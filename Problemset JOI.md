# JOISC 2017 Day 1 港口设施

首先可以发现如果，两个区间相交且不包含，那么这两个区间所分配到的颜色一定不相同

如果对于所有有交的区间对建立一条边，如果所有联通块都是二分图，那么答案就是$2^{cnt}$$cnt$为联通块数量，否则为0

## Solution 1

首先需要将区间**按左端点排序**得到的序列$s$，然后以**右端点**枚举区间，并且一个区间在枚举结束后需要从$s$中删除

考虑当前的区间范围为$[l,r]$，那么对于$s$中左端点在$[l,r]$的区间，都要跟当前的区间连一条边，可以发现进行连边的一定是当前$s$中**一段连续的区间**

但是复杂度依然是$O(n^2)$

注意到如果对于$s$中下标在$[a,b]$的区间进行了一次连边操作之后，这些区间都是联通的，并且在二分图染色的过程中颜色也一定是相同的

那么对于之后进行连边操作$[c,d]$，如果$t=[c,d]\cap[a,b]\neq \emptyset$那么没有必要对于所有交集$t$内的再连一次边，只要对于向其中一个连一条边即可

由于一定是一段区间，那么每个节点维护连完这条边后下一个需要连边的位置$nxt$

在枚举某一个区间的时候，按维护的信息，进行连边，并将所有进行连边的$nxt$置为下一个区间

由于还需要从$s$中删除元素，那么考虑用并查集维护，删除一个元素就将这个元素向右边合并

## Solution 2

**考虑在原图上找出一个生成森林，然后利用生成森林对区间进行染色，然后判断是否合法**

那么相当于每一个节点只要向父亲节点连一条边即可

考虑将所有区间按右端点排序，在枚举到某一个区间的时候，查询左端点被覆盖了哪些区间，然后将当前区间跟这些区间连边，然后将这些区间删除，结束枚举时，用当前区间更新覆盖

那么考虑用线段树进行维护，在区间覆盖的时候，进行标记永久化，每一个线段树节点开$vector$进行存储，在查询的时候，遍历$vector$中的区间，判断是否已经进行连边，然后清空$vector$

然后进行染色判断的时候，可以利用树状树组维护两种颜色的覆盖范围

复杂度$O(nlogn)$

## Solution 3

考虑进行分治，大概做法跟$Solution1$类似

# JOISC 2018 Day 2 路网服务

乱搞题

首先可能**先写一个暴力的爬山算法**，会发现从某一个点不断连边才是最优的

那么就枚举每一个点作为连边的起点，然后不断爬山，寻找最优解

但是在计算某一个方案的价值的时候，直接去计算是$O(n^2)$并且没有继续优化的空间，在进行爬山的时候效率就很低，那么就可能需要牺牲一些正确性，以加快计算效率

那么就以到连边中心的距离之和作为价值函数，那么计算一次效率是$O(n)$

但是这样直接爬山也很慢，在调整邻域的不要将所有的都枚举到，随机几个枚举即可

这样只能得83分左右

然后对于跑出来最优的节点，在程序中就不去枚举其他的节点，就是以当前这个节点为中心，试图优化方案，这样可以将爬山次数开的较大，那么就可以得到100分

# JOI 2018 Final 毒蛇越狱

首先最简单的做法就是枚举所有$?$的子集，最坏复杂度$O(2^Lq)$

但是注意到每一次询问的字符串中不止是有$?$还有$0,1$上面那个做法没有利用到，有三种字符的性质

可以发现如果记$a,b,c$为上面三种字符的个数，那么$min(a,b,c)\leq 6$如果每一次询问是利用出现次数最少的字符进行枚举，那么复杂度为$O(2^{\frac{l}{3}}q)$就可以过了

考虑1如果进行统计，对于每一个$?$所在的位置，将其看出$1$，然后统计得到数的所有子集代价之和，这个可以用高维前缀和预处理

但这样统计会多算，那么容斥掉多算的，就是那些非问号部分的位上的$1$，不能为$0$，进行子集容斥即可

# JOISC 2014 Day2 水壶

首先每一次询问就是询问最小生成树上两点之间边权的最大值，可以克鲁斯卡尔重构树解决

那么要求的是网格图上的最小生成树

一开始的想法是找出每一个点最近的点，但是这样会漏掉很多边，并且本来原图上联通的点，可能只通过这些边是不连通的

那么需要使任意两个原来联通的点集，之间至少有一条边

考虑bfs过程，将所有点加入起点队列，然后进行bfs，每一个点记录离其最近的距离和是哪一个点，当扩展的点已经被扩展过的时候，离当前点最近的起点和扩展点最近的起点连边，边权为当前点和扩展点的距离之和

注意到这样连边，一定将所有最小的边包含在内，并且保证如果原来图上联通，得到的边集中一定有连接两个点集的边，根据bfs的性质就可以发现

# JOISC 2017 Day 3 幽深府邸

大体上都想到了，应该静下心来分析一下复杂度

考虑某一种钥匙有用的只有两个，离对应的门左右最近的两个，其他的位置上如果要开这个门，那么一定会经过这两个位置之一，这两个位置分别记作$l_i,r_i$

还有某一个位置所可以到达的范围一定是一段区间$[a_i,b_i]$

那么考虑一开始先将边界向右扩展，考虑什么时候不能扩展，当且仅当$l_{b_i}< i$的时候才再进行扩展了，考虑预先处理出这个边界，可以利用栈来$O(n)$求出

但是还需要考虑左边界的扩展，由于刚才将右边界扩展完毕，那么1号位置上最终可以到达的位置区间就是$[1,b_1]$

考虑向后进行扩展，如果当前位置$i$左边的那个门可以被打开，也就是说$r_{i-1}\leq b_i$，那么就可以继承i-1的信息

- 如果$b_{i-1}\geq b_i$那么显然不能继续扩展区间，那么直接继承过来
- 否则，还是有可能继续扩展区间，判断一下左边界的限制是否符合，然后扩展到$a_{a_i-1}$的位置，右区间也是同理，并且左右边界一定是交替更新的

考虑分析复杂度，通过上面的过程，可以发现$b_i$是单调不降的，而每一次更新至少会将$b_i$的大小增加1，而左段点能够更新，也是因为右端点进行了更新，而左端点解除的限制只有落在，更新前右端点和当前右端点之间，才可以进行更新，而注意到总共的限制只有$2(n-1)$个，那么总复杂度$O(n)$

# JOISC 2019 Day 2 两个天线

首先需要考虑离线扫描线

考虑从后往前扫描，假定当前扫描到的点是点对中下标较小的那个

那么对于每一个$i$，其合法区间为$[i-b_i,i-a_i]$，那么可以通过在$i-a_i$位置上打上+1标记表示加入当前合法点集，和$i-b_i-1$位置上打上-1标记表示移出当前合法点集，然后对于当前扫描到的点j，当前在合法点集中可以跟其产生贡献的是$i\in [j+a_j,j+b_j]$这些点

注意到，如果将所有下标为$i$（并且$i$是点对中较小的那个）的合法点对，记录在$i$上面，会发现询问难以处理，主要是因为有r的限制，导致了不是所有$i$的合法点对都能算入答案中，那么考虑换一个角度，既然我们是扫描线，对于一个询问$[l,r]$只要扫描到$l$处，**那么当前已经处理的$i$一定是满足$i\geq l$，并且有$j> i$**，那么如果我们将贡献记录在$j$上面，那么只要统计$j\in [l,r]$内的答案（这个显然可以利用线段树高效处理），那么就自然而然的满足了$i\in [l,r]$的条件

接下来讨论如何计算贡献，首先$|h_i-h_j|=\max(h_i-h_j,h_j-h_i)$那么只要正着做一遍$\max h_i-h_j$，然后将h取相反数再做一遍，就是原来的贡献

那么考虑在线段树节点上维护，当前时刻，区间内合法最小的$h_j$，可以跟这段区间合法$j$进行交流的最大$h_i$，从当前时候到开始时刻区间内所产生的点对的最大值

加入新的合法点，就是单点修改，扫描线向左移就是区间取$max$，询问区间查询最大值

需要注意的是，可以跟这段区间合法$j$进行交流的最大$h_i$，需要向标记一样进行下传，并且下传之后需要删除这个节点的标记，这是因为之前进行区间修改的时候，某一个区间内的位置还是不合法，但现在修改为合法，那么之前打的标记就不能和当前修改为合法的点进行配对，而在单点修改的时候，标记被下传到叶子节点，那么在修改的时候，将标记删除即可，可以发现该位置到根节点的路径上不会存在任何标记，符合要求

# JOISC 2017 Day 1 烟花棒

首先，所有人都会向当前烟花点燃的人靠近，并且下一个接火的人一定在上一个人的烟花熄灭的时候在接上，如果这个先接上并且反向，那么由于后面的人依然跟着前面的人，相对距离不变，不会变得更优，如果继续向前，那么会跟着前面烟花点燃的人一起跑，浪费了时间，变得更劣

那么在任意一个时间，只有一个人的烟花是被点燃的，那么一开始这个人需要花费一定的时间跑到下一个人的位置上，然后相当于这个人烟花的燃烧时间增加了$t$

那么问题转化为，第$k$个人左边的人可以看做一个队列，右边的人可以看做一个队列，每一次取出其中一个队列的队首，付出一定的时间，然后再获得t的时间，并且过程中始终保持时间$\geq 0$，由于时间可能为小数，那么转化为距离

设第一个队列，净获得距离的前缀和为$A$，第二队列为$B$，假设当前在$A$中的$x$位置，$B$中的$y$位置，需要满足$2vt+a_x+b_y\geq 2vt\rightarrow a_x+b_y\geq 0$的条件

首先进行二分，考虑贪心

如果存在一个位置$i$，使得$a_i>a_x ,\min(a_x,a_{x+1},...,a_i)+b_y\geq 0$，那么一定可以将$x$替换为$i$，另外一边也是同理

当不能更新的时候，并且其中一个位置不是后缀最大值，意味着永远到不了后缀最大值的位置，那么一定不合法

如果存在x,y后面，存在一个位置与x,y不满足条件，那么一定不合法

否则将x,y之一调整为后缀次大值，如果不能调整，那么也不合法

# JOISC 2020 Day 1 汉堡肉

首先需要先考虑一维的情况是怎么样的，相当于是给定若干个区间，要用最少的点覆盖所有的区间，那么贪心的做法首先找到区间右端点最小的区间，然后在这个端点上放置一个点即可，然后删除被这个点覆盖的区间，然后重复这个过程即可

那么原问题就是这个问题的二维版本，一种最简单的想法就是找到最小的矩阵右边界以及最小的矩阵上边界，那么说明在这两个位置一定需要存在一个点，但是这样做会有一个问题，就是并不知道点要放在哪里，而是要进行枚举，显然复杂度无法接受

注意$k\leq 4$，4也就对应着了矩阵的四个边界，那么就需要找到最小的矩阵右边界，最小的矩阵上边界，最大的矩阵下边界，最大的矩阵左边界，那么说明这四个边界上一定要存在点

对于$k\leq 3$的情况，可以发现其中必有一个点是落在四个边界的交点位置，那么这个点可能的坐标只有4个，那么直接暴力枚举是哪四个坐标即可，在枚举完坐标之后，将被这个点覆盖的所有矩阵删除，然后继续递归解决子问题即可，这样的时间复杂度为$O(4^kn)$

接下来就需要考虑$k=4$的情况，在这种情况下，如果四个点都在边界上而不在交点位置的话，那么上面的做法就不对了

那么考虑如何确定这四个点的位置，那么就需要考虑其他矩阵对这个边界的限制情况，如果某一矩阵只部分覆盖了某一个边界

<img src="D:\Blog\image\image-20220123165318330.png" alt="image-20220123165318330" style="zoom: 20%;" />

这种情况就是只覆盖了一个边界，那么只要对这个边界的坐标可能的范围与这矩阵取交即可

如果某一个矩阵覆盖了3或者4个边界的话

<img src="D:\Blog\image\image-20220123165546753.png" alt="image-20220123165546753" style="zoom:20%;" />

这个矩阵一定完全覆盖了某一额边界，由于每一个边界上是存在一个点的，那么这个矩阵一定可以被点覆盖到

如果某一个矩阵覆盖了2个边界的话

<img src="D:\Blog\image\image-20220123165811482.png" alt="image-20220123165811482" style="zoom:20%;" />

<img src="D:\Blog\image\image-20220123165837800.png" alt="image-20220123165837800" style="zoom:20%;" />

那么相当于这矩阵要选择一个边界，将这个边界上的点限制到矩阵内部，那么显然如果这样的矩阵与其他限制这个边界的矩阵在这段边界上没有交的话，那么两个同时选，就会导致不存在解的情况

那么相当于每一个矩阵有两个选择，其中有若干限制，要求一个矩阵选择其中一个选择使得另外一个矩阵不能选择某一个选择，那么可以使用2-sat进行解决

# JOISC 2019 Day1 聚会

首先可以发现的是如果确定了一个节点一定要选之后，那么就可以将这个节点作为根，然后所有边指向根节点的都是不需要支付代价的

那么只需要考虑反向的边即可，剩下的问题就和[CF526G](https://codeforces.com/contest/526/problem/G)很像，显然可以建出一个费用流模型，通过模拟这个费用流的过程可以发现我们选择当前剩下未计算贡献的边中最长链，可以通过长链剖分解决

但是能这样做的前提条件是预先确定了根，如果没有确定根那么一开始指向根节点的边就会产生影响

首先如果只选一个节点的话，那么直接选指向根节点边权最大的即可

如果选两个节点以上的话，那么需要一个结论就是已经选过的点不会变回不选的点，至于证明可以先讨论一下多一个点的时候将之前选择的点撤销掉，应该是可以推出矛盾的（主要是因为选择的节点一定都是叶子节点，那么子树只有一个，稍微讨论一下就会发现如果将选择的其中一个叶子节点作为根，然后撤销这个根，一定会导致选择的权值减少）

那么可以通过换根求出选择两个点时候最大的根节点，然后套用之前那道题的方法即可

# JOISC 2022 Day 4 复兴计划

考虑固定询问的$x$，那么我们可以将边集分成两部分，一部分的边集中的边权都是$\leq x$，一部分的边集中的边权$>x$，那么可以分别对这两个边集分别求出最小生成树，那么最终的最小生成树中边一定是在这两个最小生成树中的

如果直接暴力合并的话，时间复杂度$O(nq\alpha (n))$是不能通过的，那么就需要进行优化

可以发现的是每一条边出现在$x$中的最小生成树中的合法$x$一定是一个区间

如果我们将所有边出现的位置的区间求出，那么就可以在$O(q)$时间内计算答案

可以考虑按照边权从小到大加入边，然后同时维护一个生成树，如果当前加入的边可以合并两个联通块的话，那么说明从$x=0$开始这条边一定在最小生成树中，那么就可以确定这条边的出现区间的左端点

如果当前加入的边不能合并两个联通块的话，那么可以找到形成环中边权最小的边$(u,v)$，那么当前边能够出现在最小生成树中需要满足其权值比$(u,v)$这条边的权值小，那么就可以确定当前加入边区间的左端点。然后将$(u,v)$这条边删除，加入当前边即可

由于加入的边都是按照权值从小到大加入的，那么我们当前维护的生成树就是前缀的最小生成树，并且同时考虑了后缀最小生成树中的边的影响

这样的时间复杂度可以做到$O(mn+q)$，如果使用LCT，可以做到$O(m\log n+q)$

# JOISC 2020 Day 2 遗迹

先说第一种做法

首先考虑在确定$h$的情况下如何求出最终高度不为0的位置，那么首先考虑下标最大的位置$2n$，那么在每一次操作中都是不会改变$h_{2n}$，那么相当于最终数字为$h_{2n}$的位置就在$2n$

然后考虑$2n-1$，同样如果$h_{2n-1}\neq h_{2n}$的话，所有操作都是不会影响这个位置，当$h_{2n-1}=h_{2n}$，那么$h_{2n-1}$需要减1，那么这样就可以得到一个做法

记$pos_i$表示最终数字$i$所在的位置，一开始都是0，那么可以考虑从2n开始往小的进行枚举，然后令$j\in [1,h_i]$满足$pos_j\neq 0$的最大$j$，那么可以令$pos_j=i$

那么可以对这个过程进行计数，设$dp(i,j)$表示考虑了$[i,n]$的下标位置，当前$pos$前$j$个不等于0的方案数

假设当前$(i,n]$区间中有$A$个位置最终数字=0，$B$个位置最终数字$\neq 0$

**但是注意到这样设置状态的话，对每一种数需要放置两个位置的限制是很难处理的，那么可以强制让这两个位置不等价，最终方案数除以$2^n$即可**

- 如果当前加入的是最终数字=0的话，那么只能选在$[1,j]$中，那么$dp(i,j)=dp(i+1,j)\times (j-A)$

- 如果当前加入的是最终数字$\neq 0$的话，那么就不能选在$[1,j]$之中，一种可能是会扩展$j$，另一种可能是不会扩展但是又记录不到状态中去，那么解决办法就是在当前转移的时候不考虑加入这个数字带来的影响，当需要扩展$j$的时候再统一确定方案数和状态，**就是放到之后进行处理，避免状态数的退化**

  - 那么首先是没有扩展的情况$dp(i,j)=dp(i+1,j)$

  - 存在扩展的情况，那么可以枚举一个$k$表示从$1...j-k$变成了$1...j$，那么$dp(i,j)=\sum\limits_{k\geq 1} \binom{B-j+k}{k-1}\times g(k-1)\times (k+1)\times dp(i+1,j-k)$，其中$g(k-1)$表示将$k-1$个位置形成一个连续段的方案数

    $g(x)$可以通过DP求出，就是如果要形成一个连续段的话，那么$1\leq x\leq i$的$x$个数$\leq i$，那么设$f(i,j)$表示当前枚举的值域为$i$的时候，用了$j$个位置的方案数

    $f(i,j)=f(i-1,j)+2j\times f(i-1,j-1)+j\times (j-1)\times f(i-1,j-2)$

时间复杂度$O(n^3)$

还有一种从$h$推出最终$\ne 0$的位置的判断方法，就是可以维护一个下标集合，记$a_{i,0},a_{i,1}$表示初始时候$i$这个数所在位置的下标

那么初始令下标集合$s=\empty$，然后从小到大枚举$i$，令$s\cup\{a_{i,0},a_{i,1}\}$，然后取出其中的最大值$\max s$，并从$s$中删除，那么$\max s$就是数字$i$最终所在的下标

可以从2n枚举，不断放置下标数字在序列中，同样可以用类似的方法得到完全一样的做法，重要的步骤就是

1.**强制让这两个位置不等价，最终方案数除以$2^n$即可**

2.**就是放到之后进行处理，避免状态数的退化**
