# ABC234G **Divide a Sequence**

这道题在DP过程中主要有一个类似$\min(A_j,...,A_i)\times dp(j-1)$的值需要维护

## half optimized algorithm

当时在比赛的时候维护的是用线段树进行维护，还二分出需要修改最大最小的区间，这样第一发TLE了

然后用单调栈求出区间，将复杂度变成一个log，这样才过

## optimized algorithm

事实上可以用单调栈进行维护这个值，见Ideas and Tricks(data structure II) 34

### 34.关于$\min(a_j,...,a_i)$的形式的DP优化

一般来说都是从小到大枚举$i$，然后利用这个式子进行计算DP的值，一种复杂的做法是用线段树维护这个值，会比较复杂

简单的做法就是维护一个从小到大单调栈，然后在后面加入一个新的元素的时候，可以合并栈顶的若干个元素，同时更新需要维护的DP值

这样的时间复杂度是$O(n)$也很好写

# CF1616D Keep the Average High

$A_i\rightarrow A_i-x$转化过之后就是尽可能选出位置，使得形成的连续段中不存在长度大于等于2的连续段使得和$<0$

比赛的时候还是用DP然后线段树维护，写代码的时间花费比较大

## optimized algorithm

考虑一个如何判断向之后加入一个数的做法，首先求出前缀和，可以在遍历过程中记录当前这个段中的最大的前缀和，如果当前加入的位置的前缀和比当前段的最大前缀和小，那么说明加入当前这个数就是不合法的

那么一遇到这样的情况直接跳过这个位置，答案-1，显然这样最优，因为就算调整前面使得当前段包含这个位置，得到的答案还是不会比当前更优，并且当前这种情况将最大前缀和清0一定不劣

# TCO17 Semifinal 2 RatingProgressAward

## 题目大意

给定一个DAG，需要求出最优的一个拓扑排序，使得其点权的最大子段和最大，输出答案



如果不是选一个区间的话，那么显然是一个最大权闭合子图的问题

有一种思考方式是观察到最终结束的位置一定是一个负权点，如果有正权点那么一定会选择这个点，由于整个点集被分成了三部分，最大权闭合子图能计算的是后两个部分的和的最大值，那么我们可以进行差分，减去第三个部分

用到最大权闭合子图的思想，残量网络上与S相邻的都是闭合子图，与T割掉的边表示选择负权，与S割掉的边表示不选的正权，答案就是将所有正权边-最小割，那么由于差分的那部分贡献是负的，那么所有正权点向T连权值的边，然后第一层S向这个点连正权边，然后考虑负权，由于割掉这个条边相当于选择了这个点，不割相当于结束，那么i向第二层的i连一条边即可

## optimized thinking process

就是由于点集被划分成了三部分，相当于每一个点可以在这三部分之间，由于部分之间只能前后连边或者自身连边，并且如果选在中间那个部分，那么就有贡献，原来图中连边就是限制，那么直接用最小割解决即可
