# CF605E Intergalaxy Trips

把样例模拟清楚这道题就会做了

先设$dp[i]$表示从第$i$号节点到第$n$号节点最小期望

由于是贪心的选择最小期望值走过去，那么可以想到像最短路一样转移过去，其实就是DP转移有后效性，用最短路优化一下

考虑如何转移，对于一个节点$i$，可以走向的节点是那些已经固定下来期望的节点，人在这个节点的时候会根据连边情况，来决定往哪边走

因为这些已经固定的点的期望是单调的（最短路的性质）

那么把式子写出来是这样的，假设期望递增

$dp[i]=1+(\prod\limits_j(1-p[i][a_j]))dp[i]+\sum\limits_{j} (p[i][a_j]\prod\limits_{k<j}(1-p[i][a_k]))dp[a_j]$

然后移项，把$dp[i]$解出来即可，每一次更新的时候选择未固定节点进行转移即可

转移过程中维护一下那个连乘即可

[代码](https://codeforces.com/contest/605/submission/100629018)

# CF838D Airplane Arrangements

很妙

首先可以看作人从选定的节点出发，然后不断往某一个方向走，直到走到空座位或者走出门，由于有门的限制，这就需要枚举前后缀的长度，我推了一下式子，至少需要$O(n^2)$并且如果要继续优化需要组合数下指标求部分和

那么不妨把前后门接起来，这样所有的座位就变成了一个环，把飞机外面的空间也看作一个空座位标号为$n+1$，那么一个方案合法，当且仅当$n+1$这个座位为空

由于环上所有的元素都是等价的，相当于是说某一个方案，通过旋转可以从到达不同的地方，那么只有每一个位置非空的概率相同，才不会导致矛盾

那么$n+1$号座位为空的概率为$\frac{n+1-m}{n+1}$

总方案数为$(2(n+1))^m$

答案为$\frac{n+1-m}{n+1}(2(n+1))^m$

[代码](https://codeforces.com/contest/838/submission/100981662)

# CF1392H ZS Shuffles Cards

首先需要注意到的是，总期望等于期望进行洗牌的次数乘以一轮中期望第一次抽到鬼牌的次数

严谨的证明如下（Benq写的）

$\begin{align*} E[\text{\# of seconds until game ends}]&=\sum_{i=1}^{\infty}E[\text{contribution of }i\text{-th iteration}]\\ &=\sum_{i=1}^{\infty}P[\text{game did not end after }i-1\text{ iterations}]\cdot E[\text{length of }i\text{-th iteration}|\text{game did not end after }i-1\text{ iterations}]\\ &=\sum_{i=1}^{\infty}P[\text{game did not end after }i-1\text{ iterations}]\cdot E[\text{length of any iteration}]\\ &=\left(\sum_{i=1}^{\infty}P[\text{game did not end after }i-1\text{ iterations}]\right)\cdot E[\text{length of any iteration}]\\ &=E[\text{ of iterations}]\cdot E[\text{length of any iteration}]\\ \end{align*}$​

主要的思路就是每一轮抽卡都是独立的，也就是说每一次抽卡的次数不会受当前已有卡的集合影响

那么现在要求的两个期望就可以分开求

考虑求出一轮中期望第一次抽到鬼牌的次数

这个期望等价于，在第一张鬼牌之前牌的数量，考虑除$m$张鬼牌之外，只有一张正常的牌，那么这张牌排在所有鬼牌之前的概率是$\frac{1}{m+1}$，由于贡献为$1$，那么期望也为$\frac{1}{m+1}$，那么根据期望线性可得答案为$\frac{n}{m+1}+1$

再考虑求出期望要进行多少次洗牌

设$dp[k]$表示当前还有$k$个没有在集合里的牌

由于不考虑具体抽了几次，那么就可以看作牌堆中只有$k$个还没有在集合中的卡还有$m$张鬼牌，那么考虑第一张牌，是没在集合中的卡的概率为$\frac{k}{m+k}$，那么就可以删掉这张牌，转化为$dp[k-1]$，鬼牌的概率为$\frac{m}{m+k}$，这一轮立刻结束，重新洗牌，转化为$dp[k]+1$

$dp[k]=\frac{k}{m+k}dp[k-1]+\frac{m}{m+k}(dp[k]+1)$

$dp[k]=dp[k-1]+\frac{m}{k}$

其中$dp[1]=m+1$因为只有一张牌，只要这张牌出现在第一个位置上，那么立刻结束，其概率为$\frac{1}{m+1}$

主要是第一步，这种迭代的问题，每一次洗牌之后都可以看作一个重新的开始

[代码](https://codeforces.com/contest/1392/submission/101227679)

# CF643F Bears and Juice

根本想不到，想到也想不清楚为什么，终于想出来为什么了

首先抛出一个式子$\sum\limits_{k=0}^p \binom{n}{k} q^k$表示用$q$天，可以确定酒桶最多桶数

需要这样考虑，首先考虑两桶饮料之间的关系，喝这两桶饮料熊的集合（如果哪一天喝的不同，算是不同集合）肯定不会相同，否则就区别不出这两桶饮料，并且一头熊不会喝同一桶饮料多次，这个是显然的

有了这个性质，那么可以断言最多桶数就是可以产生不同集合的数量

大概就是由于有酒的桶就只有一个，通过观察分配到这个桶集合的熊和去睡觉的时间，就可以确定是这个桶有酒，应为其他桶的集合不会因为喝了其他桶的果汁产生任何变化，那么只需要保证所有桶的集合不同即可

那么考虑枚举集合内有多少个熊和喝天数的分配，就可以得到上面的那个式子

[代码](https://codeforces.ml/contest/674/submission/103544892)

# CF757E Bash Plays with Functions

我怕不是傻了

Solution1:

$f_0(x)=2^{g(n)}$，其中$g(n)$表示$n$有多少个不同的质因子

$f_r(n)=\sum\limits_{d|n} f_{r-1}(d)$

那么最终$f_r(n)=\sum\limits_{d|n} F(r,n,d)f_0(d)$

其中$F(r,n,d)$就是接下来要算的系数

若$n=p_1^{R_1}p_2^{R_2}...p_k^{R_k}$，记$(R_1,R_2,...,R_k)$来表示$n$

假设当前的$d$可以表示为$(R_1',R_2',...,R_k')$，$\forall i\in[1,k],R_i'\leq R_i$

注意到在$r$不断减小的过程中，$d$只会减小，相当于问题转化为当前有$r$次操作，每一次操作可以给当前的数乘上若干质因数，问有多少种方案使得$r$次操作过后，当前的数变成$n$

可以发现每一个质因数都是独立的，只要最后将方案相乘即可，对于单独的某一个质因数，方案数相当于$r$个不同的盒子有$R_i-R_i'$个相同的球，盒子可空，问有多少种方案，插板法即可，记$h[k]$表示结果

但显然我们不能枚举每一个其因数，那么考虑$DP$，设$f[i][j]$表示前$i$种质因数，$R_i-R_i'$之和为$j$的贡献总和，在转移的时候需要将$f_0$同时统计进去

$f[i][j]=\sum\limits_{k}(1+[k\neq R_i])f[i-1][j-k]h[k]$

Solution2:

$f_0$其实是一个积性函数，证明显然

由转移式可以知道，$f_r$是$f_{r-1}$与$I$狄利克雷卷积的结果，也是积性函数

$n=p_1^{R_1}p_2^{R_2}...p_k^{R_k}$

$f_r(n)=\prod\limits_{i=1}^{k} f_r(p_i^{R_i})$

$f_r(p_i^{R_i})=\sum\limits_{k=0}^{R_i} f_{r-1}(p_i^{k})$

前缀和优化即可

**还有，对于询问$10^6$次，值域$10^6$的分解质因数，可以利用线性筛筛出来的最大素因子来快速分解**

# CF582C Superior Periodic Subarrays

又是一道把我卡死的数论题

首先考虑长度为$s$的子串，其周期是$\frac{n}{gcd(n,s)}$，考虑在周期内会经过哪些点

列出同余方程$ks\equiv id$改同余为等号$ks+nx=id$，那么方程有解的条件为$gcd(s,n)|id$

那么如果在子串内出现第$i$号位置，那么$i$会经过的位置$j$满足$i\equiv j(mod\ gcd(s,n))$（完美错失重要结论），那么$a_i$就是这些中最大的

考虑枚举$n$的因数，对于每一个同余结果统计最大的数及其位置，那么可以通过计算后缀和统计出贡献，这部分简单

[代码](https://codeforces.com/contest/582/submission/108028631)

# CF698C LRU

我突然发现写CF题解的都是数学题，那么这道也不例外

是道好题

## solution 1

首先一个操作序列的概率如何计算，就是这个序列中所有元素的概率乘积，那么不论是从后往前还是从前往后，计算得到的概率都是一样的，由于我们求的是最后剩下的那$k$个数，那么考虑从后往前计算

最终剩下的$k$个数一定是这个序列最后$k$种元素，那么考虑设$dp[s]$表示在某一个操作序列的后缀中，出现了集合为S的元素的概率

考虑转移，枚举$i\notin S$作为下一个加入的元素，由于可以选已经出现过的元素，那么转移就为
$$
dp[S\cup i]=\sum\limits_{j=0}^{\infty}sum(S)^jp_i=\frac{p[i]}{1-sum(S)},sum(S)=\sum\limits_{i\in S}p_i
$$
需要注意$p_i\neq 0$的个数小于$k$的话，需要特判

## solution 2

考虑某一个元素在最终序列的条件，就是在这个元素加入之后，新加入的元素种类小于$k$个，那么去枚举这些集合$S,|S|< k,i\notin S$，$S$中的元素至少出现一次

考虑对至少出现一次进行容斥，然后就是简单推式子，思想值得借鉴

# CF196E Opening Portals

好题好题

首先由于一个传送点可以以$0$代价传送到另一个传送点，那么答案就是将这$k$个关键点联通的路径价值之和（考虑树的情况就可以发现，就是在祖先向下走到儿子之后，下面没有其他关键点，那么就从这个点跳到这个点的直接祖先，然后从祖先出发向另一个子树走，那么走过的路径只有树上的边，并且只走过一次）

并且此处连接两个点的代价就是原图上这两个点之间的最短路（可能有原图上的边被重复走过），那么只要考虑两两之间最短路，然后跑最小生成树就是答案

但是直接这样做边数是$O(n^2)$的，考虑减少不必要的边

考虑进行克鲁斯卡尔算法的过程，如果某一条边的边权比当前边大，那么这条边一定在当前边之后才进行判断

那么希望找出尽可能少的边，并且保证边权都是最小的，而且使图联通

由于原图是保证联通的，那么考虑利用原图上的边

设$p[x]$表示离$x$最近的关键点

对于原图上的边，考虑离边两个端点$u,v$最近的关键点$p[u],p[v]$，将$(p[u],p[v],dis(p[u],u)+dis(p[v],v)+w(u,v))$加入候选边中，这样一定是找到所有经过这条边的最短路中，最短的一条

并且一定保证所有关键点联通，因为如果存在两个集合不连通，在原图上一定存在连接这两个集合的边，并且这条边的两个离两个端点最近的关键点一定分布在两个集合中，那么与上面的算法过程矛盾

那么只要对$m$条边做最小生成树即可

主要思想就是删去一定比最优更劣的边，将状态压缩至$O(m)$级别

然而这道题让我发现我的$dij$是假的。。。要加判断

# CF506E Mr. Kitayuta vs. Bamboos

 一开始的想法是，先二分答案，将最优化问题变为判定性问题

对于每一个竹子处理出来第一次大于$mid$的时间，然后每一轮都按照时间贪心地选择，用堆进行维护，但是这样会有问题，就是对于超过限制时间相同的竹子就不知道是选哪一个，由于要将高度减$p$，而且要跟$0$取$max$，$p$不会减全，就不知道哪个是最优的

进行倒序考虑，假设一开始所有的竹子高度都是$mid$，每一轮要将竹子的高度减$a_i$，每一轮可以选出$k$个竹子将高度拔高$p$，合法条件就是在每一轮之后每一个竹子的高度都是$\geq 0$，并且最后得到的高度$\geq h_i$，那么按照类似上面的做

就是对于$m$天之后高度会比$h_i$小的竹子用堆进行维护，最早$<0$的时间，贪心选择即可

考虑这样为什么是对的，因为每一次$+p$，都是完全加上$+p$，对于时间相同的竹子，从整体上来看都是一样的

# CF526F Pudding Monsters

首先需要按某一维进行排序，对于下标为$i$的，其另一维的高度为$a_i$

某一个子区间$[l,r]$合法当且仅当$r-l=MAX-MIN$

那么接下来套路性地考虑分治

那么考虑越过分治线的所有区间，将这些区间拆分成两段，讨论最大值最小值在左边还是右边，预处理前缀$MAX/MIN$，然后双指针维护即可

# CF587F Duff is Mad

挺好的数据结构题

首先考虑暴力如何实现，将所有串建立$AC$自动机，对于一个询问，将$[l,r]$串中结尾节点在$fail$树上的子树中所有节点价值$+1$，然后用$s_k$在$AC$自动机上进行匹配，询问的答案就是所有访问节点的权值之和

但是显然如果询问的$s_k$的长度很大，这个算法的复杂度就是$O(n^2)$

考虑将贡献转化，考虑统计每一个$i\in[l,r],s_i$对$s_k$的贡献，那么就是将所有$s_k$的节点权值设为$1$，然后对于$s_i$每一个节点的子树和进行统计

然后考虑根号分治，对于所有长度大于B的，采取第二种的方法，预处理出来所有的前缀和，对于询问$O(1)$查询，由于大于B的串不超过$O(\frac{m}{B})$个，那么总复杂度为$O(\frac{nm}{B})$

对于所有长度小于B的串，采取第一种方法，将所有询问拆成两个询问，那么相当于现在每一个询问的区间都是一个前缀，然后离线下来，从前往后扫描，加入的新串需要对于子树内所有节点+1，然后询问需要单点查询，这可以用树状数组进行维护，复杂度$O(QB\log n)$

如果使用修改$O(\sqrt n)$，询问$O(1)$的值域分块进行维护的话，最终复杂度就是$O(n\sqrt n)$

# CF587D Duff in Mafia

首先需要发现的是，对于每一条边来说，只有两种状态，在匹配中或者不在匹配中，这就需要联想到$2-sat$

由于题目所求显然可以二分，那么就变成了$2-sat$的判定问题

像这种状态只有$2$种，并且判定性问题，需要想到$2-sat$

假设某一条边$x$，被选到匹配中的状态是$x$，没有选到匹配中的状态是$x'$

考虑如何进行建图，首先对于剩下相同颜色的边进行分析，由于每一个点只能被一个边覆盖到，那么对于具有相同端点的边最多只能有$1$条边不被选到匹配中，那么可以发现如果某一个点连出的边有$3$条及以上的边是相同颜色的，那么这个图一定选不出来合法方案，那么对于相同颜色的两条边$x,y$连$x'\rightarrow y,y'\rightarrow x$

在考虑选到匹配中的边，对于两条边$x,y$连$x\rightarrow y',y\rightarrow x'$，但是直接连边规模是$O(n^2)$的

考虑前缀优化建图，对于两种状态分别用两种不同方向的链链接起来，但是需要注意自己不能连向自己

![TIM图片20200117230357](D:\Blog\image\TIM图片20200117230357.png)

# CF506E Mr. Kitayuta's Gift

考虑可以$DP$，对于一个回文串来说，如果包含$S$的子序列，那么这个回文串就是合法的

首先考虑长度为偶数的回文串

设$dp[i][j]$表示考虑回文串前半部分，从前匹配到第$i$位，从后匹配到第$j$位的方案数

那么只要考虑下一位是否跟当前相当，第$i$位是否跟第$j$位相等，就可以进行转移，直接转移复杂度$O(n|S|^2)$

如果使用矩阵乘法优化复杂度$O(|S|^6\log(n+|S|))$

<img src="D:\Blog\image\61e9c25b977bad7af00165b92070a9acabf16704.png" alt="61e9c25b977bad7af00165b92070a9acabf16704" style="zoom:67%;" />

事实上$dp$的状态是一个$DFA$，如上图所示，但是这个$DFA$显然存在压缩的空间

最开始的起点就是右上角的那个点，终点就是$GOAL$，事实上，$DFA$本质上形成的一个矩形，如果不存在斜向连边的节点，那么就是矩形路径计数，由于还存在自环，可以将某一条路径单独提取出来，进行矩阵乘法，然后乘上这样路径的条数

如果再考虑斜向的节点，如果当前非斜向节点有$a$个，那么斜向节点在路径上有$\lceil \frac{n-a}{2}\rceil$个，事实上斜向节点在路径上的分布不影响总路径的数量，那么本质不同的路径数量只有$O(|S|)$级别，那么对于每一种路径统计在原来的DFA上有多少条，这个可以通过$dp$在$O(|S|^3)$内完成

那么对于每一条本质不同的路径，都进行一次矩阵乘法，那么时间复杂度为$O(|S|^4\log(n+|S|))$

但这样依然不够，考虑将所有路径放在一起统计，由于斜向节点顺序不影响答案，那么将所有斜向节点放在最后面，可以发现，每一条本质不同的路径的前缀后缀会有大量重叠的部分，那么将这些重叠部分合并，得到的就是$O(|S|)$节点数的$DFA$，复杂度$O(|S|^3\log(n+|S|))$

# CF603E Pastoral Oddities

首先需要发现，一个环对于环上每一个点的度数贡献都是$2$，那么如果将这个环去掉，那么每一个点度数的奇偶性不变，那么最终得到合法的图一定是森林

然后再考虑，如果$n$为奇数，那么总度数和一定为偶数，由于不可能存在奇数个奇数相加是偶数，那么$n$一定要为偶数，那么进而推知，一张图是由若干联通块组成，那么对于一张合法的图，其中的联通块大小都是偶数

那么可以先猜出结论，一张图合法当且仅当其所有联通块大小为偶数时成立，上面只证明了其必要性，接下来考虑证明其充分性

由于知道得到的图一定是森林，那么考虑一颗树合法是怎么样

我们可以找出来一个生成树，然后从叶子开始，一个点与其父亲的连边保留当且仅当这个点与其所有儿子的连边数为偶数，那么就可以构造出来了，可以归纳证明，任何一个儿子数为偶数的子树大小都是奇数

然后，对于每一次加入，要求的就是当前时间下，最小的上限，使得所有代价小于这个上限的边，加入图中得到的联通块大小都是偶数

可以注意到，随着时间的推移，答案一定是不增的，那么考虑单调性分治，令$solve(l,r,x,y)$表示时间在$[l,r]$中，答案区间为$[x,y]$，并用可撤销并查集进行维护，在调用当前函数之前，需要处理出时间$<l$且代价$<x$的边，然后分治下去即可，复杂度$O(n\log n\log m)$

也可以用$LCT$进行维护，可以注意到加边的过程是类似求最小瓶颈生成树的过程，那么使用$LCT$进行维护最小瓶颈生成树，同时用大根堆维护所有在森林中的边，每一次加边之后，尝试删除大根堆堆顶元素，如果出现了奇数的联通块，那么就停止，需要$LCT$维护子树信息，总复杂度$O(n\log n)$

# CF1326F2 Wise Men

首先需要做一个转化，原来集合中的0，**改为表示相邻的两个人之间即可存在边也可不存在边**

那么现在得到的结果就是原答案作高维前缀和的结果，那么求出当前的答案，那么做一次高维差分就是原答案，这样就可以将两种链减少到一种链

那么考虑集合中一段连续的$1$，这些点串成了一条链，由于之前令$0$表示可有可无的情况，那么每一条链都是互相独立的不同的，只要这些链经过的点不相交，那么可以构成原来的一种方案，可以发现一个集合答案跟链的顺序无关，只能链之间有没有相交有关

那么所有链组成了对$n$个点的一个划分，那么本质不同的划分数量就是$18$的划分数大小，$P(18)=285$，是在一个很小的范围内

由于跟顺序无关，那么只要算出某一种方案，就是所有链划分为当前方案的答案

接下来需要考虑的是如何统计链互相不相交的方案数，注意到本质不同的链只有$n$个，那么对于$n$种链处理出来，$f_{i,s}$表示长度为i的链所经过点的集合为$s$的方案数，这个可以通过简单的状压$DP$得到，复杂度$O(n^22^n)$

那么似乎需要对于所有链做子集卷积，但事实上并不用，直接做普通的Or卷积，因为我们所需要的答案就是全集的答案，容易发现如果任何两条链有相交，那么其贡献一定不会被算入全集的答案中

那么在搜索划分数的同时，将每一种链的$FWT$结果相乘，最后需要手动还原一下最后全集项的结果

复杂度$O((P(n)+n^2)2^n)$

主要还是最初那一步会比较难想（后面都比较常规），其实也是比较套路，对于难以计数的问题，考虑差分或者前缀和，也可以从容斥的角度出发

# CF559E Gerald and Path

非常优美的DP

首先将所有线段按端点排序，最简单的想法就是，记录前i个点，最右端点的位置为j的答案，然后考虑转移到$i+1$，但是此时会出现问题，如果$i+1$的长度足够长，使得跨过了当前的连续段，把之前没有覆盖到的位置覆盖了，那么此处的贡献就无法统计

但同时发现如果一条线段完全包含另外一条线段，那么被包含的线段是没有用的，只要考虑包含的线段即可，那么$i+1$就可能不是在$i$的时候更新，更有可能是在$i$之前就被更新到了

那么考虑去枚举后面所有的线段$k\in [i+1,n]$，由于一旦跨过当前线段，那么方案一定不优，那么考虑**放缩**，只考虑加入新的线段和当前连续段的贡献，不考虑$[i+1,k-1]$之间线段的贡献，但需要注意的是，如果中间的线段右端点超过当前$k$的右端点，那么多出来的贡献也需要计算

考虑设$dp[i][j][dir]$表示考虑到前$i$个线段，右端点最右的线段是$j$，并且方向是$dir$，那么枚举$k\in [i+1,n]$，记$MAX$表示$[i+1,k]$中右端点最大的坐标，$wh$表示右端点最大的线段，$D$表示方向，$l$表示$j$的右端点，$r$表示$k$的右端点
$$
dp[k][wh][D]=dp[i][j][dir]+\min(l_i,r-l)+MAX-r
$$

复杂度$O(n^3)$

# CF526G Spiders Evil Plan

首先每一条路径一定是连接了两个叶子节点的，并且最开始的一条边肯定是连接直径某一个端点经过当前节点的路径

可以想到树上一条长链的底端一定是一个叶子节点，考虑长链剖分

除下第一次选择路径，其他选择路径一定是选择两条完整的长链，并且其顶上的那条轻边一定是于当前路径所形成的联通块相连

我们定义一条长链的价值为链上所有边的权值之和加上链顶上那条轻边的权值，可以注意到某一条长链的顶上的另一条长链的价值一定比当前这条长链的价值大

那么只要贪心的选取当前未选择的长链中最大的两条就一定合法

由于一开始需要选取树上两个直径端点作为根，分别算出答案，取$max$

那么对于在树上选择$y$条路径，就相当于选出前$2y-1$条价值最大的长链，但是询问需要这些选出的长链包含x的这个点，如果$x$不被包含在内，那么需要考虑调整

第一种调整方法就是自下往上找到第一个在当前选择长链中的长链，并且这条长链是x到根节点上经过的链，那么考虑将当前$x$所在的长链接上去，然后将原来长链上在连接点以下的部分去掉

第二种调整是，将一条不在$x$到根节点所经过的链，并且这条链底下不再接另外一条链的长链，将这条长链删除，然后加入当前的长链（此处也需要找到第一种调整方案中的那条链，但是不需要将连接点以下的部分去掉），考虑这条链一定需要是第$2y-1$大的链，否则第$2y-1$大的链一定是第一种调整方案中的那条链，显然第一种方案更优

那么只要将两种方案都算出来，取$max$即可

$P.S$未验证正确性，一开始我想是利用数据结构动态维护长链，一开始的时候先换根到每一个节点，考虑换根过程中，经过某一条边的时候，背离的那颗子树内最大的长链权值需要加上这条边的权值，走向的那颗子树内价值最大的长链需要减去当前这条边的权值，由于每一次换根都是只有$O(1)$个修改，那么从上自下利用主席树维护代价有序的数列，然后每次查询都是在主席树上查询前$2y-1$大的权值之和，不过好难写