# [十二省联考2019]皮配

首先考虑$50$分做法，注意到由于阵营派系的和是固定的，那么如果只记录蓝阵营和鸭派系，就可以得到所有的信息，那么可以设$dp[i][j][k]$表示前$i$个城市中，蓝阵营的人数为$j$个，鸭派系的人数为$k$个

那么就可以直接转移，其中第一维是可以滚动掉的，还要注意在转移的时候，需要将这城市的两种选择分开进行转移，然后对于每一个学校再做$0/1$背包

最后将这两种转移得到的答案相加即可更新$dp$

再考虑$k=0$的时候，由于所有的选择都是对称的，那么就可以将原来的$dp$的两维分别拆开，记阵营的背包为$F$，派系的背包记作$G$，然后就可以单独进行转移，最后把答案对应相乘即可

最后是考虑正解，注意到$k\leq 30$，那么这就提示我们单独对于这$k$个特殊的学校进行转移，考虑那些没有特殊学校的城市，这些城市可以直接套用上面的$k=0$的做法，然后考虑有特殊学校的城市，城市中可能还有其他没有限制的学校，那么这些学校一旦阵营选定，选派系可以随便选（都是对称的，那么不管选哪个阵营，其方案数都是一样），那么我们先不考虑这整个城市选了哪个阵营，对于没有特殊限制的学校套用$k=0$的做法，但把其对阵营方面的人数看作$0$，将那些有特殊限制的学校在阵营方面的人数视为整个城市的总人数，对于这些特殊学校，就用50分的做法，得到对应的$dp$数组

把这些$dp$都处理好之后，那么剩下的就是如何合并这两个做法的背包

最$naive$的做法，就是暴力卷积，复杂度$O(m^4)$

但是写出式子，可以发现，如果考虑$dp[i][j]$对答案的贡献，与之乘起来的$F$和$G$都是一段连续的区间，那么预处理前缀和即可

还有需要注意一点，在做特殊学校的$dp$时，如果一直循环到$m$，会被卡$T$一个点，需要记录前缀和，循环到当前的前缀和

[代码](https://www.luogu.com.cn/record/43772883)

# 「USACO 2020.12 Platinum」Spaceship

这道题搞了我一个晚上，歪果仁的DP还是很妙

这道题主要有两个想法，首先可以发现对于按钮序列上最大不合法位置一定是单调递增的，并且当按了最大那个之后，如果不去按更大的按钮，那么这个按钮之后就一定按不了，那么如果只考虑当前最大不合法的按钮为$x$的话，对于图上任意一个路径最多只有一个节点是按了第$x$个按钮

考虑设$dp[s][t][k]$表示从$s$出发到$t$，其中路上按下按钮的最大位置为$k$的方案数，由于这个路径上最多只有一个位置为$k$，那么考虑枚举这个位置$r$，那么$s$到$r$这一段路径和$r$到$t$这一段路径（其中这两条路径都不包括$r$）最大可以按下按钮的位置为$k-1$，那么方案数就为$(\sum\limits_a dp[s][a][k-1])(\sum\limits_b dp[b][t][k-1])$其中存在一条边$a$到$r$，$r$到$b$，这两个和式可以通过预处理得到，其中需要注意分成的左右两段可以为空，即在$i$处或$j$处按下$k$位置的按钮，需要单独处理一下

那么现在考虑处理询问，注意到询问是强制在$s$节点按下$b_s$位置的按钮，直接处理不好处理，考虑新加两个虚拟节点，表示起点和终点，那么套用上面的$dp$即可，其中$a,b$不能是特殊点，并且在处理特殊情况的时候，如果当前枚举到的$k$是符合条件的，那么才能把方案数加上去

对于多组询问，不需要每一次都重新就算一遍DP，加入$2q$个特殊点，转移的时候强制某一个询问的出发点只能对应相应的终点

但还有一种无脑做法，可以发现转移方程本质上就是在做矩阵乘法，可以预处理转移矩阵的若干次方

[代码](https://loj.ac/s/1019428)

# [ICPC2015 WF]Tours

真诚膜拜hhz

首先需要注意到如果把所有环都拆成若干个不相交的边集，那么只要在这个边集中的边内均匀分布各种颜色，那么这些集合组合起来得到的环一定也是均匀分布的，那么最终答案就是所有集合大小的$gcd$的所有因子

考虑如何拆出这些集合，有两种做法

首先对于某一个边集，那么都在某一个环里，要么都不在，那么如果把这条边断掉，那么那些存在这个集合的环，都会被破坏掉，那么对于集合中其他的边，都不会存在于任何一个环中，那么这些边形成了桥，那么只要对于原图上每一个非桥边，将这条边断掉，图上增加了$x$个桥，那么这个集合大小就是$x+1$，时间复杂度$O(nm)$

还有一种$O(n)$做法，考虑将原图的一个生成树找出来，对于那些非树边和两个端点在树上形成的路径，就形成了一个环，那么对于这个环上的边，需要被单独划分成若干集合，那么可以对于每一条边记录被非树边覆盖的集合，对于集合相同的，那么这些边就在同一个集合中，对于如何统计被覆盖的集合，可以对每条非树边随机一个值，定义一条边的权值为所有覆盖它的非树边随机值的异或和，值域较大的话，冲突概率很小，直接树上差分即可

[代码](https://www.luogu.com.cn/record/44593845)

# [ZJOI2016]大森林

首先可以发现，对于某一位上的树，其形态是固定的（也就是说，对于某一个已经加入的点，其位置是不会改变的），那么只要询问的位置合法，那么询问的答案一定不会变，那么不妨将所有的询问放到最后

然后又注意到询问只会询问那些存在于树上的点对，那么将$0$操作改为对于全体的树都进行生长是不会影响答案，但是需要保证$1$操作不对没有$x$节点的树进行修改

那么现在难以处理的就只剩$1$操作，对于某一个$1$操作，可以发现的是，对于所有在这个$1$操作之后生长的点之间的相对关系是不受这个操作影响的，那么这个$1$操作影响的只有之后生长节点的父亲，那么相当就是把这些节点的父亲改到$x$处，那么对于修改区间的影响，只要在端点处记录，左端点将子树改到$x$，右端点撤销

这个可以用$LCT$维护，但是不能直接一个一个这些节点$cut$，那么可以对于每一个$1$操作建虚点，对于某一段$0$操作加入的点，将这些点连向最近一次$1$操作对应的虚点，注意这里如果新加一个$1$操作，那么这个$1$操作的虚点也需要连向上一个$1$操作的虚点，这样才能保证对于一次修改操作，只需要$link,cut$一个点

剩下的就只剩如何求出两个点之间的距离，由于在维护的过程中强制使$LCT$有根，那么不能进行$makeroot$操作，那么需要找到两个点的$LCA$，用其深度来计算距离，对于两个点$x,y$其$LCA$就是$access(x)$后进行$access(y)$时，最后跳得一条轻边的顶节点，求深度的话，就直接$access$求出这条链上有几个实点

[代码](https://www.luogu.com.cn/record/44600396)

# [CERC2017]Buffalo Barricades

首先需要考虑倒推，先计算出不考虑加入栅栏时间，每一个栅栏围住水牛的数量这可以用从上向下扫描线，并且用$set$维护一下

在扫描到水牛的时候，在$set$里二分出其左边第一个遇到的栅栏将这个栅栏的答案加1

如果遇到是一个新的栅栏，那么暴力向左边跳，直到遇到第一个时间比这个点早的栅栏，在过程中遇到的栅栏都删去

但是还要考虑如何计算由于时间差多出来的答案，可以发现如果某一个栅栏$x$时间比另外一个栅栏$y$时间早，并且$x$包含$y$，那么$y$的答案就要加到$x$的答案上

可以发现在维护扫描线的过程中，对于某一个栅栏，其最近包含它的另外一个栅栏就是在$set$中比这个栅栏大的那一个，那么其实包含关系形成了一个树形结构，某一个点的答案就是在这个点子树内最大包含这个点的联通块原来答案之和，这个联通块不含时间比这点早的节点

那么考虑按时间顺序从后往前统计答案，那么只要用并查集维护当前联通块的总和即可

[代码](https://www.luogu.com.cn/record/44604416)

# 「ICPC World Finals 2019」交通堵塞 Traffic Blights

记$m_i=r_i+g_i$，$m_i$就是一个周期，考虑一种简单的情况，如果所有$m_i$都互质，那么所有红绿灯的周期为$\prod m_i$，根据$CRT$可以知道，对于某一个红绿灯，其概率都是独立的，这是因为所有在解同余方程组的时候任意设系数都是可以解出唯一解，那么无论之前走过哪些路口，其能走过的概率都是一定的，那么只要将每一个路口能够通过的概率累乘起来统计即可

再考虑如果有$m_i=m_j$的情况，那么只要记录一下到当前点，$m_i$个时刻中哪些已经被红灯堵住了，然后算出可以通过的概率

如果存在$m_i|m_j$的情况，那么将所有可以两两整除的周期变成其中最大的周期，然后将红灯的时间也相应的标记，然后用上面的做法

现在再考虑缩小剩余系，考虑取一个数$X$，然后枚举时间$c$，模$X$意义下，那么相当于就是枚举$c,c+X,c+2X...$这些时刻，考虑原来红绿灯的周期为$m_i$，那么现在的周期为$\frac{m_i}{\gcd(m_i,X)}$，那么如果可以使当前这些周期两两互质或者存在倍数关系，那么就是对于一个初始时间$c$，计算相应的概率，将所有初始时间累计出来，除以$X$即可（因为从任意一个时刻出发都是等概率的）

那么得到的周期应该都是$1$或者某一个质数的若干次方，那么可以计算得$X=2520$

[代码](https://loj.ac/s/1051535)

# [USACO17OPEN]Switch Grass P

首先需要发现的是，答案一定是某一条边的权值，并且这条边一定在这张图的最小生成树上

因为所有非树边所形成的环上，该非树边一定是最大的，如果是选取这条非树边最优的话，那么这个环上所有点的颜色都是相同的，那么就会导出矛盾，非树边链接的两个点是同色的，那么不能选这条边

这道题到这里就差不多结束了

那么可以用一个优先队列维护每一条边，并且采用延迟删除的方法，然后对于每一个树上的点，用$map$套一个$set$维护儿子节点颜色的最小值，在修改的时候只要在这个节点加入与当前未修改之前颜色的最大值，然后在其父亲处进行修改，加入最大值

[代码](https://www.luogu.com.cn/record/45961400)

# 「LibreOJ Round #6」花札

首先可以将所有可以连续出牌的一对牌连一条边，那么连出的图一定是一张二分图，那么问题就变成了从二分图某一个顶点出发沿边两个人轮流走，不能重复走过相同的点，最后不能走的人输，问先手是否有必胜策略

这是一个经典的问题Undirected Vertex Geography

就是先手必胜的充分必要条件是，起点$v$一定在该二分图所有最大匹配的交集上

那么一个朴素想法就是直接将所有边暴力连出来，然后跑二分图匹配，显然复杂度不能承受，由于二分图匹配可以使用网络流，那么考虑用网络流上优化建图，显然如果对于将每一种点数和颜色都单独建出一个点，然后将牌连向对应的点数和颜色，那么现在的图就是$3$层的图，跑出的最大流就是原图的某一个最大匹配

现在考虑如何求出这张图上所有最大匹配的交集，可以发现的是如果某一个点属于这个交集，那么在图中删去这个点，跑出的最大流一定会变小并且一定在当前最大匹配中，否则不变。如果某一个点删去之后最大流不变，由于二分图的性质（优化建图后本质上还是一个二分图），只要找出一个长度为偶数的交替路，那么这个点$x$删去之后最大流不变，考虑在残量网络上考虑，由于这个点在最大流上，一定存在这个点到源点$s$的路径，那么如果存在一条$s$到$x$的路径，那么说明在原二分图上找到了一个偶数的交替路

必要性证明类似

那么某一个点$x$属于所有最大匹配交集的充分必要条件就是在残量网络上不存在一条从$s$到$x$的路径

[代码](https://loj.ac/s/1055252)

# 「LibreOJ NOI Round #2」不等关系

考虑容斥，首先考虑如果同时存在两种限制是很难处理，首先考虑不存在某一种限制的情况，比如说先不考虑"$>$"

那么$>$左右两边的数大小关系不限制，那么两个之间的数只有$<$，那么这一段数一定要单调递增，那么$>$就相当于一个隔板，将序列划分成若干段，每一段都是单调递增的序列，设序列长度为$a_i$，总共划分成$m$段

那么方案数为$\frac{n!}{\sum\limits_{i=1}^m a[i]!}$

再考虑把所有$>$的限制加上，由于刚才计算的是两面的方案数，那么考虑将$>$改为$<$的限制，然后进行容斥

设$dp[i]$表示考虑到原串的第$i$位，去掉$n!$的容斥系数之和，如果$s[i]=>$，那么$dp[i]\neq 0$，否则$dp[i]=0$

$dp[i]=\sum\limits_{j=0}^{i-1} (-1)^{cnt_i-cnt_j-1}dp[j]\frac{1}{(i-j)!}$

分治$ntt$即可

[代码](https://loj.ac/s/1061439)

# 「HNOI2019」校园旅行

首先考虑一个暴力DP

设$dp[s][t]$表示从s出发到t存不存在合法方案路径，初始情况$dp[i][i]=1,dp[u][v]=1(\exist u\rightarrow v,s_u=s_v)$

$bfs$或者$dfs$搜索出所有合法状态即可

复杂度$O(m^2)$，考虑优化

某一条路径可以分割成$00,01(10),11$这样的若干段

对于一条路径可以发现，由于可以重复走一条边，那么在某一条边上来回走就可以在不改变颜色数量的奇偶性的情况下，任意延长路径的长度，那么限制路径的不是长度而是每一种颜色段的奇偶性

如果只考虑$0$和$0$之间的边，会形成若干个联通块，由于只跟颜色的奇偶性相关，那么可以想到二分图，如果某一个联通块是二分图，那么走到某一个点的奇偶性一定是确定的，如果不是二分图，那么走到某一个点的奇偶性可以任意选择

其他的边也是同理

根据上面的分析可以发现，判定某一段的奇偶性跟图的形态并没有关系，只跟图是否是二分图有关，**那么考虑在保证答案的情况下将图的规模缩小**

那么对于二分图只需要保留其一颗生成树，对于非二分图保留一颗生成树和一个自环，可以发现这样依然保证是否能改变奇偶性的性质

那么对于三种边分别讨论，就可以将边的规模缩小到$O(n)$级别

# 「THUWC 2017」随机二分图

首先期望等于每一种完美匹配的概率之和

考虑设$dp[S][T]$表示左边点已经匹配了$S$的集合，右边的点已经匹配了$T$的集合的答案之和，并且需要满足$|S|=|T|$，状态数有$\sum\limits_{i=0}^n \binom{n}{i}=155117520$

如果只有$t=0$的边，那么直接DP转移即可

需要考虑的是，$t=1,t=2$的情况，由于我们只需要考虑存在匹配中的边

那么考虑将其拆成两个独立的边，但是这样概率不对

对于$t=1$的情况，只出现其中某一条边的概率为$\frac{1}{2}$是对的（因为只考虑是否在匹配中），同时出现的概率为$\frac{1}{4}$，少算了$\frac{1}{4}$，那么加入新的边组，将两条边绑定在一起，并且概率为$\frac{1}{4}$，那么就和原来的问题等价

那么$t=2$同理

# 「NOI2017」整数

### Solution 1:~~垃圾~~线段树压位做法

首先没64位压成一个unsigned long long，然后可以发现每一次修改最多只会影响两个块

但需要注意的是可能会有进位或者退位的情况，那么这就需要找出，从某一个位置开始，后面第一个0/1的位置

考虑用线段树维护所有块，线段树节点上记录翻转标记，区间内块全0个数，区间内块全1个数

那么只要线段树上二分找出这个位置就可以了，然后在这个块内暴力修改，将前面那段区间打上翻转标记

每一次修改某一个块的时候，需要在线段树上将标记下传更新这个块

实现较为复杂

### Solution 2:高级set

同样考虑压位

考虑到上面主要的瓶颈在于进位或者退位

注意到如果单纯只有加的操作，那么每一次在某一个二进制位上加1，总进位次数是$O(n)$

那么不妨考虑将加法和减法分开考虑，分别维护压位数组，那么每一次进行修改操作的时候，就暴力进位即可，这一部分复杂度$O(n\log a_i)$

接下来考虑如何处理询问，那么将加法的压位数组与减法的压位数组相减，由于还需要考虑进退位的关系，那么需要找出第一个$\leq k$的位置，使得加法和减法在这一位上不同

只要加法这一位比减法小，那么就需要退位，否则不需要，那么考虑用set维护，所有两个压位数组不同的位置，由于每一次修改位置的个数最多2个，那么复杂度$O(n\log n)$

# HDU 5121 Just A Mistake

首先根据期望的线性性，答案就是每一个点存在于$S$中的方案数之和，那么考虑钦定这个点为根

考虑设$dp(x,i)$表示$x$这个节点在$x$的子树内是第$i$个被删去的并且存在于$S$集合中的方案数

考虑如何合并两个子树，由于当前的$x$需要在$S$中，那么底下的儿子就一定不能在$S$中，那么需要将总方案数减去DP得到的值

具体来说，考虑枚举$i,j$分别表示$x$在合并时，前面有$i-1$个原来子树的节点，$j$个$u$子树的节点，如果$u$在$x$之前被删去，那么$u$一定不能在$S$中，如果在$x$之后被删去，那么所有情况都合法

那么总方案数就是$dp(x,i)(sz(u)!-\sum\limits_{k\leq j} dp(u,k))\binom{i-1+j}{j}\binom{sz(x)-i+sz(u)-j}{sz(x)-i}$

那么$O(n^2)$树形背包转移即可

总复杂度$O(n^3)$

# [NOI2021] 密码箱

首先如果序列固定，那么利用矩阵维护十分显然

假设当前分数为$\frac{x}{y}$，从后往前扫描，遇到$a$
$$
\begin{bmatrix}
y & x
\end{bmatrix}
*
\begin{bmatrix}
0 & 1\\ 
1 & a
\end{bmatrix}
$$
但是需要维护的是操作序列，如果可以将每一种操作对应一个矩阵进行乘法，那么就可以使用数据结构进行维护

先考虑W操作
$$
\begin{bmatrix}
1 & 0\\ 
1 & 1
\end{bmatrix}
*
\begin{bmatrix}
0 & 1\\ 
1 & a
\end{bmatrix}
\rightarrow
\begin{bmatrix}
0 & 1\\ 
1 & a+1
\end{bmatrix}
$$
只要在所有转移矩阵乘积左边乘上一个$\begin{bmatrix}1 & 0\\ 1 & 1\end{bmatrix}$即可

再考虑E操作

这个判断条件特别麻烦，考虑对于最后一项为1的情况
$$
f(a+1,1)=f(a+2)\\
f(a,0,1,1)=f(a,0,2)=f(a,\frac{1}{2})=f(a+2)
$$
可以发现，进行两种操作的结果是相同的，那么就可以统一成，给最后一项减一，然后在最后面增加两个为1的项

通过简化，得到在左边乘上$\begin{bmatrix}0 & 1\\ -1 &  2\end{bmatrix}$

然后利用平衡树维护，原来矩阵积，原来矩阵积的转置，翻转矩阵积，翻转矩阵积的转置，四个矩阵来进行维护

# HDU 6634 Salty Fish

题目大意：每一个点有一个权值，并且有m个特殊点，对于每一个特殊点$x$会给出$k,c$，$k$表示在$x$子树内距离$\leq k$的所有点都在这个特殊点的管辖范围之内，$c$​表示去除这个特殊点的代价，一个点可以获得其权值当且仅当这个点不在任何一个未去除特殊点的管辖范围之内。现在需要决策每一个特殊点是否需要被去除，求出可以获得的最大价值

首先可以看出一个最大权闭合子图的模型，就是每一个点连向被管辖的特殊点，原点向每一个点连容量为权值的边，特殊点向汇点连容量为代价的边

只要跑出最大流即可，显然不能直接建出图跑dinic，那么需要贪心来模拟这个过程

如果从下往上考虑这个问题，处理出$mp[i][j]$表示$i$子树内，深度为$j$的可以贡献的流量之和，那么枚举当前点的特殊点，需要向这个点流入尽可能多的流量（可能会有是否先不让这个点满流，然后积蓄给更上面的点更优的情况，由于**流量都是相同的，只要最大化个数就可以了**，如果不在这个点流，留到之后，那么如果之后的点不能通过现在留出来的位置贡献，那么显然在当前流掉更好，如果可以，那么流到这个点还是之后的点都等价的，那么就可以在这个点流尽可能多的流量）

那么接下来的问题就是如何更新$mp$，由于跟深度相关，那么考虑长脸剖分，每一次继承重儿子的信息，然后暴力合并轻儿子就可以了，时间复杂度$O(m\log n)$

# Zadanie Różne słowa ([网址](https://szkopul.edu.pl/problemset/problem/wTy-sxQCIKry0Ml-6RvM0L78/site/?key=statement))

## 题目大意

给定$n$​个串，每一个串由$5$​个(字符构成，定义两个串是完全不同当且仅当每一个位置上的字符都不相同

输出所有完全不同的两个对应串，如果超过了100000个，那么就终止输出
$$
n\leq 50000
$$

## 算法讨论

是一种随机做法

一种最暴力的方法就是，对于所有字符的组合记录下来对应的串，然后进行枚举，显然会超时

这样做的主要是因为字符集太大，导致的问题，那么可能需要考虑缩小字符集，但是一旦缩小了字符集那么就会出现冲突的情况，有一些合法的情况就会算成不合法情况，等下再进行讨论

我当时想到这里的时候觉得会产生冲突，而且是将合法的情况混到不合法的情况，就很难处理，但是没有发现可以通过随机化的方法进行处理

那么给字符集种所有字符随机分配0/1，作为替代字符，然后可以发现如果两个串在这个条件下仍然是完全不同的，那么原串也一定是完全不同的，但是不能枚举到所有这样的串，做一次这样的算法复杂度为​

考虑一对合法的二元组在一次算法中被枚举到的概率为$\frac{1}{32}$​，如果做600次这个算法，那么没有枚举到的概率为$(\frac{31}{32})^{600}$​

那么总算法正确的概率是$(1-(\frac{31}{32})^{600})^{100000}=0.999$​

需要注意的是，不能对字符进行随机分配0/1，需要对每一个位置上每一种字符分配0/1，否则有可能出现两个串需要三种字符才能符合条件的情况

像这样不是确定性的算法，**并且一次错误概率不是很高的时候，可以通过多做几次这样的算法来获得更高的正确率**

时间复杂度$O(600n)$

# [POI2008]KUP-Plot purchase

## 题目大意

给定n*n的矩阵，求出一个子矩阵满足和在$[k,2k]$中，输出方案
$$
n\leq 2000
$$

## 算法讨论

考虑先枚举左上端点和右下端点所在的列，然后就是在行中选出一段区间，满足和为$[k,2k]$，直接做的话需要双指针，时间复杂度$O(n^3)$

**注意到这里的区间不是直接给出左端点和右端点，那么就考虑从这个条件入手**

由于刚才问题已经转化成一个序列上的问题，那么先不妨考虑一下序列上有什么性质

我们需要的是找到从某一个位置出发，和$\geq k$的第一个位置，首先如果一个元素$k\leq x\leq 2k$，那么直接合法，输出方案就行，那么元素大小就是只有两种可能$<k$和$>2k$，显然如果这个区间内包含一个元素$>2k$，那么这个区间显然不合法，那么只考虑$<k$的元素，注意到如果存在一段区间$\geq k$​，那么一定可以调整出合法方案，那么我们就只需要考虑极长连续段就可以了，这样我们需要考虑的区间就变成了$O(n)$个

回到原来的问题上来，对于每一行可以处理出下一个$>2k$的位置在哪里出现记作$suc_i$，那么一段极长连续可以存在的时间就是到区间内最小$suc-1$​的位置上，那么不难联想到笛卡尔树，那么就可以用单调栈来进行实现

时间复杂度$O(n^2)$

