# 7.6

## A.珠宝

首先正常的背包肯定是不行的，注意到$c$的范围很小，那么可以考虑对每一种$c$进行$DP$

显然对于$c$相同的时候，需要按照$v$的降序排序，然后从大往小的顺序选，这个过程就类似于多重背包的过程，显然二进制分组起不到作用，那么可以考虑类似单调队列优化的思考

设$dp(i,j)$表示考虑到售价为$i$的情况，$\sum c_i=j$时最大的吸引力
$$
dp(i,j)=dp(i-1,j-k*i)+sum(k)
$$
其中$sum(k)$表示当前$i$中前$k$大的物品吸引力之和，按照模$k$的余数进行分类，然后对于同一组内的dp下标进行重标号
$$
dp(i)=dp(j)+sum(i-j)
$$
接下来就需要DP优化了，首先$sum$不满足四边形不等式，但是$dp$仍然存在决策单调性

证明如下

设$a<b<c<d$，假设存在如下两个最优转移
$$
f(a)+sum(d-a)\rightarrow f(d)
\\f(b)+sum(c-b)\rightarrow f(c)
$$
再考虑这两个转移
$$
f(a)+sum(c-a)\rightarrow f(c)
\\f(b)+sum(d-b)\rightarrow f(d)
$$
可以发现的是$sum(d-a)+sum(c-b)\leq sum(c-a)+sum(d-b)$

那么上面两个转移至少有一个转移是错误的，那么就不满足跨越转移的情况，那么决策一定单调

那么可以直接决策单调性分治即可

## C.点

首先需要一步转化，如果可以向左向右跳，会发现会跟前后的点都发生关联，显然是不好处理的，那么需要考虑将操作进行转化，改为向同一个方向跳

$x+d,x-d\Rightarrow x,x+2d$

计算代价的时候，不能通过依赖枚举被覆盖点的位置来做，那样很难计算贡献，一种简单的方式就是将所有点放到数轴上，然后对于数轴上一个一个整点地进行$DP$，那么计算贡献的时候，只需要当前点和上一个点的是否被线段覆盖的状态即可

有四种情况，其贡献分别为$01:a,11:b,10:0,00:0$

那么对于某一个点来说，$x$和$x+2d$的位置上至少有一个点是被线段覆盖的，那么一定存在一种合法方案（事实上，这里并不是从每一种跳的方案去思考，而是对于某一种代价是否存在一种方案的角度思考，相当于换了一个主元）

首先需要考虑$d\leq 9$的部分分，由于有了上面的计算贡献的方法，考虑对于每一个点的$x+2d$位置上做一个标记

那么碰到一个有标记的位置时，需要检查前$2d$个位置上是否被覆盖，以此决定当前点的决策

那么设$f(i,mask)$表示，当前到达数轴上i的位置，$i$前$2d$位置的覆盖状况为$mask$，那么按照上面所说进行转移即可，该复杂度为$O(\max x_i 2^{2d})$

如果$d>9$，该复杂度难以承受，但是注意到$\frac{m}{2d}\leq 9$

那么可以将数轴每$2d$个分组，那么总共组数为$\frac{m}{2d}$，那么每一个数的状态，只会跟当前组的上一个数和上一个组的相同位置的数有关系，那么可以考虑，对于每一个组同时进行状压$DP$

如果将这些组排成矩形，那么相当于一个轮廓线$DP$，从左往右，从上到下地进行
$$
\begin{matrix}
1 & 2 &3 & ... & 2d \\ 
2d+1 & 2d+2 & 2d+3 &.. & 4d \\ 
 ...& ... & ... & ...
\end{matrix}
$$


注意到，这样会忽略每一个组第一个数的状态，它根上一个组的最后一个数的状态有关，那么考虑一开始枚举每一个组第一个数的状态是什么，然后DP更新答案的时候，加入贡献即可

那么复杂度为$O(\max x_i2^{\frac{m}{2d}+1})$

# 7.10

## B.危险的星球

首先不考虑卡车爆炸的情况，那么对于每一个位置进行考虑，考虑期望走过多少步
$$
\begin{align}
E&=\sum\limits_{x} x*Pr[X=x]\\
&=\sum\limits_{x} Pr[X\geq x]
\end{align}
$$

设$v(i,j)$表示第一次走到$(i,j)$的概率，其中$v(0,0)=1$，$p$表示从一个点出发回到这个点的概率

那么一个点被走过的期望就是
$$
E(i,j)=\sum\limits_{x\geq 1} v(i,j)p^{x-1}=\frac{v(i,j)}{1-p}
$$
如果可以得到$E$那么就可以解出$p$和$v$

考虑对$E$建立递推式
$$
E(i,j)=p_rE(i,j-1)+p_dE(i-1,j)+[i=0\wedge j=0]
$$
如果直接高斯消元的话，时间复杂度$O(n^6)$，可以考虑将第一行和第一列所有元素当作主元，然后将其他元素用这些主元来表示出来，然后利用这些位置的转移列出$O(n+m)$个方程，复杂度$O((n+m)^3)$

由于期望的线性性，可以考虑将总的期望拆成爆炸杀死士兵的期望数量加上走过杀死士兵的期望数量

其中爆炸杀死士兵的期望，其中$q_{i,j}p^{x-1}$表示的是走到$(i,j)$但当前还没有决策，那么就需要乘上$p_b$的概率
$$
\begin{align}
E_1&=\sum\limits_{i,j}p_ba_{i,j}\sum\limits_{x\geq 1} q_{i,j}p^{x-1}\\
&=\sum\limits_{i,j}\frac{p_ba_{i,j}q_{i,j}}{1-p}
\end{align}
$$
由于每一个点的士兵数量有上限，那么需要分经过这个点的次数$\leq a_{i,j}$和$>a_{i,j}$讨论
$$
\begin{align}
E_2&=\sum\limits_{i,j} \sum\limits_{x=1}^{a_{i,j}}x q_{i,j}p^{x-1}(1-p_b-p)\\
&=\sum\limits_{i,j}q_{i,j}[(1-p_b)(f(m-1)+\frac{1-p^m}{1-p})-f(m)]
\end{align}
$$
其中$f(m)=\sum\limits_{i=1}^m ix^i$
$$
\begin{align}
f(m)&=\sum\limits_{i=1}^m ip^i\\
&=\sum\limits_{i=1}^m \sum\limits_{j=1}^i p^i\\
&=\sum\limits_{j=1}^m \sum\limits_{i=j}^m p^i\\
&=\sum\limits_{j=1}^m p^j\frac{1-p^{m-j+1}}{1-p}\\
&=\frac{1}{1-p}(p\frac{1-p^m}{1-p}-mp^{m+1})
\end{align}
$$
再考虑$>a_{i,j}$
$$
\begin{align}
E_3&=\sum\limits_{i,j} a_{i,j}q_{i,j}p^{a_{i,j}-1}\sum\limits_{y\geq 1}p^y(1-p_b-p)\\
&=\sum\limits_{i,j} \frac{a_{i,j}q_{i,j}p^{a_{i,j}}(1-p_b-p)}{1-p}
\end{align}
$$
三者相加就是答案

# 7.12

## B.强连通(UOJ 451)

首先一张竞赛图缩完点都是一条链，考虑利用链表维护这个序列

考虑插入一个点会对这条链产生什么影响

- 如果这个点指向所有节点，那么加在这条链的最前面
- 如果这个点被所有节点指向，那么加在这条链的最后面
- 如果这个点指向链的一段前缀，链后缀的点都是指向这个点，那么将这个点插入分界点中
- 如果是交错指向，那么需要找到链最前面这个点指向的点，还有最后一个点指向这个点的位置，然后将这两个位置之间的点缩其来

插入和缩点操作都是可以利用链表来进行维护，用并查集维护缩点操作，但需要一个线段树维护最前面指向的位置和最后面的位置

注意到由于缩点操作不会改变链节点之间的相对位置，那么只要查出来的节点在并查集中找到父亲即可

那么剩下的就是如何支持动态插入，快速询问两个点的位置关系，插入可以$O(\log n)$，询问必须要$O(1)$

考虑建出一个二叉搜索树，每一次插入可以为每一个位置上的数赋一个权值，比较的时候用权值比较即可

具体来说，就是可以将根的权值赋值$2^D$，每一次向左儿子走将权值减去$2^{D-depth}$，向右儿子走将权值加上$2^{D+depth}$

但是直接做，二叉搜索树的深度可能会很大，D会不够用，插入的复杂度也是错的

那么可以考虑用替罪羊树的思想，当子树不平衡时候，暴力重构使子树平衡

## C.画图(Aizu 1410)

认识到最小割的正确打开方式

这道题需要对单独的一个格子进行分析，考虑其限制条件，然后利用这些限制条件来建图

首先由于被染成白色的格子不能再被黑色染色，而且初始格子都是白色的，就可以将染白色的操作在染黑色的操作之后进行

可以发现的是，如果存在一个格子同时被同一个方向的染白色和染黑色操作覆盖过，由于白色都是来修正的，那么可以分开黑色染色段来避免白色的操作，这样可以得到更优的代价

记$bh_{i,j}$0/1变量表示$(i,j)$这个格子是否被水平染黑过，其余类似

- 考虑黑色格子有什么限制，首先这个格子不能被染成白色，并且如果$bh_{i,j}\vee bv_{i,j}=0$那么需要付出$C$的代价，那么其代价函数为$C(\overline{bh_{i,j}}*\overline{bv_{i,j}})+A(bh_{i,j}+bv_{i,j})$

- 考虑白色格子，首先$bh_{i,j}$和$bv_{i,j}$不能同时为$1$，否则一个格子会被重复染色三次；并且如果$bh_{i,j}\vee bv_{i,j}=1$且$wh_{i,j}\wedge wv_{i,j}=0$需要付出$C$的代价，由于不存在同一方向上的黑白染色，那么代价函数就是$C(bh_{i,j}\ \overline{wv_{i,j}}+bv_{i,j}\overline{wh_{i,j}})$+$A(bh_{i,j}+bv_{i,j}+wh_{i,j}+wv_{i,j})$

然后考虑B代价如何计算
$$
B\sum\limits_{i,j} bh_{i,j}\overline{bh_{i,j+1}}
$$
对于每一个格子每一种变量都可以建出图

黑色格子

![graph (1)](D:\Blog\image\graph (1).png)

白色格子

![graph (2)](D:\Blog\image\graph (2).png)

B的贡献

![graph (3)](D:\Blog\image\graph (3).png)

# 7.14

## C.凸包

首先需要发现，对于某一条直线来说，只有最左边和最右边的交点有用，那么实际上需要求凸包的交点最多只有$O(n)$个

首先考虑$m=0$的情况

有一个结论是，**如果将所有直线极角排序，那么只有极角序相邻的两条直线的交点有用**

只需要讨论一下位置关系，就可以发现这个结论

接下来考虑$m\neq 0$的情况，由于m很小，涉及到的直线也很少，那么直接暴力求出最左最右的交点即可

# 7.15

## A.二分查找

首先可以列出一个$O(n^3)$的区间DP

设$dp(l,r)$表示区间$[l,r]$的答案
$$
dp(l,r)=\min\limits_{m=l}^r b_m+\max\{dp(l,m-1),dp(m+1,r)\} 
$$
然后直接对这个式子优化，只能用优先队列优化到$O(n^2)$

注意到最后的答案都比较小，理论上分析，最优的转移最多分成$\log n$层，每一层的代价最多是$9$，那么答案不会超过$9\log n$

那么考虑设$f_L(i,L)$表示花费$i$的代价，从$L$出发，右端点最多能够到达$f_L(i,L)$，相当于是固定左端点，对dp做前缀取$\max$，$f_R(i,R)$的定义也是同理

需要考虑两种转移

考虑更新$f_L(i,L)$的情况，枚举$j$作为分界点，讨论两边的花费大小关系

如果$[L,j-1]$的花费$<i-b_j$，那么$f_L(i,L)\leftarrow f_L(i-b_j,j+1)$

如果$[L,j-1]$的花费$= i-b_j$，那么$f_L(i,L)\leftarrow \max\limits_{k\leq i-b_j} f_L(k,j+1)$

由于$f_L(i,L)$关于$i$一定单调，那么$\max\limits_{k\leq i-b_j} f_L(k,j+1)=f_L(i-b_j,j+1)$

那么在枚举i的过程中，预处理出j的花费以及贡献，单调队列维护即可，做到$O(9n\log n)$

# 8.11

## 绝体绝命

### 题目大意

给定一个$n$个点的树，有$m$个人，其中一个人选择了树上恰好$k$个点，剩下$m-1$​​​个人里，**每一个人至少选择一个点**，强制1号节点被特殊的人选择，并且树上每一个点都属于一个人，如果一条边会产生贡献当且仅当两端顶点选择的人相同，求最优决策中最小有贡献的边权之和

如果不存在合法方案输出-1
$$
n,m,k\leq 400
$$

### 算法讨论

首先需要判断一下不合法的情况，因为题目中说每一个人至少选一个点，那么有
$$
m-1+k\leq n
$$
并且如果$m=1$​，由于树上每一个点都属于一个人，那么有$k=n$​，答案就是所有边的权值之和

如果上面的条件不符合那么就输出-1

注意到，如果除了那个特殊的人之外还有至少两个人$m\geq 3$​的话，那么可构造所有没有被特殊的人选择的节点，奇数层让第一个人选，偶数层让第二个人选（至于多于两个人的情况），可以使得其他人之间是没有贡献的，只有那个特殊的人选择节点之间有贡献

至于$m=2$的情况，另外一个人和这个特殊的人事实上是等价的

考虑设$dp(i,j,0/1)$​表示$i$​号节点子树内有$j$个节点被特殊人选择，并且$i$号节点是否被特殊人选择，是1，否0

那么有如下转移
$$
\begin{align}
dp'(x,i+j,0)&=dp(x,i,0)+dp(u,j,1)\\
dp'(x,i+j,0)&=dp(x,i,0)+dp(u,j,0)+[m=2]*w_{x\rightarrow u}\\
dp'(x,i+j,1)&=dp(x,i,1)+dp(u,j,1)+w_{x\rightarrow u}\\
dp'(x,i+j,1)&=dp(x,i,1)+dp(u,j,0)
\end{align}
$$
需要注意的是如果$m=2$，那么两个节点如果都是没有被特殊人选择，那么也是会产生贡献的

转移方法就是树形背包的转移方法，最终答案就是$dp(1,k,1)$

时间复杂度$O(n^2)$

## 老街北

### 题目大意

给定两个字符串，求出最小带权编辑距离

![0811T2](D:\Blog\image\0811T2.PNG)
$$
n\leq 5000
$$

### 算法讨论

如果不考虑第四种操作，就是一般最小编辑距离

设$dp(i,j)$表示A串中前$i$个已经跟B串中前$j$个匹配的最小代价

然后可以插入一个$B_{j+1}$，那么$dp(i,j)+t_i\rightarrow dp(i,j+1)$

可以删除$A_{i+1}$，那么$dp(i,j)+t_d\rightarrow dp(i+1,j)$

可以将$A_{i+1}$​替换成$B_{j+1}$​，那么$dp(i,j)+t_r\rightarrow dp(i+1,j+1)$​

然后考虑第四种操作，当时觉得一定是A串中两个原来的字符进行交换（否则一定可以通过改变操作顺序避免交换操作），并且这两个字符需要相邻，这句话前半句是对的，但是后半句是错的

是可以中间有若干个字符存在的，在交换之间需要把中间这些字符删去，然后交换两端的字符，并且有一个重要结论，A两端的字符和对应B两端的字符一定是反序的，否则一定不优（因为如果两个都不同，显然交换没有用，如果其中有一个相同，那么一定会多一次删除和一次插入，比之间删除插入劣），并且交换的位置一定是A串中$i+1$之后$B_{i+1}$出现的第一个位置

否则如果跨过这个位置，那么一定不比选这个位置优，因为中间本来有可以匹配的，结果选了更远的

那么对于每一个位置记录之后每一种字符最早出现的哪里就可以

比如记A串中$i+1$位置之后$B_{j+1}$出现在$sa$的位置，B串中j+1之后$A_{i+1}$出现在sb的位置

那么有$dp(i,j)+t_e+t_i(sb-j-2)+t_d(sa-i-2)\rightarrow dp(sa,s b)$

时间复杂度$O(n^2)$

## 夏夜空

### 题目大意

给出p个字符串，字符集大小为n，求出有多少个长度为m的字符串满足，每一个给出的字符串在这个字符串中出现过

$n\leq 50,m,p\leq 100$

### 算法讨论

建立AC自动机，然后定义一个节点非法，就是这个节点在fail树上到根节点的中存在某一个字符串的结尾

然后就是经典的AC自动机上DP，设$dp(i,j)$表示第i步走到j号节点的方案数，然后枚举字符集进行转移，强制不能转移到非法节点

时间复杂度$O(mp|S|n)$

## 世末积雨云

### 题目大意

给定一个01串a，定义$f(a)$表示将某一段相同字符串进行压缩的不同方案数

给定s，求$\sum\limits_{t \subset s}f(t)$

### 算法讨论

考虑设$dp[s]$表示字符串为$s$的答案

如果第一位填的是单个字母，那么$dp[s]=dp[s_{2..n}]*(1+s[0])$

如果填的是一个连续的重复段，考虑枚举这个连续段的长度i和循环的长度j，那么首先$j\mid i$，然后考虑在$s$子集中可以形成连续段的长度$i$和循环的长度$j$的字符串长什么样，先不去考虑$i$之后的元素（因为在后面DP时候会算到），那么可以发现，这个循环节就是$0$到$i-1$所有长度为$j$循环的字符串的“&”和，记作$t$，那么就变成了$t$的子问题（因为$t$所有子集形成的$s$前缀，$s$的子集也都能形成）方案数$f(t)$，转移$dp[s]=\sum \limits_t dp[t]*dp[s_{i...n}]$

综合上面两个转移即可算出答案，我在想的时候，用区间DP推到这里了，但是看到有新的字符串会产生，乍一看这是个$O(2^n)$​的DP

考虑在算循环节的时候，如果枚举的$j=i$，那么$dp[t]$是原来字符串的一个区间，那么这样的$t$最多有$O(n^2)$个，如果$j\neq 1$，那么$j \leq \frac{i}{2}$，而$t$的长度为$j$，那么说明每一次t的长度至少减半，最多进行$log$次转移

这就提示围我们，把较小的所有字符串先计算好$dp$值，然后记忆化搜索转移$DP$，处理到$13$是可以通过的

理论复杂度$O(n^3+n^2 2^{13})$，跑不满

# 8.22

## 序列

### 题目大意

![20210822](D:\Blog\image\20210822.PNG)

### 算法讨论

首先需要判断非法的情况，就是输入的n对位置有相邻的情况，就输出-1（题目意思应该就是这个，其他不用管。。）

然后将$n$对数和其他的$m-2n$个数分开考虑

首先考虑这$n$对数的情况，根据期望的线性性，可以先考虑一对相同的情况

数字相同的概率是$\frac{1}{k}$，贡献为$2$

那么n对的贡献就是$\frac{2n}{k}$

在考虑其他位置的数，首先也是同样的期望线性性，考虑一个位置的情况

设$F$表示从$n$个数内两次选出$n-k$个数，被选了两次的数的期望个数，那么就是$\frac{F(k-n-1)^{2(l-1)}}{(k-n)^2(k-n-1)^{2(l-1)}}=\frac{F}{(k-n)^2}$

考虑计算$F$，还是期望的线性性，得到$F=k(\frac{\binom{k-1}{k-n-1}}{\binom{k}{k-n}})^2=\frac{(k-n)^2}{k}$

那么总答案就是$\frac{m}{k}$与$n$无关

## 迷宫

### 题目大意

![20210822T2](D:\Blog\image\20210822T2.PNG)

### 算法讨论

首先可以证明，如果固定三个点，那么最优的会合位置一定是三个点到某一个点，并且最短路之和最小

证明的话就是反证，如果有两个人提前相遇，那么在那个提前相遇的点会合更优

首先需要判断所有可能的传送点都是在同一个联通块之内的，否则就是不合法

然后预处理出来所有传送点出发的最短路，然后枚举三个位置，枚举联通块里面的点，求出最小的距离和即可

注意像找树上重心的那样的方法可能不行，虽然这个图满足走向周围是递减的，**局部最优点**是比周围都小的节点，但是可能存在多个局部最优点

**另解**：可以先枚举F,R，将这两个点的最短路叠加起来，那么就可以看作这两个点先走到某一个点会合，然后走向L的位置上（需要注意的是这里虽然是两个人一起走，但是每走一步代价都是1，相当于是对L倒序考虑），这个由于可以互相更新，就用一个dij来计算就可以了

那么时间复杂度就是$O(20^2nm\log nm)$

## 考试

### 题目大意

![20210822T3](D:\Blog\image\20210822T3.PNG)

### 算法讨论

考虑建出图来，对于表达式$A=B+s$，建立$B\rightarrow_s A$的一条边

那么可以发现得到的有向图必须是一个DAG才是有可能合法的

但是这样计算答案仍然不好计算，如果我们可以将DAG缩成一个外向树的话，就可以很方便的计算答案

我们按照拓扑序的顺序来考虑

首先考虑一个节点所有的入边，这些入边需要满足一些条件，就是如果将这些入边上的字符串按照长度排序的话，长度小的一定是长度大的后缀，否则就不合法

那么显然这样记录信息是浪费的，那么考虑简化，我们可以在排好序的边节点依次建立边，边上就是长度小的字符串前面没有出现过的信息

<img src="D:\Blog\image\IMG_20210822_183457.jpg" alt="IMG_20210822_183457" style="zoom:50%;" />

然后有可能对于连过来的边还是存在两个入边，那么就递归处理一下就可以了

**需要注意的是，如果将这个图缩成了一个链的话，可能存在链前面的节点连向后面的节点，那么需要特殊判断否则会死循环**

**另解**：一开始建边的时候不止是要建一条有向边，对于反向的负权边也要建出来，代表着经过这条边，就要在当前字符串的后缀减去这个字符串

就是由于数据范围很小直接在原图上进行dfs，看最长的路径和最短的路径长度是否相等，如果不相等那么一定不合法，然后在判断字符串的问题，就是在dfs过程直接将这个字符串维护出来

## 毒瘤

### 题目大意

给定$n$个点的树，每一个节点都有一个权值$a_i$，表示第一次经过这个点可以获得的价值，走的过程中权值之和不能为负，并且如果一个节点的父亲没有经过，那么只能往儿子节点走，求出从点$to$到根上节点出发，是否能到达to
$$
n\leq 10^5
$$

### 算法讨论

一个经典的贪心

首先在$to$下面挂一个权值为$inf$的点，如果从某一个点出发可以到达$to$的话，途中最大权值一定是大于等于$inf$的，那么就需要求出路程中最大权值和

考虑将一个子树内所有的节点缩成如下的形式$(a,b)$表示先要付出$a$的代价，然后得到$b$的收益，并且需要完成前面一个二元组才能继续做下一个二元组，相当于就是形成了一条链

首先需要考虑几个性质

- 如果存在两个相邻的$(0,b)$的话，就可以将这两个合并起来，对于$(a,0)$的情况也是同理

- 如果存在$(a,b)$满足$b<a$的话，那么就合并成$(a-b,0)$，然后查看是否可以跟其他的合并，这是因为如果选了这个二元组，获得的收益是负的，那么不会之后什么操作也不进行，肯定会找解锁有正收益的二元组
- 可以保证$(a,b)$中$a$是递减的，如果存在一个递增的，那么就可以合并相邻的两个二元组，原因也是比较显然，肯定是一开始找门槛比较低的，然后不断提高门槛

那么对所有子树维护出来这些二元组，一个子树内的二元组最多是子树大小个，可以利用堆来维护这些二元组

至于合并的时候，就是启发式合并，按照上面的条件进行判断，最后再加入当前子树的根，就是在堆顶加入（因为经过子树内的点一定需要经过子树的根）

至于判断，由于出发的时候权值为$0$​，那么一定要保证堆首的元素$a=0$，然后检查$b$是否大于等于$inf$

时间复杂度$O(n\log ^2n)$，常数很小

**另解**：对于平衡树的启发式合并可以用finger search来做到$O(n\log n)$，就是将插入的平衡树的中序遍历拿出来，**然后插入的时候记录上一次插入到哪里**，然后从上一次的位置不断走，直到走到当前插入的位置，可以证明这样的时间复杂度就是$O(n\log n)$

还可以用线段树进行维护，但是常数比较大
