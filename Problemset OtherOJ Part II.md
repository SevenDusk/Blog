# 「ZJOI2017」字符串

由于是区间修改操作，那么我们就肯定需要用线段树进行维护，那么考虑在线段树中维护什么信息

考虑一个串可能成为最小后缀的位置集合$S$，在线段树节点中就是维护这个$S$，当然不能直接维护，我们肯定需要找一点性质出来

假设当前的区间为$[l,r]$并且整个字符串记作$s$

那么对于$i,j\in S,i< j$来说，如果其$lcp(s[i...r],s[j...r])<r-j+1$，也就是说这两个后缀在区间内已经分出大小，那么显然对于比较出来字典序较大的那个字符串就不能留在$S$集合中了

但是通过这个限制我们并不能 S$集合大小范围

那么接下来考虑$lcp(s[i...r],s[j...r])=r-j+1$的情况，那么也就是说$s[j...r]$是$s[i...r]$的一个前缀同时也是一个后缀

根据border的性质可以知道其一定存在一个循环节$s[i...j+1]$

如果$2(r-j+1)>(r-i+1)$，那么循环节长度$\leq r-j+1$，那么假设$s[i...r]=T^{k+1}c,s[j..r]=T^kc$

其中假设$c=T[1..p],p\leq|T|$

那么考虑往后加入一个字符$q$，如果$q>T[p+1]$，那么显然我们取$s[i...r]$一定比$s[j...r]$字典序小，如果$q\leq T[p+1]$那么我们取$c$这个后缀一定也比取$s[j..r]$优

那么我们就可以说明$|s[i..r]|\geq 2|s[j...r]|$，那么说明$|S|=O(\log n)$(因为确定最小可能后缀，剩下的后缀长度至少倍增)

那么我们可以在线段树中暴力合并两个儿子的可能的$S$，那么我们唯一需要计算的就是两个后缀的LCP长度，我们考虑用hash进行维护，我们需要一个数据结构维护这个序列的hash值，可以发现的是我们查询某一个位置hash值的次数会远远大于修改次数

那么考虑平衡复杂度，那么可以用分块做到$O(\sqrt n)$单次修改，$O(1)$单次查询，那么在求LCP的时候直接二分即可

由于每一次修改之后需要重新更新涉及到的线段树节点，而每一次合并的复杂度为$O(\log ^2n)$

那么总的时间复杂度$O(n\log ^2n+q\log^3 n+q\sqrt n)$

# IOI 2019 天桥

首先考虑$s=0,g=n-1$的这一档暴力，通过前面几档的暴力我们可以知道，我们的目标就是在所有的天桥和建筑的交点中选出可以接受数量的关键点，然后在所有关键点之间进行连边，也就是同一个天桥之间按顺序连边和同一个建筑之间按顺序连边（显然边数级别和点数相同），然后跑一遍最短路即可

那么肯定需要找到几条性质来缩减关键点的数量

首先由于出发点和终点两侧没有其他建筑了，那么显然我们不会走回头路，如果需要走回头路一定是出发点或者终点刚好在某一个天桥的中间

首先考虑如果当前正在某一个天桥上行走，由于我们不会走回头路，一定是尽可能的向终点走，那么在过程中一定不会**向下**走到其他天桥，因为如果在中途走下去，并且之后的路径一直在当前所走天桥之下（如果不在的话，**那么一定存在一个交点**，这样显然不优，直接从走下的点走到交点即可），那么我们走到当前天桥的端点再走到这条路径的端点的方案一定不劣（由于距离是曼哈顿距离）

那么我们可以将每一个天桥的两个端点加入到关键点之中

还有一种可能就是从当前天桥中途**向上**走到其他天桥，此时端点的建筑高度可能很低，无法从端点走到终点（或者说其他路径的端点），那么就需要中途离开这个天桥

首先考虑如果另一个高度高于当前天桥的天桥区间被当前天桥的区间完全包含，那么显然中途走到另一个天桥一定不优，如果另一个天桥完全包含了当前天桥，如果我们需要走到另一个天桥，那么在之前的决策中已经走上去了，不会在当前天桥中途走上去

然后需要考虑就是其他天桥区间跟当前区间相交的情况

如果我们贪心地走，如果遇到可能最优的天桥就立刻走上去，那么可以发现我们选择的位置一定是天桥所在区间的前缀max位置，并且我们只要走到高度最低的天桥端点即可，之后的决策在这个天桥上进行

在去除包含或者被包含的区间之后，这两个端点之间不存在其他天桥，事实上我们只需要对每一个天桥的端点找到下面最高的在天桥上的点作为关键点即可（实际上两者等价，并且点数严格$O(n)$）

那么这样就解决s=0,g=n-1的问题

然后考虑一般情况，首先还是保留之前叙述的所有关键点，然后可以发现对于一个天桥来说，在$[s,g]$区间内的最左最右端点需要当作关键点，结论跟上面叙述的一样

接下来不同的就是可以走回头路，显然最终的路径一定是$s\rightarrow s'\rightarrow g'\rightarrow g$并且满足$s'\leq s,g'\geq g$

考虑一下走回头路的意义是什么，就是如果直接从$s$出发向右走，可能当前$s$的建筑高度很低，不能到达终点或者路径不优，那么就需要回头走到高度更高的建筑再向右走

那么显然$s'$的取值一定是在$[0,s]$中的后缀最大值处，同理$g'$的取值也是在$[g,n-1]$的前缀最大值处

那么我们取出所有后缀最大值位置将所有天桥交点作为关键点（此时加入的关键点是表示从当前点向上走然后直接走到$g'$），但是这样会产生$O(n^2)$个点，但是注意到如果前一个建筑没有向上走，那么在下一个建筑上一定不会从当前高度走上去，一定是在更高的位置走，那么选择的区间一定是不交的区间（但是需要建两个点）

那么这样就解决了问题

# 「LibreOJ NOI Round #2」小球进洞

首先$b_i$是$\leq a_i$中第一个位置数大于等于球数的位置，首先将所有询问离线下来，将所有的可能出现的位置离散化，具体来说以所有可能出现的$(a_x,x)$为元素进行离散化，同时将洞的位置也离散化进去，以$(i,0)$的形式

那么记$s_i$表示前缀$[1,i]$中位置数-球数的值

考虑如何计算询问，对于一个询问$[l,r]$，将$\sum \limits_{[l,r]\subseteq [a_i,b_i] } (a_i+b_i)$拆成$\sum a_i+\sum b_i$，记$tr_l$表示$(l,0)$在离散化之后的位置

首先考虑计算$\sum a_i$，首先对于一个位置$i$，需要求出其$b$是否$\leq l$，那么也就是说$[tr_l,i]$的所有后缀其$s$都是$<0$的，相当于$\forall j\in[tr_l,i-1]$满足$s_j>s_i$，相当于$s_i<\min s_j$

也就是说可能的位置就是$[tr_l,....]$所有取到前缀min的位置并且这个位置$>tr_r$，那么可以在线段树上维护当前区间前缀min位置的信息和即可，pushup的时候递归求贡献

这样就可以先求出$[tr_l,tr_r]$的最小值，然后在求出贡献即可

然后考虑计算$\sum b_i$，首先可以发现的是上面取到前缀min的值一定是连续的（由于$s$的变化量只有1），那么就可以确定$b$的取值区间，同样也是类似的计算，不过变成了后缀min

这样的时间复杂度就是$O(n\log ^2n)$

# P5617 [MtOI2019]不可视境界线

首先对于一个选定的圆集合如何求出其面积并

由于所有圆的半径相同，并且圆心都在$x$轴上，那么从左到右考虑不断增加圆，然后我们只需要计算增加了多少面积即可

如果最后一个圆和当前添加的圆圆心距离等于$d$的话，那么增加的面积就是$v(d)=\pi r^2-2\times r^2\cos ^{-1}(\frac{d}{2r})+d\times \sqrt{r^2-\frac{1}{4}d^2}$

然后注意到对于选出集合的大小其最大覆盖面积是凸的，那么我们就可以wqs二分斜率，求出在当前斜率切到凸包的最大值

那么就转化成选出若干个圆，然后选出一个圆需要付出额外的代价mid，求选出圆的面积并-代价的最大值

考虑DP，设 $dp(i)$表示当前从左到右最后一个圆的编号为$i$的最大值
$$
dp(i)=\max\limits_{j<i} dp(j)+v(\min(2r,x_i-x_j))-mid
$$
然后考虑进一步优化，首先我们需要注意到$v(x)$是关于$x$的上凸函数，也就是说将其差分之后，得到的就是一个递减的序列

那么我们可以通过这个性质证明，最优决策一定不会存在包含转移的情况，那么也就是说明$dp$的转移具有决策单调性，通过二分栈就可以做到$O(n\log ^2n)$的复杂度
