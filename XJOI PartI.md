# noip2020模拟27

这次挂分挂的太严重了。。本来已经对的代码，在比赛最后的时候改错

# C.Sequence on Tree

对于OR和XOR的操作，可以发现能选则选一定最优

对于AND操作，贪心地想，一定是使选取地祖先和当前的值AND之后最高位，越高越好，并且如果对于第$k$位，如果有两个祖先在$k$位都可以AND出$1$来，那么一定是选取最深的那个祖先，因为这样这个较深的祖先还可以跟较浅的祖先再AND一次，再产生$2^k$的贡献

那么对于每一个点需要记录的是某一位上为$1$并且离它最近的祖先是那一个，转移的时候用那个祖先来更新这个节点，这个可以用一个栈来维护

时间复杂度$O(nlogw)$

[代码](https://dev.xjoi.net/contest/detail/486525)

# D.Power of Two

首先可以把题目的限制转化为，将$n$个相同的球放到$k$个相同的盒子中盒子不能空，这是一个非常经典的DP（我居然还写挂。。。）

$dp[i][j]$表示将$j$个球放到$i$个盒子里的方案数，那么$dp[i][j]=dp[i-1][j]+dp[i][i-j]$

由于题目条件是不能为空那么记$f[i]][j]=dp[i][j-i]$那么这样就保证盒子不能为空

再考虑每一个数的贡献

对于一个数$x$，我们枚举它出现了$i$次，那么只要算出来在原来的方案中有多少个方案中$x$出现了$i$次，但是这样不好计算

考虑**将恰好转化为至少**，对于数$x$，如果其至少出现了$i$次，方案数为$f[k-i][n-ix]$

求出了这个，那么可以通过差分，得到恰好出现了$i$次方案数

[代码](https://dev.xjoi.net/contest/detail/486566)

# [2021省选训练1](https://dev.xjoi.net/contest/1626)

# C.九条美由纪与传奇魔法物品

考虑如果某一位上所有数都是$0$或都是$1$，那么把这一位去掉不影响答案，考虑剩下的位，由于划分出的两个集$合AND$和必须相等，那么不能出现某一位所有的$0$都在某一个集合的情况，直接统计不好统计，注意到这个位数很少只有$20$位，那么考虑容斥

考虑限制条件的反面，也就是某一位$0$全在某一个集合，那么去枚举哪些位强制让所有的$0$都划分到同一个集合中去

再考虑如何统计答案，这些限制实际上就是把一些数绑在一起，看作一个整体，然后统计有多少个自由的数$num$，那么在这个限制条件下的方案数就是$2^{num}-2$

实际上就是那些没有当前枚举的限制位的数的个数+限制位之间绑成了几个整体，先考虑没有当前枚举的限制位的数的个数，那么这些数就是当前枚举限制位集合的补集的子集，那么$fwt$或者高维前缀和预处理即可

考虑限制位之间绑成了几个整体，考虑如果存在每一个数，在$i$位和$j$位上都是$0$，那么$i,j$位就是一个整体，那么这些边也是可以通过$fwt$来得到，这些边可以用二进制数来表示邻接矩阵，对于某一个集合可以利用这些信息做到$O(20)$求出联通块有多少个

[代码](https://dev.xjoi.net/contest/detail/500429) 

# [2021省选训练2](https://dev.xjoi.net/contest/1627)

# B.小C的利是

大体思路是对的，但是一些更深入的分析和知识还是不行

首先我是想到选出排列应该跟行列式有点关系，但是这里的运算是带模加法，不是乘法，就不知道如何下手，后面想到用$x$的次方代替，又没想到把矩阵里的元替代为多项式

首先可以把矩阵的某一个数$a$看作对应的$x^a$，然后可以把加法变为乘法，那么问题就变为了，在最高次为$k-1$的意义下做循环卷积，计算行列式，结果的常数项系数是否为$0$

但是由于计算行列式会带正负号，可能贡献会抵消，那么这里可以随机给原来矩阵中每一个元素随机赋值一个系数，那么再去计算行列式，那么此时再看得到答案多项式的常数项，出错概率很小

还有这里的乘法是定义为最高次为$k-1$的意义下做循环卷积，直接暴力计算复杂度不对，考虑将其转化为点值表示法，那么可以每一位分开计算行列式

根据fft的经验，这里的点值就是选取$x=\omega_k^i,i\in[0,k)$，那么就保证$x^k=1$，那么需要保证选取的模数$mod$，需要满足$k|(mod-1)$

由于原根的性质$\sum\limits_{i=0}^{k-1}\omega_k^i\equiv 0$

那么可以把所有得到答案多项式的所有点值加起来，得到的就是原多项式的常数项的$k$倍

大概式子是这样的$\sum\limits_{i=0}^{k-1}\sum\limits_{j=0}^{k-1}a_j\omega_k^{ij}$

注意到如果$j\neq 0$，那么$ij$遍历过所有$[0,k)$中的数，那么这一项的贡献就为$0$

如果$j=0$，那么$\omega_k^{ij}=\omega_k^0=1$，最终结果就是$ka_0$，只要$ka_0\neq 0$，就是$Yes$，否则就是$No$

[代码](https://dev.xjoi.net/contest/detail/501020)

# [2021省选训练2*](https://dev.xjoi.net/contest/1629)

# B.Third

$DP$的式子推复杂了，本来做法都想到了，结果式子没法做。。

首先考如何计算一个序列的本质不同子序列数量，设$dp[i][j]$表示当前到第$i$位，以$j$结尾的本质不同子序列的数量

对于$j\neq a_i$，有$dp[i][j]=dp[i-1][j]$

对于$j=a_i$，有$dp[i][j]=1+\sum\limits_k dp[i-1][k]$

显然第一维可以滚动去掉，那么现在就可以支持向一个序列后面加元素，然后统计新序列的本质不同子序列

考虑题目问的操作，由于是由一个前缀后缀交换，可以发现当$b$递增的时候，相当于每一次需要在一个序列的前面或者后面加入元素，或者删除元素

如果需要支持在前面加入元素，那么设$dp[i][j]$表示以$i$开头$j$结尾的本质不同子序列数量，按类似上面的转移去转移即可

对于删除操作，考虑每一次加入操作的逆操作即可，解方程就可以了

那么可以把所有询问离线下来，以$b$排序，然后一边扫过去，一边统计答案即可

[代码](https://dev.xjoi.net/contest/detail/501546)

# A.Second

可以发现的是，如果这个计算答案的式子取到最小的时候，对于所有的$i$，其值都是相同的，因为如果有某一个$i$比其他的都大，那么可以通过调整$k$的大小来减小答案

那么最暴力的做法就是直接把$k$个方程列出来，直接高斯消元

考虑将串反转，然后建出$SAM$的$parent$树，那么两个后缀的$LCP$就是在树上$LCA$处$len$的大小，考虑利用这一性质来加速算法

可以设$dp[i]$表示在$i$子树内，只考虑子树内的后缀的话，得到的最小答案

考虑如何合并$i$和$j$两个子树，设当前节点最长等价类串长为$len$，由于在各自的子树满足$\sum k=1$，那么合并的过程中需要分别成上一个系数$r_1,r_2$且$r_1+r_2=1$

可以列出方程$r_1dp[i]+r_2len=r_2dp[j]+r_1len$

将$r_1,r_2$解出即可

[代码](https://dev.xjoi.net/contest/detail/501570)

# [2021省选训练9](https://dev.xjoi.net/contest/1636)

# B.Distance

首先考虑路径经过边的边数$<k$的情况，直接在原图上跑最短路就可以，这样一定不会比答案更优，并且如果存在答案一定可以搜到

再考虑边数$\geq k$的情况，可以考虑枚举前$k$大边中边权最小的边$w$，计算这种情况的答案

简单的想法是将所有边权小于$w$边的边权设为$0$，然后在图中跑最短路，但是这样会把原来较劣的情况变得更优

那么这样考虑，由于指定了至少有$k$条边的边权是大于等于$w$的，那么考虑将这一部分的贡献提取出来，即$wk$，然后将所有大于等于$w$的边减去$w$，然后再跑，这样一定可以把合法方案搜出来

# C.九条璃雨与网格图最短路

首先可以将点权加到指向这个点的边上（注意不是加到指出的边，否则某一个点可能会被松弛多次，就不能用后面的方法优化）

然后暴力跑最短路，考虑优化这个做法，首先考虑每一次松弛实际上是在干什么，由于当前点已经是最优，如果存在某一个点还没有被松弛过并且当前点有边连向这个点，那么这点一定可以被松弛，并且只会在这一次松弛，这是因为连向这个点的边的边权都是相同的

那么每一次就是询问某一个子矩阵中还没有被选到的点，并将这些点加入到堆中

考虑一维情况如果做，可以维护一个并查集，每一个联通块的根都还没被删，其他节点都被删，并且一个联通块中的点构成一个区间，并且根为区间的右端点，每一次询问的时候找到区间最左那个没有被选过的点，然后将这个点加入到堆中，然后将这个点和右边的联通块合并，然后找到右边联通块的根继续做下去即可

考虑扩展到二维的情况，那么考虑一维使用这个做法，另一位用线段树维护，那么对于每一个线段树节点都开并查集，设节点$x$表示的区间为$[l,r]$那么，那么$x$节点维护的并查集中某一个区间，是需要满足另一维上$[l,r]$区间都是在一个联通块时才能合并，那么这个在修改时候顺便维护的一下即可

每一次询问的时候，在线段树上跳，直到某一个终止节点，然后在这个节点向下递归下去，将所有儿子节点中的并查集都修改掉

需要注意的是如果当前线段树节点中并查集，对于询问的区间已经在同一个联通块，那么需要直接退出，否则复杂度是错的

时间复杂度$O(nlog^2n)$

# [2021省选训练10](https://dev.xjoi.net/contest/1639)

# B.Two?Two!

神仙思路$DP$

首先考虑一个$O(n^2)$$DP$，考虑设$dp[i][j]$表示到前$i$个人，某一个序列中最大值为$j$，另外一个序列最大值为当前前缀最大值，转移分两种情况讨论，由于$x$范围太大，考虑将$x$离散化，那么j的大小只有$n+1$个，需要把$0$也计入状态，也就是某一个队列为空

记$MAX$为当前前缀的最大值

若$x_i>MAX$有如下的两种转移

$dp[i][MAX]=\min\limits_j dp[i-1][j]$

$dp[i][j]=dp[i-1][j]$

若$x_i \leq MAX$有如下转移，其中=号都是取$min$关系

$dp[i][x[i]]=\min\limits_{x[j]\leq x[i]} dp[i-1][j]$

$dp[i][j]=dp[i-1][j]+MAX-x[i](x[j]\leq x[i])$

$dp[i][j]=dp[i-1][j]+x[j]-x[i](x[j]>x[i])$

考虑如果直接转移话，会很难用数据结构维护，主要是那个区间取$min$和区间加等差数列很难直接用线段树维护，那么这时候考虑找$DP$的一些性质，如果仔细观察的话，大体上$DP$还是满足单调性的，但是由于存在取出一个区间$min$的转移，这个$DP$会在某几个点上不单调

那么考虑将$DP$转移反向，不从前往后转移，从后往前转移，那么区间取$min$操作，就变成了用一个数去覆盖区间，可以证明现在$DP$状态是满足单调性的，感性理解就是当j比较小时是包含所有j较大时候的情况，也可以理性证明

那么用线段树维护即可

# [2021省选训练32](https://dev.xjoi.net/contest/1714)

# A.新访问计划

第二部分的优化有意思

首先对树跑一遍欧拉序一定是符合条件的

那么相当于把每一条边都拆成了两条边，并且这两条边只能经过一次，然后从$1$号节点跑欧拉回路

考虑坐车的改变，相当于是坐车的两点之间的路径都去除一条边

但同时要保证欧拉回路存在

那么一种坐车方案合法，那么就是这些路径不交

题目就转化为将树划分成不超过$k$条不相交的路径，划分一条路径的代价为$C$，并且未覆盖边的代价就是这条边的边权

然后这就是一个比较经典的问题，设$dp[i][j][0/1]$表示$i$号节点的子树内用了$j$条路径，并且存不存在一条坐车路径伸出$i$子树

时间复杂度$O(nk)$

考虑优化，**如果假设没有$k$这个限制，坐车的次数无限**，那么可以设$f[i][0/1]$表示$i$号节点子树最小代价，并且存不存在一条坐车路径伸出$i$子树，$g[i][0/1]$表示对应最小坐车次数，这个DP是$O(n)$

然后如果乘车费用就是$C$并且在最小花费下，最小次数$\leq k$那么可以直接输出答案

但如果$>k$那么就不知道需要使用哪$k$条，这里不能直接贪心选前$k$大的路径，因为可能存在另一种方案，使最大比较小，但总和更大

那么巧妙之处就是，需要通过调整$C$的大小，来控制选的方案，只要找出选取路径个数$\leq k$的最大$C$即可

**如果在适当调整$C$之后使得选出的路径有$k$条，那么在原来$C$的情况下，选这些路径一定是最优的**

证明：

假设当前的价值为$C'$，方案为$S'$，原来的价值为$C$

考虑反证法，如果存在另外一种方案使得$C$下选出$k$条的方案$S$更优

若存在一条路径$P\in S,p\notin S'$使得$C<V(p)<C'$那么一定存在$p'\in S',p'\notin S,V(p')>C'$，那么将$P$替换成$P'$那么更优

否则$V(p)>C'$，那么在求$C'$最优解的时候，就一定选择所有$P$中总和最大那$k$个，对于$C$来说也是最大的

这个优化方式很具有启发性

# [ 2021省选训练37](https://dev.xjoi.net/contest/1722)

# B.数据结构

显然可以进行分治

考虑分治的过程，对于分治左右两边，一定是左边最r的最大值和右边b的最大值组合起来

再考虑询问的结构

![无标题](D:\Blog\image\无标题.png)

可以发现分治左右两边的最大值至少有一个存在于询问范围内

那么分别将左边的与右边所有的配对，右边最大跟左边所有的配对

那么总共有$T(n)=T(\frac{n}{2})+O(n)$个对数

$T(n)=O(nlogn)$

然后二维数点

# [2021省选训练38](https://dev.xjoi.net/contest/1723)

# C.在星河里

第一部分暴力思路不对，第二部分暴力思路正确（其实这种题考试时侯还是打暴力比较保险）

首先考虑按$m$奇偶分类讨论

如果$m$为奇数，那么带权重心一定唯一

如果$m$为偶数，如果不存在两个点的子树和均为$\frac{m}{2}$，那么带权重心唯一，否则带权重心为这两个点路径上的最小标号

那么先考虑带权重心唯一的情况，考虑某一条树上的边，将树分成了$s$和$n-s$两个部分，如果s这边的权值和$\geq\lfloor \frac{m}{2} \rfloor+1$那么带权重心一定在$s$这边

如果对于所有$s$算出带权重心属于$s$这个部分的方案数$f(s)$，那么就可以确定每一个点作为唯一带权重心的方案数，就是先假定当前的节点$x$为根

如果$m$为奇数，那么只要将总方案数减去在儿子子树内的方案数即可

如果$m$为偶数，除了要减去奇数的情况以外，那么还需要减去存在两个子树内权值和为$\frac{m}{2}$的情况

现在考虑如何计算$f(s)$
$$
f(s)=\sum\limits_{k=p}^{m}\binom{s+k-1}{s-1}\binom{n-s+m-k-1}{n-s-1}
$$
考虑其组合意义，将$n$个盒子分成左边$s$个，右边$n-s$个，并且左边$s$个盒子中球数之和大于等于$p$

考虑第$p$个球所处盒子为$i$，那么$i$号盒子一定有一个球，那么前面$p-1$个球需要放在$1$到$i$盒子中，方案数$\binom{p+i-2}{i-1}$，剩下$m-p$个球可以放在$i$到$n$号盒子中，方案数$\binom{n-i+m-p}{n-i}$

令$f'(s)=\binom{p+s-2}{s-1}\binom{n-s+m-p}{n-s}$但是$f'(s)$并不是$f(s)$，只是钦定了第$p$个球在$s$号盒子中，还可能在$[1,s]$中

那么$f(s)=\sum\limits_{t\leq s}f'(t)$

这一部分就做完了，那么奇数就可以直接输出答案了

对于偶数来说还需要考虑存在两个子树和等于$\frac{m}{2}$的情况

考虑枚举路径上标号最小的点$x$，如果以$x$为根，那么这两个子树选的范围就是包含$x$，且其中编号全部大于$x$的联通块，那么考虑从大向小加点，维护联通块

具体计算过程可以看暴力计算，过程较为繁琐

# [ 2021省选训练39](https://dev.xjoi.net/contest/1724)

# C.绝对伏特加

整理一下最近的数学题，最近做到的数学题我都傻逼了，特别是这道$F$抄成$i$可还行

考虑对于数字$i$出现次数列出生成函数
$$
\begin{align}
F(x)&=\sum\limits_{i}i^F\frac{x^i}{i!}
\\&=\sum\limits_{i}\sum\limits_{j=1}^F \left\{\begin{matrix}F\\j\end{matrix}\right\}\frac{x^ii^{\underline{j}}}{i!}
\\&=\sum\limits_{j=1}^F \left\{\begin{matrix}F\\j\end{matrix}\right\}x^j \sum\limits_{i}\frac{x^i}{i!}
\\&=\sum\limits_{j=1}^F \left\{\begin{matrix}F\\j\end{matrix}\right\}x^j e^x
\end{align}
$$
由于前$L$个数个数之和可能不到$n$，所以列出数字大于$L$的生成函数
$$
G=\sum\limits_{i}\frac{(k-l)^ix^i}{i!}=e^{(k-l)x}
$$


所求为$\frac{n![x^n]F^LG}{k^n}$

其中
$$
\begin{align}
F^LG&=e^{kx}(\sum\limits_{j=1}^{F}\left\{\begin{matrix}F\\j\end{matrix}\right\}x^j)^L
\end{align}
$$
里面可以多项式快速幂，复杂度$O(FLlog^2)$

假设得到的多项式为$\sum\limits_{i}f_ix^i$

那么
$$
\frac{n![x^n]F^LG}{k^n}=\sum\limits_{i} f_i\frac{n!}{(n-i)!k^i}
$$
注意到如果$i\geq mod$时$\frac{n!}{(n-i)!}\equiv 0$复杂度$O(mod^2)$

# [2021省选训练39'](https://dev.xjoi.net/contest/1726)

# C.数数题

考虑一位一位考虑，对于$a_i^k$的期望
$$
\frac{1}{a_i}\int_{0}^{a_i} x^k dx=\frac{a_i^k}{k+1}
$$
假设$\sum\limits_{j<i}x_j=sum$那么$(sum+a)^k=\sum\limits_{i=0}^k\binom{k}{i}a^isum^{k-i}$

那么考虑每一位的生成函数
$$
\begin{align}
F&=\sum\limits_{k} \frac{(a_ix)^k}{(k+1)!}=\frac{e^{a_ix}-1}{a_ix}
\end{align}
$$
答案就是
$$
\begin{align}
F&=\prod\limits_{i=1}^n\frac{e^{a_ix}-1}{a_ix}
\\\ln F&=\sum\limits_{i=1}^n \ln \frac{e^{a_ix}-1}{a_ix}
\\\ln F&=\sum\limits_{i=1}^n f(a_ix),f(x)=ln \frac{e^x-1}{x}=\sum\limits_i f_ix^i
\\\ln F&=\sum\limits_{i=1}^n \sum\limits_{j} f_j(a_ix)^j
\\\ln F&=\sum\limits_{j}f_j x^j\sum\limits_{i=1}^n a_i^j
\end{align}
$$
那么预处理$\sum\limits_{i=1}^n \frac{1}{1-a_ix}$，这个可以分治$FFT$，最后将原式$Exp$回去就是答案多项式

复杂度$O(nlog^2n)$

