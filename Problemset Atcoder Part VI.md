# AGC25E Walking on a Tree

首先需要发现一个结论就是如果记一条边被路径覆盖的次数为$c_i$

那么最终答案一定能取到$\sum \min(2,c_i)$

实际上这个结论是可以通过构造过程中得到的，考虑对一条路径$(u,v)$，我们在新图上将$u,v$之间连一条边，对于得到的无向图中的一个环来说，沿着这个环走一遍，反映在树上就是这些路径经过的边都被正反走过两次

由于我们要给每一条路径定向，那么相当于要走过所有的路径并且尽可能的形成环，那么就可以联想到欧拉回路（欧拉回路实际上是若干环的并），对于存在欧拉回路的情况，在树上对应边正反经过的次数相同

这种情况只会存在与所有边被覆盖的次数为偶数的时候，如果有边被覆盖了奇数次，那么得到的新图中是不存在欧拉回路的

那么考虑如何将有覆盖次数为奇数的边转化成覆盖次数都为偶数的情况，那么可以强制这些奇数次的边正反经过次数恰好为1

那么我们可以通过补一条路径覆盖这个边即可，实现的时候我们在树上从深到浅枚举节点，如果当前节点在新图中度数为奇数，那么新增一条从当前点到父亲的路径即可

最终得到的图所有点一定都是偶数，那么直接跑欧拉回路即可

# AGC34D Manhattan Max Matching

首先需要发现的是$|rx-bx|+|ry-by|=$四种将绝对值去掉的最大值

那么相当于可以将$(r_x,r_y)$和$(b_x,b_y)$的贡献独立出来，每一个点可以选择四种贡献之一，并且四种情况$r,b$选择的个数相同

- 第一种情况，$r$集合点的贡献为$r_x+r_y$，$b$集合点的贡献为$-b_x-b_y$
- 第二种情况，$r$集合点的贡献为$r_x-r_y$，$b$集合点的贡献为$-b_x+b_y$
- 第三种情况，$r$集合点的贡献为$-r_x+r_y$，$b$集合点的贡献为$b_x-b_y$
- 第四种情况，$r$集合点的贡献为$-r_x-r_y$，$b$集合点的贡献为$b_x+b_y$

那么这个是类似一个匹配的问题，那么可以通过最大费用流进行解决，具体来说就是左侧$n$点，中间有$4$个点分别代表四种选择，左侧点与这四个点两两连边，代价为不同选择的代价

右侧同样建$n$个点，表示$b$集合的点，可以证明这样得到的图中在增广过程中是不存在正环的（如果存在正环实际上就可以证明原来的增广不是当前最优的增广路）

在原题上直接跑费用流就可以通过，模拟的时候增强了，那么就需要考虑模拟这个费用流的过程

首先每一次选择的增广路一定是不经过重复节点的，由于中间的中转节点只有4个，那么总共经过的节点实际上不超过12个

每一次的增广路都是形如

![graph (4)](D:\Blog\image\graph (4)-16478353882651.png)

这样的增广路，那么我们可以用可撤销贪心去维护这样的增广路，注意到这张图上实际上$1\rightarrow 5,6\rightarrow 3$都是进行反悔

那么我们对每一个中间节点用堆维护可以选择的左右侧节点代价以及编号，同时对于那些可以进行撤销的选择，同样用堆进行维护，但是我们维护的实际上是类似$1\rightarrow 5\rightarrow 2$这样的选择，那么代价相当于是(5选择2号选择的代价)-(5选择1号选择的代价)，那么就需要在任意两个中间节点中都维护进行撤销的选择（左右两侧都是要进行维护）

这样的话，可以在4个点之间跑最长路即可，一开始初始需要选择一个还可以选择的左侧节点作为出发点，然后通过撤销的边更新其他中间节点

最终选择一个还可以选择的右侧节点作为终止节点即可

这样的时间复杂度就是$O(n\log n)$的

# AGC33F Adding Edges

首先直接做是很难做的，但是注意到如果将选择的三个点确定顺序在树上路径中出现过，也就是说选择两条边$(a,b),(b,c)$如果树上存在一条路径按照$a,b,c$的顺序经过这三个点，那么就在$a,c$之间连一条边

这样的话对于最终得到的图$x,y$之间是否存在边有一个简单的判定法则，在图中存在一条从$x$到$y$的简单路径，并且按照这条简单路径的顺序在树上可以找到一条路径经过所有的点

那么如果存在$(a,b),(a,c)$这样的边的话，那么就需要将$(a,c)$这条边删除，再重新加入$(b,c)$这条边即可，考虑具体如何实现

像上面这种情况，$b$在$a,c$路径之间，那么在树上以$a$为根的话，在$b$子树内的所有节点$x$，如果存在$(a,x)$这样的边的话，显然可以将其缩成$(b,x)$，只需要在$b$子树内每一个点打一个$b$的标记即可

那么可以考虑一条边一条边加入，首先可以将加入的边缩成不能在缩的情况，假设当前的边为$(u,v)$，那么在$u$为根的$v$子树内，如果在之前加入的边中存在一个端点为$u$，另一个端点在$v$子树内，那么这条边也可以被缩短

那么我们在$v$子树内dfs，如果当前点没有标记，那么直接打上标记，如果存在标记，那么相当于找到了一条满足上面的条件的边，直接退出dfs即可（由于当前$v$到根子树内是不存在其他边的，那么dfs到的第一个节点一定还是存在于当前的图中的，那么需要进行修改，加入到待修改的边的队列中即可）

需要注意的是如果我们要打标记的点之间已经存在标记，直接跳过就可以了，因为最终另一个端点还是会变成一开始的标记

然后这样dfs下去即可，最后$u,v$交换重新做这个过程即可

这样的话，每一个边最多只会被缩短$2n$次，那么这里的复杂度为$O(nm)$

然后最后统计答案的时候，枚举存在的边的一个端点，然后从这个点开始在树上dfs，同时维护上一个在图中路径的端点$last$，然后注意到如果$tag(last,x)=x$，那么说明是存在一条$(last,x)$的边，那么当前的$x$是可以作为另一个端点的

## sol 2

还有一种做法是利用bitset，我们可以考虑维护一个待加入的边的队列，每一次从中取出一条边，加入到图中，然后找出选择这条新加的边之后可以加入的边，然后将这些与新加边关联的边加入到队列中

具体来说，如果预先确定好一条边$(u,v)$的话，那么另外一个点的$x$一定是在树上$u,v$的路径上，或者$u$的子树内或者$v$的子树内，那么我们可以用bitset维护出这些可能合法点集的mask即可

记$e(u)$表示当前图中与$u$相邻的点集，$e(v)$表示当前图中与$v$相邻的点集，那么$x\in (e(u)\cup e(v))\backslash(e(u)\cap e(v))$

那么求出这两个可能点集的交集，就可以确定另外一个点了

这样的时间复杂度$O(\frac{n^3}{w})$

# ARC138E Decreasing Subsequence

首先可以做一个转化，对于所有$A_i\neq 0$的位置，连一条$i\rightarrow A_i-1$的边，由于$A_i\leq i$，那么这样连出的图一定是一个DAG，并且由于每一个$A_i$只能出现一次，那么相当于这张图实际上是由若干条链组成的

那么相当于连出的图中节点的编号为$0...n$，那么选出一个长度为$k$的下降序列的话，那么对应着一个序列$L_1<L_2<L_3<...<L_k<R_k<R_{k-1}<...<R_1$

然后要求存在$R_i\rightarrow L_i$的边，实际上相当于选出$k$条链，然后取出其中的一条边，作为$R_i\rightarrow L_i$，那么可以将这条链上的节点分成两个集合，一个集合是$\leq L_i$的节点集合$A_i$，一个集合是$\geq R_i$的节点集合$B_i$

那么我们可以先选出所有$A_i$并集的节点位置，选出所有$B_i$并集的节点位置，并且将这两个节点集合各自划分成$k$条链集合，这个的方案数就是$S(|A|,k)\times S(|B|,k)$其中$s(x,y)$表示是第二类斯特林数

根据上面的连边方式，那么这两个集合连接起来的方式实际上只有一种

那么剩下的方案就是将剩下的节点进行链组合即可

那么就是$\sum s(n-|A|-|B|,k)$，那么可以通过预处理第二类斯特林数做到$O(n^2)$

实际上我一开始想了一个只能做$O(n^3)$的做法

就是可以考虑从大的数往小的加入数，那么只需要记录一下之前的选择多少个数放置到位置上的情况，那么就可以得到当前放置一个数可以放置的空位

那么考虑加入当前k长度的下降序列的最大值时候，就可以从当前剩下的空位中选出k个位置，然后在剩下转移的时候反向，可以求出贡献系数

但是在确定$k$个位置的时候，后面的影响会有$k$次转移，那么状态数需要多加一维，就只能做到$O(n^3)$

# AGC36D Negative Cycle

首先题目中要求没有负环的条件，与差分约束系统有解的条件是相同的，并且注意到边权只有三种，那么就可以往差分约束系统上靠

那么$n$个点就代表着$n$个变量，记$v_i$表示第$i$个点代表的变量

首先是图中一开始加入的边，那么限制着$v_i\geq v_{i-1}$

然后对于$i<j$的连边，限制着$v_i-1\geq v_j$

对于$j>i$的连边，限制着$v_j\geq v_i-1$

那么对于$v$序列来说，其相当于一个不增序列，那么可以考虑$v$相同的连续一段

那么首先考虑$i<j$的连边，由于$v_i\neq v_j,v_j\leq v_i$，那么$v_j\leq v_i-1$，那么说明限制对于不同两个段的位置始终成立，而段内不成立，那么只要在段和段之间连边即可

然后考虑$i>j$的连边，显然对于同一段之间的位置来说，一定是满足限制条件的，如果我们要求相邻两段之间的权值差等于1，那么可以在相邻两段之间连边

那么我们可以设$dp(i,j)$表示当前段的结尾为$i$，上一段的结尾为$j$的答案‘

就可以做到$O(n^3)$转移

# AGC22F Checkers

首先可以发现由于$x$足够大，那么我们可以将最终剩下的那个数看作关于$x$的多项式，那么相当于就是在问最终剩下的多项式有多少种

由于每一次操作都是需要删除作为对称中心的那个点，保留剩下的点，假设作为堆成中心的点编号为$x$，对称的点编号为$y$，记其多项式分别为$f_x,f_y$，那么操作之后得到的多项式就是$2f_x-f_y$

那么我们可以建立一个新的点$z$，然后令$f_z=2f_x-f_y$，然后删除$x,y$，那么相当于$x,y$作为$z$的左右儿子，并且连向左儿子的边上有系数权值$2$，连向右儿子的边上有系数权值$-1$

这样的话总共有$2n-1$个点，并且所有的点形成了满二叉树的关系，并且存在$n$个叶子节点，那么这些叶子节点就是对应着原来的$n$个点，并且其对最终多项式的贡献系数就是对应的叶子节点到根路径权值之积

需要特别注意的是此时所有叶子都是无序的，是我们需要分配初始节点编号，那么对于一个固定的序列$a$，方案数就是$\frac{n!}{\prod\limits_v (\sum [a_i=v])!}$

那么问题就变成了，对于所有可能的叶子序列的贡献和进行计数，首先我们需要判定一个序列是否合法

由于系数只有$-1,2$两种，那么说明序列中的所有元素都是正负$2$的次幂，可以从最大的数开始考虑，假如当前为$2^k$，那么对应的节点必须要和另一个$-2^{k-1}$的节点合并成$2^{k-1}$的节点

首先记$dp(k,i,j,p)$表示当前考虑到$2^k$级别的数，其中存在$i$个$2^k$的节点，存在$j$个$-2^k$的节点，并且剩余叶子节点还有$p$个

- 如果$i>j$，那么显然我们至少需要$i-j$个链来使得其合并成$2^{k-1}$级别的节点，并且需要的叶子节点也至少要$i-j$个$-2^{k-1}$，那么先转移到$f(k-1,0,i-j,p-i+j)$
- 如果$a<b$，那么显然我们至少需要$j-i$个链来使得其合并成$2^{k-1}$级别的节点，并且需要的叶子节点也至少要$j-i$个$2^{k-1}$，那么先转移到$f(k-1,j-i,0,p-j+i)$
- 如果$a=b$，那么我们只需要任意一种$2^{k-1}$级别的节点就可以了，那么先转移到$f(k-1,0,0,p)$上

那么对于$f(k-1,0,j,p)$来说枚举当前还存在$a$个$2^{k-1}$叶子，$b$个$-2^{k-1}$叶子贡献系数就是$\frac{1}{(a+j)!b!}$，对于$f(k-1,i,0,p)$来说也同样枚举

需要特殊处理$f(k-1,0,0,p)$的转移，同样还是枚举$a,b$，但是要求$a+b>0$即可

这样的时间复杂度就是$O(n^5)$，如果将$f$转移的两维独立转移，那么复杂度可以优化到$O(n^4)$

