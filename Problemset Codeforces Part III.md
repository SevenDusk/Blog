# CF1654G Snowy Mountain

首先可以通过bfs求出每一个点到最近的基地的距离

考虑从一个点出现的最优策略，显然在存在两个高度相同的节点相邻的位置，可以将所有的能量耗尽，然后直接走到终点，只考虑这样的路径一定包含了最优的路径

如果假设出发点为$s$，当前选择耗尽能量节点为$i$，那么最终路径长度为$2h_s-h_i$

然后考虑一下怎么样才会出现两个相邻的节点高度相同，我们可以记录一下每一个节点到最近的基地是哪一个（如果存在多个相同距离的基地，那么可以选择任意一个），当出现两个相邻的节点的时候一定是有一个基地的联通块在这个节点终止的，向其他方向延伸的是另一个基地

如果我们固定一个根，从下往上看每一对相邻并且高度相同的节点话，上面分析的性质说明每出现一对相邻的相同高度节点时候就是一个联通块的根，由于点的高度在树上是连续的，这个联通块的大小至少为这个节点的高度

那么也就是说所有存在相邻相同高度的节点$v$来说$\sum\limits_{v} h_v\leq n$

那么也就是说明不同的$h_v$只有$O(\sqrt n)$个，我们可以枚举这个耗尽能量的高度$h_i$，然后求出哪些节点可以到达这些存在相邻相同高度的节点

我们可以记$d_x$表示在枚举之后从$x$至少需要多少能量到达$h_i$这个高度中可以耗尽能量的节点，可以按照$h$分层，用bfs或者dij进行转移

通过分析其实可以知道两个方法复杂度都是$O(n\sqrt n)$的

# CF1667D Edge Elimination

首先可以发现的是可以删除一条边的时候当且仅当这条边的两个端点的度数奇偶性相同

考虑删除一个点周围所有边的情况，先考虑最简单的情况，就是连到的这些边的奇偶性都不变的情况

如果当前的节点度数为奇数，那么要求相邻的节点中奇数度数的个数恰好比偶数度数的个数多1，如果当前节点度数为偶数，那么要求相邻的节点中奇数度数个数等于偶数度数个数

那么这种特殊的情况，只会存在于所有儿子都是叶子的情况，并且需要确定当删除这个点和父亲连边时要求的度数奇偶性，那么可以对这两种情况确定是否存在方案

那么相当于可以对每一个节点维护两个变量，表示删除这个节点与父亲连边的时候为奇数度数是否可以，为偶数度数是否可以

那么在确定一个节点的时候，统计出儿子中存在多少个一定要是奇数度数的和一定要是偶数度数的，剩下的节点就是奇数和偶数都可以的情况，那么再通过之前的判断方式判断与父亲连边的奇偶性情况即可

只需要要求一定是奇数度数的节点数量$\leq$要求的节点数量即可，偶数度数的同理

然后构造的方案的话，需要维护子树内的删边方式，然后启发式合并即可

时间复杂度$O(n\log n)$

# CF1672G Cross Xor

首先需要考虑对$n,m$的奇偶性进行分类讨论

如果$n,m$都是偶数的话，通过选择第一行和第一列的格子进行操作的时候，可以发现最终只会对第一行第一列的那个格子进行异或1

那么这样就可以得到只对一个格子进行操作的方案，那么也就是对于所有$2^k$种情况都是合法的

然后考虑$n,m$其中一个是偶数另一个是奇数的情况，这里以$n$为偶数，$m$为奇数为例

现在要找一个不变量，可以发现对一行一列进行操作的时候，对于某一行的异或和的影响是可以简单刻画的，记$R_i$为第$i$行所有位置的异或和，$C_i$为第$i$列所有位置的异或和，最初的情况就是$R,C$都是0

如果对$(x,y)$进行操作的话，对于$i\in[1,n]$，$R_i$都异或1，对于$i\in [1,m],i\neq y$的$C_i$都异或上1

那么我们就可以得到一个判定01矩阵是否合法的充要条件，对于列来说，一定要有偶数个列中1的出现次数为奇数，对于行来说，所有行的0/1出现次数奇偶性相同

那么可以通过枚举行是全部0还是1，然后计算方案即可

考虑$n,m$都是奇数的情况，通过上面类似的分析，可以得到所有行和所有列中1出现次数的奇偶性都是要相同的，首先我们先求出将所有?换成0时候$R,C$的数值

如果所有行列的奇偶性要为0，那么需要通过?将$R,C$中为1的位置都异或1，如果所有行列的奇偶性要为1，那么需要通过?将$R,C$中为0的位置都异或1

然后考虑建图，对于所有行建一个点作为左部点，对于所有列建一个点作为右部点，然后如果$(x,y)$位置存在?，那么就在$x$行的点向$y$列的点连一条边

那么现在相当于说要选择一些边，然后将两端的点异或1，使得规定集合的点异或了奇数次

现在考虑对于每一个连通块进行计数，首先这个连通块中要求异或奇数的点一定要是偶数个，那么可以求出这个连通块的一个生成树

事实上，如果只考虑这个生成树，对于这个联通块所有点任意指定次数奇偶性都是可以唯一确定的，只要从叶子开始不断构造即可

那么方案数就是$2$的非树边数量次数，将所有联通块的方案乘起来即可

这样时间复杂度$O(nm)$

# CF1458D Flip and Reverse

首先考虑一下操作会对字符串产生什么影响，首先可以和括号序类似，将0看作-1，将1看作1，然后做的时候在考虑差分，实际上要考虑一下前缀和

首先操作的区间$[l,r]$需要满足$s_r=s_{l-1}$，然后相当于翻转这个区间内的前缀和，那么我们可以对于每一种$s_i$建出一个点，然后在$s_{i-1}$和$s_i$之间连一条有向边

那么进行一次操作相当于选取一个环，将这个环上的边方向反向

由于欧拉路径可以被拆解成若干个环，那么一个合法的字符串相当于图中一个欧拉路径

那么就相当于在图中求出一个字典序最小的欧拉路径

那么在dfs过程中贪心选，然后反向输出即可

这样的时间复杂度就是$O(n)$
