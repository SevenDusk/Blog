# AGC30C Coloring Torus

## 题目大意

给定$K$个颜色，要求构造一个$n\times n$的矩阵，要求所有格子的颜色是在这$K$个颜色中，并且所有颜色都必须要存在一个格子染这种颜色

对于$i,j\in [1,K]$来说，要求每一个染着$i$颜色格子四个相邻格子染$j$颜色的格子数相同
$$
K\leq 1000,n\leq 500
$$

## 算法讨论

对于最后那个条件，相当于是说对于相同颜色的格子周围格子的颜色集合必须相同

首先一个比较显然的是如果$K\leq 500$，那么就可以构造每一行$1,2,...,K$的$K\times K$矩阵

那么接下来考虑$K>500$，考虑一个$n\times n$的矩阵对角线的个数为$2n-1$，不妨在对角线上进行考虑

![20210928T1](D:\Blog\image\20210928T1.PNG)

可以这样进行构造，但是这样使用的颜色数还是$n$

这张图事实上是与副对角线对称的，可以如下构造

![20210928T2](D:\Blog\image\20210928T2.PNG)

对于每一种颜色都可以这样替换（n必须要是偶数），那么可以达到的颜色数就是$2n$

# AGC55A ABC Identity

## 题目大意

给定一个长度为$3\times n$的字符串，其中包含n个A，n个B，n个C，现在要求将这个字符串划分不超过6个子序列，使得每一个子序列都是好的

一个字符串是好的，当前仅当其长度为3的倍数，并且$T_1=T_2=...=T_k,T_{k+1}=T_{k+2}=...=T_{2k},T_{2k+1}=T_{2k+2}=...=T_{3k}$

构造划分方案

## 算法讨论

首先将序列分成三段，每一段长度为n，然后我们如果可以在三段中找到三个不同的字符，并且将所有字符都这样放到一个三元组里面

那么我们就可以按照ABC的排序进行分组，对于同一组就是一个子序列，由于ABC的排列为6个，那么这样划分一定可行

那么剩下的就是需要将所有字符放到这样的三元组里面，一个暴力的想法是，枚举ABC的每一个排列，然后将形成这个排序的三元组，全部去掉，对于所有排列重复这个过程

可以发现这样一定可以将所有位置分到三元组里面，考虑反证法，就是如果存在剩下的字符没有分到三元组里面，那么首先剩下A,B,C的数量相同，并且每一段剩下的字符相同，显然我们可以找到一个合法三元组

# AGC55B ABC Supremacy

## 题目大意

给定一个长度为n个字符串，字符串中只包含$A,B,C$，现在可以选择一个长度为3的子串ABC,BCA,CAB，然后将其替换成ABC,BCA,CAB中任意一个，现在给定两个字符串，问是否可以通过若干次操作，使得两个字符串相同

## 算法讨论

首先注意到，如果将$A$看作0，$B$看作1，$C$看作2，那么对于可以进行操作的ABC,BCA,CAB相邻的两个数字在模3意义下相差1，前面+1=后面

比赛的时候我一直想将两个位置进行差分，然后相当于每一次选择11然后对于前后进行加减，**但是这样我没有找到一个在进行操作过程中不变的量，主要还是操作比较复杂还需要进一步简化**

如果我们可以将ABC,BCA,CAB变成AAA,BBB,CCC的话操作会简单很多

那么我们将$a_i=s_i-A$，然后令$a_i'=(a_i-i)\bmod 3$，那么我们可以操作的长度为3的子串就为000,111,222

然后我们需要发现，如果某一个位置上存在$000,111,222$，那么左右两边的数可以任意穿过这三个位置，那么如果我们将这三个位置删除，并不影响余下的操作

如果我们将初始中的s的所有连续3段删除，剩下的数是在操作过程中不变的，那么相当于得到剩下的位置形成的字符串就是s在操作中不变的量

可以发现的是无论按照什么顺序删除这3段，最终得到的字符串是相同的，我们一开始可以将211122这种类型的串变成111222，那么任意三个连续的串都是不交的，那么我们最终得到的串是唯一的

那么我们对于s,t都进行这样的操作，如果结果相同，那么答案就是yes，否则答案为no

# AGC55C Weird LIS

## 题目大意

给定n,m求出有多少个长度为n的序列A满足以下条件

- $A_i\in [2,m]$
- 存在一个长度为$n$的排列$p$，使得对于每一个$i\in [1,n]$满足$p_1,p_2,...,p_{i-1},p_{i+1},...,p_n$的最长上升子序列长度为$A_i$

## 算法讨论

首先A中任意两个元素的差一定$\leq 1$，我们先不考虑A中所有数都相同的情况（这个情况是简单的），只考虑存在相差1的情况

首先假设$A$中最大的值为$k$，那么说明完整的$p$的LIS长度为$k$，而对于$A$中为$k-1$的位置，说明所有的LIS都是经过$p_i$的，所以在删除这个位置之后LIS的长度会$-1$

假设我们不考虑$LIS=k$的这个限制，只考虑对于所有$A_i=k-1$的位置，是否可以构造一个排列的LIS都是经过$p_i$的，显然是可以的，我们可以钦定$A_i=k-1$的位置上的数形成的是一段区间，并且是递增的，然后对于之间间隔的位置，填入大于这段区间的数就不会影响LIS的长度了，具体来说

- 首先考虑开头结尾都是$A_1=A_n=k-1$的情况，假设$A_i=k-1$的个数为$x$，并且其集合为$s$，那么我们令这些位置的数在$[1,x]$的区间内，对于$A_i=k$的位置都填入$>x$的数
- 然后考虑如果$A_1=k$，那么我们将$p_1=n$，如果$A_n=k$，那么我们将$p_n=1$，这样显然不会影响LIS，然后递归考虑中间的位置

然后我们还需要将$LIS=k$这个限制加上，会发现如果我们只用$A_i=k-1$来形成LIS可能长度不够（也可能超过k了）

首先如果$A_i=k-1$的个数$>k$，显然这个序列是不合法的

只考虑$A_i=k-1$的个数$cnt\leq k$的情况，那么对于$A_i=k$的位置还需要贡献$k-cnt$长度的上升序列，由于对于$A_i=k$的位置删除这个位置，LIS长度不变，那么说明存在一个位置$j$可以替代这个位置$i$，那么显然$A_j=k$，并且i，j之间位置都是$=k$的

那么我们将所有极长连续$A_i=k$缩成一段，我们可以将这段分成若干长度$\geq 2$的小段，对于一个小段，就是作为LIS的一个长度（位置）

对于一个小段来说同样可以看作$k-1$的情况，按照上面的进行构造，然后将填到这个小段中的数展开成一段区间即可

然后对于长度$=1$的段，就是看作上面构造过程的$A_i=k$的位置进行处理

那么原来序列的极长连续段长度为$b_1,b_2,...$

那么LIS长度的区间范围就是$[cnt,cnt+\sum \lfloor \frac{b_i}{2}\rfloor ]$，只要$k$在这个区间即可

由于只跟连续段的长度有关，那么我们就可以开始计数了，我们先枚举$A_i=k-1$的个数$i$，那么$A_i=k$的个数为$n-i$，我们枚举其中长度为奇数的段个数$x,x\equiv n-i(\bmod 2)$，那么得到的范围就是$[i,i+\frac{n-i}{2}]$，需要注意的是k的下界至少为3，上界为m，那么得到区间需要与$[3,m]$取交，记作$[l,r]$

至于方案数，考虑先将$A_i=k-1$排好，相当于连续段要放在$i+1$个空隙中，那么首先将奇数的位置放入，然后剩下$\frac{n-i-x}{2}$个2随意放到$i+1$个空隙中（就是球同盒不同可空，插板法即可），就是一组方案
$$
\binom{i+1}{x}\binom{i+\frac{n-i-x}{2}}{i}(r-l+1)
$$
直接枚举时间复杂度$O(n^2)$

最后考虑$A_i$中所有数相同的情况，显然除了$A_i=n-1$的情况下$A_i=k-1$，其他情况都是$A_i=k$，那么只需要$A_i\leq \lfloor \frac{n}{2}\rfloor$就是一组合法的序列

最终的式子为
$$
\sum\limits_{i=2}^m [i\leq \frac{n}{2}\or i=n-1]+\sum\limits_{i=2}^m \sum\limits_x \binom{i+1}{x}\binom{i+\frac{n-i-x}{2}}{i}(r-l+1)
$$
时间复杂度$O(n^2)$

# AGC31E **Snuke the Phantom Thief**

首先这道题目的数据范围就很像网络流的复杂度，但是限制有四个方向的限制，如果选择一个节点需要流出到四条边上，这会导致边权无法计算

那么需要观察到的是一个限制对选择点的影响是如何产生的，先以x轴的举例说明，对于一个限制要求横坐标$\leq a_i$最多选择了$b_i$个，那么如果将所有选择的点按照横坐标排序，那么也就是说第$b_i+1$个位置坐标是$>a_i$的，否则就不满足限制条件，这样就可以转化到选择出来的点和已有点之间的匹配

但是$b_i+1$可能会超过选择的点数，那么还是无法进行建图匹配，那么考虑到一旦确定了最终选出了多少个数$k$，那么也可以求出哪些限制有用，进行匹配的点数也可以确定

具体来说，对于一个坐标$\leq a_i$的点数$\leq b_i$，那么如果$b_i<k$，那么第$b_i+1$个坐标必须要$>b_i$，对于$\geq a_i$的限制，如果$b_i<k$，那么第$b_i+1$个坐标必须要$<b_i$

那么对于选择点排序过后的第$i$个位置，其限制坐标范围为$[L_i,R_i]$，同时对于$j\leq i$有$L_j\leq L_i,R_j\leq R_i$这样可以满足进行排序的关系（虽然可能$j$位置选择的实际点坐标在i之后，但是显然不可能超过$i$的坐标范围，那么进行交换编号即可）

那么直接求出最大权匹配即可

现在扩展到两维上，还是类似一个匹配模型，首先将原来的n个点进行拆点，限制这个点只能选择一次，然后对于每一位的$k$点，那么分别连向两侧对于坐标范围内的点即可



还有一种最开始想到的思路，就是如果单独考虑一个方向的限制，显然有用的限制的$b_i$一定是沿着这个方向单调递减的，那么可以利用其差分进行建图，选择一个点相当于对于一个后缀-1

但是考虑同一维上的另一个方向，相当于要给一个前缀-1，这就无法实现，考虑进行转化，假设最开始的方向是$\leq $，现在需要转化的方向是$\geq $，那么对于$<a_i$的数相当于至少有$k-b_i$个，那么我们需要枚举$k$，然后再原图上的边添加一个下界，求上下界费用流

# AGC45D Lamps and Buttons

首先由于是对所有排列进行计数，那么实际我们并不关心这个$A$个位置具体在哪里，所以最优的方案应该是每一次选择一个还没有被按过的开关，由于在之后的计数过程中不能算重，那么我们强制就选当前没有按过开关中最小的编号

注意到如果按的开关使得$p_i=i$，那么显然就是输了，否则的话我们就可以将$i$所在的环的灯全部按亮，那么就可以将这些位置的灯不看

那么可以设$f(i,j)$表示前$i$灯亮，后$j$个灯不亮的方案数
$$
f(i,j)=\sum\limits_{k=0}^{i-1}\sum\limits_{p=0}^j [k+p>0]\binom{i-1}{k}\binom{j}{p}(k+p)!f(i-1-k,j-p)\\
\frac{f(i,j)}{j!}=\sum\limits_{k=0}^{i-1}\binom{i-1}{k}\sum\limits_{p=0}^j\frac{(k+p)!}{p!} \frac{f(i-1-k,j-p)}{(j-p)!} -\frac{f(i-1,j)}{j!}
$$
考虑令
$$
G_k=\sum\limits_{i\geq 0} \frac{(k+i)!}{i!}x^i=(\frac{1}{1-x})^{(k)}=\frac{k!}{(1-x)^{k+1}}
$$
令$F_i(x)=\sum\limits_{j\geq 0} \frac{f(i,j)}{j!}x^j$

那么
$$
F_i(x)=\sum\limits_{k=0}^{i-1} \binom{i-1}{k} k!\frac{1}{(1-x)^{k+1}} F_{i-k-1}(x)-F_{i-1}
$$
令$z=\frac{1}{1-x}$

那么我们就可以得到一下的递推式
$$
F_i(x)=\sum\limits_{k=0}^{i-1} \binom{i-1}{k} k!z^{k+1} F_{i-k-1}(x)-F_{i-1}\\
f(i,j)=\sum\limits_{k=0}^{i-1}\frac{(i-1)!}{(i-1-k)!} f(i-k-1,j-k-1)-f(i-1,j)
$$
可以通过前缀和优化到$O(A^2)$，其中$f(i,0)$需要进行修正

## Solution 2

考虑枚举最小$t$满足$p_t=t$，如果不存在这样的$t$那么令$t=A+1$

由于我们无法强制$<t$的位置都是$p_i\neq i$的，那么就需要枚举这其中存在多少个位置$p_i=i$然后进行容斥，而对于$p_i=i$的位置直接删除即可

那么剩下的位置形成的环一定要包含后面的$n-A$个，这样才合法

那么问题就转化为有$a+b+c$个元素，其中$c$个元素一定要在$[1,a]$形成的环中，考虑$a$个元素任意排列$a!$，然后不断插入$c$元素，由于$c$只能插入到$a$形成的环中，那么方案数$a\times(a+1)\times...\times(a+c-1)$，最后插入$b$元素$(a+c+1)\times ...\times(a+b+c)$

这样的复杂度$O(A^2)$

# ARC118F Growth Rate

先将n+1，如果考虑所有$A_i=1$的情况的话，那么答案就是$\binom{m+n+1}{n+1}$那么答案是关于$m$的$n+1$次多项式，那么考虑扩展到$A_i\neq 1$的情况

如果我们是从前往后进行DP的，设$dp(i,j)$表示考虑前$i$个位置，最后那个位置填了$j$的方案数，那么相当于$dp(i,j)=\sum\limits_{k\leq \lfloor \frac{j}{a_i}\rfloor } dp(i-1,k)$，这样关于的就不是$j$的多项式，而是关于$\lfloor \frac{j}{a_i}\rfloor$的多项式，然后不断操作就很难处理

但如果我们倒过来考虑，令$dp(n+1,m)=1$，$dp(i,j)=\sum\limits_{k\geq a_ij} dp(i+1,k)$由于$a_i$是一个常数，那么还是关于$j$的多项式

由于次数只有$O(n)$，那么我们只需要维护出后$n$个值即可，就是我们可以求出某一个位置$j$的上界$r_i=\frac{m}{\prod _{j\geq i}a_j}$，然后维护$[r_i-n-5,r_i]$区间内的DP

需要注意到如果$a_i=1$的话，$a_ij$一定是落在上一个区间内的，但是如果$a_i\neq 1$的话就有可能落在区间之外，那么就需要用拉格朗日插值求出某一个位置的值，由于$a_i\neq 1$的位置只有$\log n$所以复杂度是正确的



另外一种做法是维护下降幂多项式的点值

假设我们当前从后往前考虑到第$k$位，设当前需要维护的多项式为$f_k(x)$考虑转移
$$
\begin{align}
f_k(x)&=\sum\limits_{j=ax}^m f_{k+1}(j)\\
&=\sum\limits_{j=ax}^m \sum\limits_{i=0}^d b_ij^{\underline{i}}\\
&=\sum\limits_{i=0}^d b_i\sum\limits_{j=ax}^m j^{\underline{i}}\\
&=\sum\limits_{i=0}^d b_i\frac{1}{i+1}((m+1)^{\underline{i+1}}-ax^{\underline{i+1}})
\end{align}
$$
那么只要将上式稍加整理，就可以得到次数为$d+1$的下降幂多项式，最终我们只需要求出一个单点点值即可
