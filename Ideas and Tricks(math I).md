# 1.树上拓扑排序计数

结论$\dfrac{n!}{\prod\limits_{i=1}^n size_i}$

对于节点$i$，其子树随意排序的结果是$size[i]!$

但$i$需要排在第一位，只有$size[i]-1$个数可以任意排

乘上$\frac{1}{size[i]}$

# 2.$\sigma$因数函数

性质：

$$\sigma _{0}(i*j)=\sum_{x\mid i}\sum_{y\mid j}[gcd(i,j)=1]$$

多维情况

$$\sigma_k (AB) = \sum_{x|A} \sum_{y|B} [\gcd(x,y)=1] (x \frac{B}{y})^k = \sum_{x|A} \sum_{y|B} [\gcd(x,\frac{B}{y})=1] (x y)^k$$

三个因数相乘情况

$$\sigma_k (ABC) = \sum_{x|A} \sum_{y|B} \sum_{z|C} [\gcd(x,\frac{B}{y})=1] [\gcd(y,\frac{C}{z})=1] [\gcd(x, \frac{C}{z}=1)] (x y z)^k$$

证明待填……

不填了……

 

# 3.循环矩阵

![1614195-20200727165124215-975785837](D:\Blog\image\1614195-20200727165124215-975785837.jpg)

形如上面的矩阵称为循环矩阵，可以通过只记录第一行来保存矩阵的所有信息

$m_{x}=\sum_{(i+j-2)\%n+1=x} m_{i}m_{j}$

那么可以$O(n^{2})$的时间内计算

将下标减1

$m_{x}=\sum_{(i+j)\%n=x} m_{i}m_{j}$

NTT计算即可

做到$O(nlogn)$

# 4.多项式DP，拉格朗日插值

DP如果某一维定义域很大，如果初始边界值是多项式的话，可以考虑这个DP是一个多项式，可以拉格朗日插值求出某一项我们需要的值

如果证明的话，可以通过归纳证明，先设上一个是多项式，代入递推式，将相同次数的项提出来，观察即可

常用自然数次幂的公式，记$g_i(x)=\sum_{j=1}^{x} j^i$

$(i+1)g_{i}(x)=(x+1)^{i+1}-1-\sum_{j=0}^{i+1}C_{i+1}^{j}g_{j}(x)$

可以递推，可以拉格朗日插值求特定值

# 5.二项式反演

$f_n = \sum_{i=0}^n (-1)^i {n \choose i} g_i \Leftrightarrow g_n = \sum_{i=0}^n (-1)^i {n \choose i} f_i$

常用形式 $f_n = \sum_{i=0}^n {n \choose i} g_i \Leftrightarrow g_n = \sum_{i=0}^n (-1)^{n-i} {n \choose i} f_i$

注意这里下标可以不从0开始，也可以倒序枚举

容斥的时候可以使用二项式反演

至多和恰好的转换，设$g[i]$为至多$i$个的方案数，$f[i]$为恰好$i$个的方案数

$g[i]=\sum_{j=0}^{i}\binom{i}{j} f[j]$

二项式反演得到 $f[i]=\sum_{j=0}^{i} (-1)^{i-j}\binom{i}{j}g[j]$

 至少和恰好的转换，设$g[i]$为至少$i$个的方案数，$f[i]$为恰好$i$个的方案数

 $g[i]=\sum_{j=i}^{n}\binom{j}{i} f[j]$

 二项式反演得到 $f[i]=\sum_{j=i}^{n} (-1)^{j-i}\binom{j}{i}g[j]$

但这样可能难以找到什么实际意义来解释

考虑至多和恰好的转换，对于一个需要求出恰好$k$的方案数，先找出问题至多的下界记作$least$，那么当有$least$个的时候，至多和恰好的方案数相同，那么向前递推。在递推过程中，每一项都可以计算出至多的方案数，先乘上$\binom{i}{k}$，减去之前计算好的前缀和，表示减掉比$i$小恰好的方案数，直到递推到$k$

至少同理

![1614195-20200914201712766-285451627](D:\Blog\image\1614195-20200914201712766-285451627.png)

# 6.上升幂下降幂和斯特林数

$x^{\overline{n}}=\sum_{k=0}^{n}\begin{bmatrix}n\\k\end{bmatrix} x^{k}$

$x^n=\sum_{k=0}^{n}\begin{Bmatrix}n\\k\end{Bmatrix}x^{\underline{k}}$

第一类斯特林数递推式

意义：$n$个不同元素形成$m$个圆排列的方案数

$\begin{bmatrix}n\\k\end{bmatrix}=\begin{bmatrix}n-1\\k-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\k\end{bmatrix}$

第二类斯特林数递推式

意义：$n$个不同元素放入$m$个相同的盒子，盒子不可空

$\begin{Bmatrix}n\\k\end{Bmatrix}=\begin{Bmatrix}n-1\\k-1\end{Bmatrix}+k\begin{Bmatrix}n-1\\k\end{Bmatrix}$

有通项公式

$s(n,m)=\frac{1}{m!}\sum_{k=0}^{m} (-1)^{k}\binom{m}{k}(m-k)^{n}$

可以卷积

# 7.矩阵乘法

如果矩阵乘法在中间有断点的话（也就是需要分成若干段，每一段分别做矩阵快速幂），可以先预处理出来转移矩阵的2次幂的次数，那么通过二进制拆分就可以得到任意转移矩阵的次幂，在转移的分段的时候不需要每次乘一个$n*n$的大矩阵，可以乘一个一行的向量，向量和矩阵的乘法是$O(n^2)$，那么每一段的时间复杂度就是$O(n^2logMAX)$，预处理复杂度$O(n^3logMAX)$，那么总复杂度就是$O(n^3logMAX+kn^2logMAX)$

# 8.扩展欧拉定理（欧拉降幂）

$$
a^{x}\equiv \left\{\begin{matrix}a^{x \bmod \varphi (p)} & gcd(a,p)=1 \\ a^{x} & gcd(a,p)\neq 1,x<\varphi(p) & \\ a^{(x \bmod \varphi(p))+\varphi(p)} & gcd(a,p)\neq 1,x\geq \varphi(p)\end{matrix}\right.(\bmod p)
$$

[Power Tower](https://codeforces.com/problemset/problem/906/D)

# 9.线性基

离线下来，在线性基里面优先存储较晚删除的数，在判断一个数是否是在线性基里面，只要尝试插入线性基，如果这个数不能成功插入线性基，并且用到的线性基中的元素的删除时间都在当前时间之后，那么这个数就可以被异或得到

```cpp
struct liner
{
    int d[40],t[40];
    inline void insert(int x,int id)
    {
        for (int i=29;i>=0;i--)
        {
            if (!((x>>i)&1)) continue;
            if (t[i]<id) swap(t[i],id),swap(d[i],x);
            if((x>>i)&1) x^=d[i];
        }
    }
    inline int query(int x,int l)
    {
        for (int i=29;i>=0;i--)
        {
            if (!((x>>i)&1)) continue;
            if (t[i]<l) return 0;
            x^=d[i];
        }
        return 1;
    }
}T;
```

一些性质

- 线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。
- 线性基是满足性质 1 的最小的集合。
- 线性基没有异或和为 0 的子集。
- 线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。
- 线性基中每个元素的二进制最高位互不相同。
- 原集合的数互相异或得到的集合的线性基和原来的线性基等价

线性基的严谨定义

> 向量空间$V$的一组向量若满足
>
> 1）线性无关
>
> 2）$V$中任一向量可由此向量线性表出，则称该组向量$V$中的一个基（亦称基底）。

上面讨论的线性基中的向量可以看成一个数的二进制表示，向量中每一个元素都为$0$或$1$，并且定义向量的加减法为模2意义下进行的。其实构造线性基的过程中，就是在判断试图插入的向量是否跟之前所有的向量线性相关，如果线性相关那么就不插入到线性基中，如果线性无关那么就插入到线性基中

就是在解$a_1x_1+a_2x_2+...+a_nx_n=b$模$2$意义下的这个方程组（向量中每一个维都可以列出一个方程）

而解这个方程的基本思路就是，把当前的最高位先消元消掉，不断消下去，看能不能得到$0$，如果不行说明这个向量于之前的向量线性无关，插入线性基中

那么这种线性基的构造方式可以推广到$n$进制下的异或（不进位加法），思路跟二进制下的一样，先利用之前的向量试图把最高位给消掉，直到消不掉或者当前向量被消成了$0$

应用：扩展NIM博弈（先手必败条件：每一堆个数拆分为$2$进制下，每一位为$1$的个数$\%(d+1)=0$)

# 10.博弈论

所有$ICG$游戏，都可以转变到$DAG$图上游走游戏

一般要将状态归成一个简单的规律，然后可以试图证明这个规律

证明有三步：

1.证明最终状态是必败态

2.证明必胜态可以转移到一个必败态

3.证明必败态只能转移到必胜态

------



基本模型有：巴什博弈，NIM博弈（EX），威佐夫博弈（EX），斐波那契博弈

NIM博弈结论：每一堆石子异或和为$0$时，先手必败

EXNIM博弈结论：每一堆个数拆分为$2$进制下，每一位为$1$的个数$\%(d+1)=0$，先手必败

威佐夫博弈：第k个必败态为$\left (\left \lfloor \frac{1+\sqrt{5}}{2}k \right \rfloor,\left \lfloor \frac{3+\sqrt{5}}{2}k \right \rfloor \right )$

可以利用Betty定理证明（$\frac{1}{a}+\frac{1}{b}=1$，$Spec(a)$和$Spec(b)$分别为正整数的划分，并且没有交集）

$b=a+1$（第一项），带入即可

斐波那契博弈：当石子数为斐波那契数时先手必败

**阶梯博弈：**

两个绝顶聪明的人在玩游戏，有$n$堆石子，每次每人可以取走第$i$堆$(i>1)$任意数量的石子并将它们放到第$i−1$堆，或者直接取走第一堆的任意数量石子，不能操作的人输，请问先手能否必胜？

对于这一类问题我们将堆的编号分奇偶考虑，如果只有奇数编号那些堆石子，这就是一个尼姆博弈。现在加入了偶数编号的堆，同样不影响答案，因为如果有人将偶数编号第$i$堆的石子移到第$i−1$堆，那么另一个人可以将上一个人操作的那些石子从第$i−1$堆再移到第$i−2$堆，这样奇数编号堆的局势没变，两人的先后手关系也没变，相当于将偶数堆编号的石子往前移了两次。而移动奇数堆到偶数堆就相当于拿走了石子。

 

SG定理：由$n$个$ICG$游戏组合起来的游戏，先手必败的条件为$SG(a_1)\ Xor\ SG(a_2)\ Xor\ ...\ Xor \ SG(a_n)=0$

# 11.平面图欧拉定理

$$V+F=E+2 \tag{25.1}$$

其中这个公式在连通图的情况下成立，其中$V$为图的顶点数，$E$为图的边数，$F$为这张图把平面分成了几个部分（包括图以外的一个平面）

$$V+F-E=K+1 \tag{25.2}$$

$V$,$F$,$E$跟上文表述一致，$K$表示整个图形中有$K$个联通图，其中$K=1$时即为$(25.1)$

应用：网格图上求连通块

题目:[「APIO2017」斑斓之地](https://loj.ac/problem/2310)

# 12.多项式全家桶

首先要知道两个东西，牛顿迭代和泰勒展开

先讲泰勒展开

$f(x)=f(0)+\frac{f'(x_0)}{1!}(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+\dots \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$

一种形象的理解方式是：对于一个光滑的曲线考虑用一个多项式函数去逼近它，首先考虑的是先选取原来函数上一个点，是多项式函数经过这个点，这仅仅是保证在这一个点上多项式函数和原函数相同，那么考虑如何更精准的逼近，函数的性质中最先注意到的是函数增减性，也就是函数的导数，那么让多项式函数在这一点的导数也和原函数的导数相同，保证这一点之后，会发现多项式函数和原来的函数趋势已经相同，之后就考虑函数凹凸性，即二阶导数，之后以此类推，不断逼近，就得到上面的表达式

# 13.对于统计答案幂次的技巧

对于$x^k$，考虑其组合意义：将$k$个不同球放到$x$个不同的盒子里的方案数，直接维护不好维护，那么考虑枚举把这些球放到了哪些盒子里，最后乘上第二类斯特林数和对于的阶乘（保证盒子有序），可以利用一个dp来统计，每次转移的时候考虑是否选择这个盒子$x$

然后这个做法相当于维护了答案的下降幂，由于下降幂优秀的性质

$(x+1)^{\underline{m}}= x^{\underline{m}}+mx^{\underline{m-1}}$

最后利用第二类斯特林数将下降幂转化为普通幂即可

#  14.解递归式$f_x=af_{x-i}+bf_{x-j}$

考虑其组合意义，相当于是爬楼梯，每一次可以走$i$步代价为$a$，或者走$j$步代价为$b$，总代价为每一步代价的乘积，然后问所有走到$n$的方案的代价总和为多少

可以枚举其中一种步走了多少次

$\sum_{k=0}^{\lfloor \frac{n}{i} \rfloor} [j|n-ik]a^kb^{\frac{n-ik}{j}}\binom{k+\frac{n-ik}{j}}{k}$

当然如果代价是每一步之和也是同理

# 15.$(x_1+x_2+...+x_n)^k \equiv x_1^k+x_2^k+...+ x_n^k(\mod k)$k为质数

$\\ \equiv \sum_{\sum k_i=k} \binom{k}{k_1,k_2,...,k_n}x_1^{k_1}x_2^{k_2}...x_n^{k_n}$

$\\ \equiv \sum_{\sum k_i=k} \frac{k!}{k_1!k_2!...k_n!}x_1^{k_1}x_2^{k_2}...x_n^{k_n}$

如果$k_1,k_2,...,k_n$中不存在一个$k_i=k$那么系数中一定存在$k$这个因子，那么取模之后系数就变为$0$

那么上式得证

# 16.快速沃尔什变化

FWT可以处理形如$C_{i\oplus j}=A_i*B_j$形式的卷积

**OR/AND卷积**

首先由于FWT是一个对于多项式的线性变换（说白就是不会出现自己乘自己的情况）

那么$FWT(A+B)=FWT(A)+FWT(B)$

由于按位或的特点可以构造出

$FWT(A)[i]=\sum_{i|j=i}A_j$

这个基于当$i|k=k,j|k=k$时，$(i|j)|k=k$，那么可以通过归纳证明出FWT的确等于这个运算

考虑如何计算，根据FFT的经验考虑，按首位$0/1$分类记作两个多项式$A_0,A_1$，假设$FWT(A_0),FWT(A_1)$已经计算得出

那么$FWT(A)=(FWT(A_0),FWT(A_0)+FWT(A_1))$

逆运算$IFWT(A)=(IFWT(A_0),IFWT(A_1)-IFWT(A_0))$，其中第$i$项表达式$a_i=\sum\limits_{j|i=i} (-1)^{|i|-|i\cap j|}a_j$

如果首位是$0$和$1$的两个数或起来，其首位一定为$1$，那么$FWT(A_1)$不可能贡献到首位为$0$的位置，而原来首位为$0$和首位为1的数或之后，会对应的加到最高位添上了一个$1$的位置上，因为保证了低位或起来一定是原来的低位

与运算其实是一样的

$FWT(A)=(FWT(A_0)+FWT(A_1),FWT(A_1))$

**XOR卷积**

大体思路也是和OR卷积相同，只是运算特点不一样，记$cnt(x)$表示$x$在二进制下$1$的个数模$2$的结果

$cnt(i \& k) \wedge cnt(j \& k)=cnt((i \wedge j) \& k)$

那么$FWT(A)[i]=\sum_{cnt(i\&j)=0} A_j-\sum_{cnt(i\&j)=1} A_j$，归纳同样可以证明

结论$FWT(A)=(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))$

主要说这一个公式的理解

首先考虑$A_1$，当$A_1$中某一个下标贡献到首位为$0$的位置$i$上时，由于$i$最高位为$0$，在FWT的计算式中的下标$j$，$cnt(i\& j)$是不会变的，那么正负号相同，不会变号，所以加上$FWT(A_1)$

当$A_1$贡献到首位为$1$的位置上时，由于$i,j$的最高位都是$1$，那么$cnt(i\& j)$会比原来$+1$，那么会变号，需要减去$FWT(A_1)$

再考虑$A_0$，由于原来的最高位为$0$，$cnt$的值不会发生改变，计算式中也不会变号，那么无论是$0$还是$1$就直接加上即可

在推式子的过程中常用的形式

设$\overline{F}$表示$F$的$FWT$结果

$[x^S]\overline{F}=\sum\limits_T (-1)^{|S\cap T|} [x^T]F$

$IFWT$就是

$[x^S]F=\frac{1}{2^n}\sum\limits_T (-1)^{|S\cap T|} [x^T]\overline{F}$

upd：对于xor卷积的一些不同角度的理解

本质上我们可以将xor称为二进制不进位加法，实际上相当于对于每一位都看成独立的一维，然后对于每一维进行循环卷积（DFT的过程）

假设我们要对于$k$维不进位加法进行fwt，那么相当于我们要对每一维进行长度为$k$的循环卷积，根据DFT的性质，我们需要求出$k$次单位根$w_k$，并且求出在$1,w_k^1,w_k^2,...,w_k^{k-1}$处的点值

如果是需要取模，如果当前模数对于1存在$k$次单位根的话直接使用即可，如果不存在的话，那么每一个位置就需要用$\sum a_i w_k^i$的形式来表示

如果是实数fwt，那么直接用复数进行表示即可

这样的时间复杂度$O(nk^2k^{n-1})$

# 17.min-max容斥

$\max(S)=\sum_{\varnothing\not=T\subseteq S}(-1)^{|T|-1}\min(T)$

反过来也同样成立

证明：

考虑集合中一个数$x$，设比$x$大的数有$k$个

考虑$min(T)=x$的集合$T$

枚举集合大小，其总方案数为$\sum_{i=0}^{k}(-1)^i\binom{k}{i}=[k=0]$

那么只有当$k=0$时，$x$有贡献，即$x=max(S)$

对于期望这个式子也是成立，不过这里$max$表示满足所有条件的期望，$min$表示至少满足一个条件的期望，带入式子即可

扩展

$kthmax(S)=\sum_{\varnothing\not=T\subseteq S}(-1)^{|T|-k}\binom{|T|-1}{k-1}\min(T)$

# 18.树上高斯消元

当一些树上的期望DP既要依赖儿子信息又要依赖父亲的信息，此时简单的dfs就无法更新DP值，需要高斯消元

由于树的特殊性质，树上高斯消元可以做到$O(n)$

将$dp$方程式改写成,$dp[x]=A_xdp[fa[x]]+B_x$的形式，不断用这个形式更新父亲，直到根节点，最后在根节点解出方程，再反代入解出所有节点的$dp$值

应用：树上随机游走

# 19.利用期望来计数

对于一些直接计数较难的题，可以考虑用期望来计算，最后乘上方案数即可

由于期望的线性性，那么可以拆开计算贡献，这样可以只看一个部分而不用关注整体

