# 1.DAG上的问题退化成有向树解决

如果转化为DAG问题的题目，如果边与边之间有传递关系

可以退化成树进行解决

在建树的时候需要关心的是某一个点的直接父亲是什么

如ATcoder的[ABC158F](https://atcoder.jp/contests/abc158/tasks/abc158_f)

# 2.完全图

建反图，那么原来的完全图，在反图上就是一堆独立的点，互相没有边连接，判断即可

# 3.最小割

最小割等于最大流

利用最小割建图的题目一般会有多种选择，并且会有一些限制条件

对于多种选择，一般来说会拆点，拆成一条链，链上每一条边就代表一种选择边权为这种选择的价值/代价，然后链的两端分别连向汇点和源点，边权为$inf$（边权设为$inf$的目的就是强制不让选这条边），那么这样在最小割的时候一定会在这条链上选出一个合法且最小的边割掉，使这条路径不连通源点和汇点

关于限制的连边，一般来说是通过在限制的点中构造出一条路径，并且除了原来在链上的边，其他的边权都是$inf$，这样就可以表达限制某种条件

说起来很抽象，大概思路就是利用$inf$边来强制不选这条边，然后合理地构造建图

然后还有一个问题就是如果在建边的时候有负权，那么需要把所有边都加上一个余量，使得都变成正权边，跑出答案之后再减去即可
$$
\min \sum\limits_iCost_i A_i \overline{B_i}
$$
对于这种最优化问题，可以建出最小割模型

<img src="D:\Blog\image\graph (4).png" alt="graph (4)" style="zoom:67%;" />



[ARC107FSum of Abs](https://atcoder.jp/contests/arc107/tasks/arc107_f)

# 4.最大权闭合子图

闭合子图就是所有在这个图上的点连出的边指向的节点仍然在这个图上

在网络流中这个模型很常见

首先将对于一个有向图中如何求出最大权闭合子图

对于原图上的边仍然保留并且边流量赋为$inf$

对于点权为正的点，$s$连向这个点，并且流量设为点权权值

对于点权为负的点，这个点连向$t$，并且流量设为-点权权值

最后跑出最小割，所有正点权之和减去最小割即为最大权值

这个模型可以用来限制选择之间有关系的情况，比如“选了$x$必须选$y$”的情况

# 5.2-SAT

其主要思想是利用对称性建图，然后保证了一些性质，使选取拓扑序较大的点时，不会存在矛盾

主要需要注意的是，建图的时候一定要保证对称性

对于强制某一个点需要选某一个状态的建边将这个状态直接向另一个状态连边

![img](D:\Blog\image\1614195-20201118190204787-1638174385.png)

# 6.对于矩阵选数的一些问题

对于每一行每一列只能选一个数，问选出来的数的最大值，这可以转化为二分图最大权匹配问题，就是对于每一个列和行建一个点，不同列和行之间连一条边，边权为行列相交的那个元素大小

然后费用流跑就行了或者KM

对于这种只能选一个的问题，需要联想到匹配的模型，因为匹配的点只能最多连出一条边，这可以对应题目的限制

# 7.Hall定理

对于二分图的两部分端点，点集分别记作$X,Y$，其中$|X|\leq |Y|$，对于$X$中任意一个子集$W$，记$NW$为$W$中点在$Y$中有连边的点集

那么对于任意的点集$W$，都有$|W|\leq |NW|$时，二分图存在完美匹配

推论：二分图的最大匹配为$\lvert X \rvert - max\{\lvert W\rvert -\lvert N(W)\rvert \}$

# 8.竞赛图求哈密顿回路

竞赛图就是无向完全图给每条边定一个方向，在任意一个竞赛图中一定存在一条哈密顿路径，在一个强连通的竞赛图中一定存在一条哈密顿回路

对于求哈密顿路径，可以如下的归纳构造

对于$1$到$i-1$的点，我们假设已经求得其哈密顿路径

如果当前i号点有连向$1$号点或者$i-1$号点连向了$i$号点，那么直接加入路径的首或者尾

否则记$x$号点为$i$第一个连向的节点，那么$[1,x)$中的节点，都是连向$i$的，那么可以构造$...(x-1)\rightarrow i\rightarrow x\rightarrow (x+1)...$的路径

求得哈密顿路径之后就可以构造哈密顿回路，那么首先找出最后一个有边连向第一个节点的点

考虑还是归纳构造，对于$1$到$i-1$的点已经构造出其哈密顿回路，也就是一个环

分两种情况讨论，首先如果没有边连向环中，那么先跳过这个节点，向下考虑

那么设第一个环中的节点$x$，使得$i$连向$x$，那么可以构造一个新环，就是将所有当前不在环中的点，依次插入$x$前面

# 9.拿出图的一棵 dfs 树，其中一条非树边和其两端点的树上路径所构成的环是这个图的环空间的基

# 10.DAG的覆盖问题

精确覆盖指把用最少的路径，覆盖所有的节点，并且只覆盖一次，做法是拆点，拆成入点和出点，原图上的边仍然保留，但是由出点连向入点，求二分图最大匹配，答案为所有点数减去二分图最大匹配数

任意覆盖指用最少的路径，覆盖所有的节点，一个点可以被覆盖多次，在精确覆盖的做法上，增加出点到对应入点的反向inf边，然后跑最大流 

首先做一遍二分图最大匹配，然后令左边点只能走非匹配边，右边的点只能走匹配边

二分图的一种最小点覆盖就是左侧的未访问点加上右侧的已访问点；二分图的一种最大独立集就是这些点的补集（对于二分图所有点全集）

边的精确覆盖，可以转化成上下界网络流，就是将原来DAG上的边的容量上限下限都设置为1，源点向每一个点连边，然后跑上下界最小流

任意覆盖就是将每一条边的容量上限改为inf

# 11.Undirected Vertex Geography

经典结论

描述：初始时在二分图的一个点上，两人轮流沿着边走，不允许重复访问节点，不能移动者输。

对于该问题有以下定理：起点$v$是先手必胜的，当且仅当它在所有最大匹配上。

必要性：若存在一个最大匹配$M$使得起点$v$不在其上，那么先手每次操作时，要么无路可走，要么走到了某个匹配点上（否则就找到了一条增广路）。于是，后手只要每次走到$M$中与该点匹配的点即可。
充分性：若$v$在所有最大匹配上：
我们有增广路定理的如下推论：对于无向图$G$和其任一最大匹配$M$，点$v$必定在最大匹配上，当且仅当对于$M$，在匹配上且不存在以$v$为一端的偶数长度交替路。
于是，我们取任意最大匹配$M$，现在先手把$v$移动到$M$中与之匹配的点上。那么由于不存在以$v$为一端的偶数长度交替路，移动后并删去点$v$的图中也不存在增广路，于是由增广路定理从$M$中删去先手走的边后仍然是最大匹配，且现在$v$在未匹配点上。于是情况和必要性证明中相同，先手必胜。

对于一般图来说这个结论也是同样成立的

# 12.Primal_Dual原始对偶算法（费用流）

比较适用于特殊图费用流，速度比$spfa$快很多，因为单次（多次）增广复杂度严格$O(nlogn)$，只要第一次求势能函数的时候，如果图有性质，可以避免$spfa$求最短路

首先是将求最短路的算法改成$dijkstra$，但是考虑到原来图上存在负权边，直接跑$dijkstra$不行

考虑给每一条权赋势能函数

这里势能函数$h(x)=dis(s,x)$，$dis(s,x)$表示原图上源点$s$到$x$的最短路

然后利用**三角不等式**$h(u)+w_{u,v}\geq h(v)$

移项$w_{u,v}+h(u)-h(v)\geq 0$，那么将新的边权赋为$w_{u,v}+h(u)-h(v)$，就保证了图上边权非负

可以证明，原图上最短路径所经过的点和新图上最短路径所经过的点是相同的

且$dis'(s,x)=dis(s,x)-h(x)$，增广也很方便

由于跑网络流的时候图是在动态变化的，那么也要动态维护势能函数

结论是$h'(x)=h(x)+dis'(s,x)$

证明略

# 13.无向图dfs树不存在横叉边，只存在返祖边

# 14.将图的规模缩小，但同时保证答案

# 15.前后缀优化建图

就是对于一个需要连完全图（两个点集需要两两连边）或者是区间连边，如果之间连边的复杂度是$O(n^2)$

对于一般的线段树优化建图，复杂度往往会多一只$\log$

而前后缀优化建图连出的点数和边数都是$O(n)$级别，并且好调好写

其思想就是利用两条链，在对应位置分别下挂两个集合$A,B$的点，那么对于某一个节点$x\in A$如果要向B的链上某一个前缀（后缀）连边，那么只要在对应位置的链上链一条边即可

<img src="D:\Blog\image\graph-1619099890299.png" alt="graph" style="zoom: 50%;" />

如图，$A$的前缀$[1,2]$和$B$的后缀$[4,5]$就进行了连边

有时候可以前后缀混合使用

例题[587D - Duff in Mafia](https://codeforces.com/problemset/problem/587/D) 前缀优化建图2-sat

[P3783 [SDOI2017]天才黑客](https://www.luogu.com.cn/problem/P3783) 虚树+前后缀优化建图

# 16.Hierholzer 算法

求解一组合法欧拉回路/路径的算法

1. 选择任一顶点为起点，遍历所有相邻边。
2. 深度搜索，访问相邻顶点。将经过的边都删除。
3. 如果当前顶点没有相邻边，则将顶点入栈。
4. 栈中的顶点倒序输出，就是从起点出发的欧拉回路。

**性质一**：

如果该图为欧拉图，则栈底的必定为起点。如果该图为半欧拉图，则栈底部存储的是与起点不同的另外一个奇度数顶点。

**证明**：

当顶点入栈时，说明当前所在顶点没有相邻边。

考虑到从起点出发到当前结点的路径中，除了起点和当前顶点外，其他的顶点都失去了偶数度数(入度与出度一一对应)。

如果起点和当前顶点不同，那么两者都失去了奇数度数。

如果图中包含欧拉回路，意味着所有顶点的初始度数都是偶数，而当前顶点的当前度数为0，表示当前顶点的初始度数必定是奇数，产生矛盾，因此假设不成立，当前顶点就是起点。

同样地，对于欧拉路径，当前顶点不可能是起点，否则起点的度数就是偶数，而欧拉路径中起点和终点的度数一定是奇数。

因此，当前顶点不是起点，但是度数也是偶数，所以一定是终点。

**性质二**：

如果该图为欧拉图(/半欧拉图)，则栈中的自底到顶第 ![[公式]](https://www.zhihu.com/equation?tex=n) 个顶点就是欧拉回路(/欧拉路径)上的第 ![[公式]](https://www.zhihu.com/equation?tex=n+) 个顶点。

**证明**：

在此只证明栈中相邻顶点在图中也为相邻顶点。因为模拟 Hierholzer 算法过程，可知该算法实际上就是在模拟“一笔画”过程，并且沿着画完的轨迹，从终点倒着逐一添加顶点到栈中。

并且主要以 ![[公式]](https://www.zhihu.com/equation?tex=n%3D2) 的情况为例，后面的情况可以此类推。并且为了不用纠结于区分欧拉回路和欧拉路径，不妨以半欧拉图为例。

假设图中存在相邻的两顶点 ![[公式]](https://www.zhihu.com/equation?tex=V_1%2CV_2) ，并且深度搜索过程中，先访问 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 随后访问了 ![[公式]](https://www.zhihu.com/equation?tex=V_1) ，并且 ![[公式]](https://www.zhihu.com/equation?tex=V_1) 成为第一个入栈的顶点。由**性质一**可知， ![[公式]](https://www.zhihu.com/equation?tex=V_1) 就是欧拉路径上的起点(两个奇度数顶点任一可看作起点)。

根据 **Hierholzer 算法**，在遍历过程中，删除了途径的边，所以此时所有顶点的度数都为偶数。当然 ![[公式]](https://www.zhihu.com/equation?tex=%5Cdeg%28V_2%29) 也是偶数，接下来就分类讨论。

如果 ![[公式]](https://www.zhihu.com/equation?tex=%5Cdeg%28V_2%29%3D0) ，也就是说当前顶点 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 成为第二个入栈的顶点，那么 ![[公式]](https://www.zhihu.com/equation?tex=n%3D2) 的情况就证毕了。

如果 ![[公式]](https://www.zhihu.com/equation?tex=%5Cdeg%28V_2%29%3E0) ，那么考虑当前包含 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 的子图 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbf%7BG%7D) ，显然 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbf%7BG%7D) 是一个欧拉图，那么当前以 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 为起点继续实施 Hierholzer 算法遍历剩下的相邻边，根据**性质一**， ![[公式]](https://www.zhihu.com/equation?tex=V_2) 将会是 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbf%7BG%7D) 中第一个入栈的顶点。也就是， ![[公式]](https://www.zhihu.com/equation?tex=V_2) 是原图中第二个入栈的顶点。

综上所述，以此类推， ![[公式]](https://www.zhihu.com/equation?tex=V_%7Bn-1%7D) 入栈前最后接触过的 ![[公式]](https://www.zhihu.com/equation?tex=V_n) 将会是第 ![[公式]](https://www.zhihu.com/equation?tex=n) 个入栈的顶点，再结合直观理解， ![[公式]](https://www.zhihu.com/equation?tex=V_n) 就是路径上的第 ![[公式]](https://www.zhihu.com/equation?tex=n) 个顶点。

跟一般的$dfs$不同的是，边序列是在递归结束之后再加入的

```C++
void dfs(int x)
{
	for (int i=nrl[x];i!=-1;i=nxt[i]) if (!vi[id[i]])
	{
		int u=point[i];nrl[x]=i;
		vi[id[i]]=1;
        //ans.push_back(m_k(x,u));不是在这里加边
		dfs(u);
		ans.push_back(m_k(x,u));//是在这里加入
		i=nrl[x];
		if (i==-1) break;
	}
}
```

**事实上这个算法，如果是找欧拉路径的话，那么本质上就是找出图上两个奇点之间的路径，然后将这条路径所经过的边删除，并且找到的表示就是当前点没有未访问过的边**

**那么起点是偶点的话，相当于就是找出图上的一个环，然后将路径上的边删去**

# 17.Bron–Kerbosch算法

求解最大团的算法，复杂度$O(3^{\frac{n}{3}})$

伪代码如下

```text
R := {}
P := node set of G 
X := {}

BronKerbosch1(R, P, X):
    if P and X are both empty:
        report R as a maximal clique
    pivot=first vertex of P
    for each vertex v in P:
    	if (pivot,v)∈ E continue
        BronKerbosch1(R ⋃ {v}, P ⋂ N(v), X ⋂ N(v))
        P := P \ {v}
        X := X ⋃ {v}
```

R表示当前在最大团的点集，P表示待选点集，X表示一定不选的点集

其中pivot为P中任意一个点，在加入点集的过程中只加入跟pivot没有边相连的点

加入之后，由于最大团中的点都是互相连边的，那么可以缩小枚举范围

并且有X的存在，保证了每一个团只会没枚举到1次

# 18.斯坦纳树

就是给定一张$n$个点$m$条边的无向图，需要把$k$个关键点联通的最小边权之和

最终的最优解一定是树，否则可以通过删去一条环上的边来得到更优的解

那么肯定是需要状压DP的，由于需要进行转移，那么需要先确定树上的一个根

设$dp(i,s)$表示当前以$i$​为根，s中关键点已经联通

转移分两种

- 将$i$的子树分开变成子问题$dp(i,t)+dp(i,s-t)\rightarrow dp(i,s)$

- 可能当前$i$的子树只有一个，那么需要走到一个新的根，等待一步的合并$dp(i,s)+w(i,j)\rightarrow dp(j,s)$

其中第二步转移需要用最短路进行更新

复杂度$O(n3^k,2^k(n+m)\log n)$

# 19.欧拉回路可以考虑dfs树

对于一个图来说，其欧拉子图的个数为$2^{n-m+c}$，c为联通块数量

# 20.Boruvka算法

考虑维护图中的联通块，如果只存在一个联通块那么就结束算法，否则每一轮就处理出来所有联通块连向其他联通块最小的边，然后将这些边加入到联通块之间，然后将联通块进行合并

形式化表述为

构造若干边集
$$
E_0\subseteq E_1\subseteq ...\subseteq E\\
E_0=\empty
$$
假设$E_{i-1}$已经计算好了，然后记$(V_1,...,V_t)$表示形成的联通块点集

然后对于所有点集$V_i$,找到一条边权最小的边$(x_i,y_i),x_i\in V_i,y_i\notin V_i$

然后我们令$E_i=E_{i-1}\cup\{e_1,...,e_t\}$即可

可以发现的是每一轮联通块个数都至少减半，那么说明进行的轮数为$O(\log n)$轮



可以用在类似完全图求最小生成树（完全图不是直接给出，往往是给定生成规则，然后需要用数据结构之类的求出两个联通块之间的最小边权）

例：[Problem - 888G - Codeforces](https://codeforces.com/problemset/problem/888/G)

# 21.构造二分图最小点覆盖

其中二分图最小点覆盖等于二分图最大匹配

至于构造就是从左侧所有的未匹配点出发，按照非匹配边，匹配边的顺序进行遍历点

对于左侧没有遍历到的点和右侧遍历到的点组成了一个最小覆盖点集

显然这个点集中都是匹配点
