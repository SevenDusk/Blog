#  25.进行$q$次区间修改

进行$q$次区间修改之后，如果原来的序列中的数都是相同的，那么序列就被划分成最多$2q$个本质不同的区间，这里本质不同是指被区间覆盖的情况不同

每一次加入某一个区间的时候，考虑其两个端点所在的区间，这个区间会被分裂成两个，那么每一次修改最多增加$2$个不同的区间，那么最后最多有$2q$个本质不同的区间

# 26.二进制分组

可以支持强制在线，并且复杂度优秀的技巧（常数略大）

考虑将所有修改操作按照二进制分组，就是将其分成$\log n$个块，对于每一个块内对询问的贡献用数据结构进行维护，每一次询问的时候在块内的数据结构上进行查询

在加入新的修改操作的时候，会合并某两个块，直接暴力合并即可，因为每一块内元素个数都是跟长度有关，复杂度为$O(f(n)\log n)$，$f(n)$为合并的复杂度

在实现的时候就是在线段树上实现，如果某一个节点的区间都加入过修改操作了， 那么将左右儿子的信息合并上来，作为一个新的块

如果询问所对应的修改操作是一个前缀的话，在合并左右儿子信息的时候，可以将左右儿子所用的空间回收

# 27.根号分治

相当于是拼接两种复杂度依赖不同的算法，然后通过调整阀值来平衡复杂度

# 28.整体二分/单调性分治

完了完了，整体二分都快忘了

就是对于所有询问都需要进行二分，但是每一次二分的代价都是$O(n\log n)$，那么考虑将所有询问放到一起进行处理

考虑分治结构，$solve(l,r,x,y)$表示区间在$[x,y]$的询问的答案在$[l,r]$范围，令$mid=\frac{l+r}{2}$，然后在$[x,y]$中找出答案比$mid$大的询问，和比$mid$小的询问，然后拆分成两段，类似归并的逆过程，然后递归下去

还有一种分治是单调性分治，就是要求一个序列$a$的答案，**这个序列具有单调性**，但是单独求一项的时间代价很高

考虑进行类似整体二分的分治，仍然考虑设分治函数$solve(l,r,x,y)$表区间$[x,y]$的答案在$[l,r]$范围内，令$mid=\frac{x+y}{2}$，处理出$a_{mid}$的答案，然后分治到$solve(l,a_{mid},x,mid-1),solve(a_{mid},r,mid+1,r)$形式类似的可以处理，单调增或者单调减的情况

# 29.带权并查集动态维护树上路径异或和

在每一个点上维护这个点到父亲的边的权值，每一次查询的过程中，在找根的过程中，将记录在每一个点的值异或起来

接下来考虑合并两个联通块，由于可能连边不一定是在两个根之间，而且在合并的时候只能将两个根连起来，那么考虑将边的两个端点到根路径上的异或值，异或上边权，然后将这条边看作两个根之间连边即可

并且可以支持栈序撤销

# 30.长链剖分$O(n\log n)-O(1)$求k级祖先

较为复杂，卡常用

首先根据长链剖分的性质，可以知道从某一个点向上跳$k$步，得到的点所处的长链长度一定$\geq k$

那么可以考虑对于每一条长链处理出，链顶向上链长度的祖先，这里可以记录在链的节点上，就不需要开vector

那么如果预先处理出$k$的最高位$d$，然后预处理出$d$级祖先，那么就可以在$d$级祖先的长链上$O(1)$查询出答案，那么只要先倍增预处理即可

预处理复杂度$O(n\log n)$，单次询问复杂度$O(1)$

# 31.替罪羊树

一个重要的思想就是，当子树不平衡的时候暴力重构，一般是当左右子树大小最大值超过总子树大小的0.7-0.8倍的时候将整颗子树的中序遍历求出，然后build出一颗平衡的子树

# 32.多叉表达式树

可以利用括号序给每一个运算符标记优先级关系，然后递归的进行建树

每一层提取出当前区间内优先级最小的数，然后将区间分成若干段，然后将这些段代表的节点接到当前节点下，就可以建出多叉表达式树

如果配合树上倍增，可以快速计算区间表达式求值

# 33.关于长链剖分记录数组以及输出方案的方法

首先将求出这个树的dfs序，这个dfs序一定要是优先枚举重儿子

那么对于$dp(x,i)$其中第二维的大小为x的最深深度$d(x)$，那么我们可以将其记录在$i\in[dfn(x),dfn(x)+d(x)-1],f(i)$中，在合并子树的时候，直接使用这个信息即可，可以发现的是这些位置都是在x的重儿子内，在合并子树的时候都是合并轻儿子，那么存储信息的位置并不会冲突

然后如果需要输出方案之类的，那么我们可以将更新信息记录在轻儿子上就可以了

这样就避免了复杂度多log的复杂操作

# 34.关于$\min(a_j,...,a_i)$的形式的DP优化

一般来说都是从小到大枚举$i$，然后利用这个式子进行计算DP的值，一种复杂的做法是用线段树维护这个值，会比较复杂

简单的做法就是维护一个从小到大单调栈，然后在后面加入一个新的元素的时候，可以合并栈顶的若干个元素，同时更新需要维护的DP值

这样的时间复杂度是$O(n)$也很好写

# 35.后缀max/min信息维护

假设现在需要维护一个区间中取到后缀min/max上的信息并，以max为例，就是只关心$a_i=\max(a_i,...,a_r)$这些位置上的信息并，就可以用这个技巧进行维护

可以用线段树进行维护，线段树节点上维护区间内$a_i$的最大值，还有所有取到后缀max位置上的信息并，考虑pushup的过程

首先当前节点一定是先直接继承右儿子的信息并，然后考虑左儿子的信息，相当于是在左儿子代表区间右侧加入了右儿子最大值的元素，那么我们可以递归的解决这个问题

那么需要解决的问题就是在当前节点代表区间右侧加入一个数求信息并

首先如果加入的数大于右儿子的最大值，那么说明右儿子是不存在贡献的，那么直接递归到左儿子求解即可

如果小于右儿子的最大值，那么左儿子的贡献不会受到影响，递归到右儿子求解即可

这样一次pushup的时间复杂度为$O(\log n)$

# 36.字符串最小可能后缀集合大小为$O(\log n)$

考虑证明，假设字符串为$s$，长度为$n$

现在考虑两个后缀$s[i...n],s[j...n],i<j$

首先如果$s[i...n],s[j...n]$已经可以比较出大小了，那么直接删除较小的那个即可

接下来考虑$s[j...n]$是$s[i...n]$一个前缀的情况，由于同时又是后缀，那么说明$s[j...n]$就是一个border，那么记$s[i...n]$的最小循环节为$T$，那么$s[i...n]=T^AC,s[j...n]=T^BC,A>B$

接下来考虑向后加入一个字符$q$

如果$q>T_{|C|+1}$，那么此时选择$s[i...n]$一定比$s[j...n]$更小

如果$q\leq T_{|C|+1}$，那么我们如果选择$C$这个后缀那么一定比$s[j...n]$更优

那么实际上我们并不需要保留$s[j...n]$这个后缀，由于我们选择$C$更优，那么也就是如果我们可以保留$s[j...n]$当且仅当$2(n-j+1)\leq n-i+1$

维护这个集合的时候我们从长度小开始不断加入，如果不满足上述条件，就弹出当前集合中长度最大的后缀即可

# 37.字符串的border集合可以划分成$O(\log n)$个等差数列

如果将一个字符串的border按照长度排序，那么就可以将其划分成$O(\log n)$个等差数列

一个引理：字符串$s$的所有长度不小于$\frac{|s|}{2}$的border长度组成一个等差数列

也就是说一个字符串划分出来的等差数列中，想要跳出某一个等差数列，那么一定是比这个等差数列中最长border长度一半短的

# 38.$|x-y|=\sum\limits_{k} [x\leq k\and y>k],x\leq y$

有了这个等式，那么在处理多个绝对值相加的时候，可以通过枚举$k$求出有多少个二元组$(x,y)$满足条件即可
