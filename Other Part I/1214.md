# CF1572F Stations

## 题目大意

现在有$n$个站，每一个站都有一个高度$h_i$，以及范围$w_i$

称$j$可以被$i$播报当且仅当

- $i\leq j\leq w_i$
- 对于任意$i<k\leq j$，满足$h_k<h_i$

一开始所有$h_i=0,w_i=i$

现在有$q$个操作，有以下两种类型

- 将$c$站的高度变成当且所有站中最高的，然后将$w_c=g$
- 假设$b_i$表示第i个站可以被播报的站的数量，求$\sum\limits_{i=l}^r b_i$

$$
n,q\leq 2\times 10^5
$$

## 算法讨论

如果设$s_i$表示$h_j>h_i,j>i$最小的$j$，如果不存在则为$n+1$

那么可以被$i$播报到的范围为$[i,\min(w_i,s_i)]$

那么由于每一次都是将当前的站变成最高的那个站，那么相当于将$[1,c)$的$s_i$与$c-1$取$\min$

其中将$w_i=g$直接单点修改就可以了

可以用吉司机线段树维护，在线段树中维护需要区间取min的数的最大值$MAX_0$和次大值$MAX_1$，以及这两个数出现次数

如果当前区间的$v\in (MAX_1,MAX_0)$，那么说明这个区间修改的位置只有$MAX_1$，那么打上标记修改即可

然后由于我们还需要维护$b_i$，而我们在修改的时候并不是显式将可以播报的范围进行修改，而是利用标记进行懒惰修改

那么显然不可能在同一个线段树上维护这个信息的区间和

那么我们可以新开一个线段树专门维护这个区间和，在修改$MAX_0$的时候，对于这些数来说消除的贡献是相同的，那么相当于在$(v,MAX_0]$的$b_i$，减去了$cnt_0$（最大值的个数），那么在这个时候可以在另一个线段树上进行修改

区间取min的线段树的复杂度用势能分析复杂度是$O(n\log n)$，然后套上另一个线段树

总时间复杂度$O(n\log ^2n)$

# CF1290E Cartesian Tree

## 题目大意

给定一个 $1\sim n$ 的排列 $a$ .

对于一个整数 $k\in[1,n]$ , 将排列中 $\leqslant k$ 的项构成的子序列建**大根笛卡尔树**. 这棵笛卡尔树的所有节点的子树大小之和记为 $s_k$ .

$\forall k\in[1,n]$ , 求 $s_k$.
$$
n\leq 150000
$$

## 算法讨论

首先对于一个$k$来说，一个节点的子树大小子序列中满足$\max(a_{l...r})=a_i$的最大区间长度

那么我们需要维护出来每一个位置的数左边第一个大于$a_i$的位置$p_i$，以及右边第一个大于$a_i$的位置$s_i$，然后求出这两个位置之间在子序列中的数出现次数

那么考虑不断向这个子序列加入最大的数$a_i$，那么相当于对于所有$j\in [1,i)$对于$s_j$和$i-1$取min，对于$j\in (i,n]$对于$s_j$和$i+1$取max

这个是区间取max和区间取min，可以用线段树进行维护，在线段树中同时维护每一个位置子树的大小之和，每一次加入一个新的数，其$p_i=1,s_i=n$，其子树大小为$i$

然后在取min/max的时候，一个位置的子树大小会发生改变

这里需要观察到当更新$s_j$的时候，对于更新$MAX_0$的时候修改变$v$，所有$cnt_0$等于$MAX_0$的位置，其数值是随着位置递减的，这是因为$MAX_0$一定$>$最右边$s_i=MAX_0$的位置，那么对于小于$<j$都必须要$a_j>a_i$否则$s_j=i$这是矛盾的

那么可以得出，假设$s_i=MAX_0$最大的i等于$L$，那么在区间$j\in [L,MAX_0]$中满足$a_j\leq a_i$而且对于所有的位置都满足，那么相当于这个贡献对于所有$s_i=MAX_0$的位置是等价的，而当前加入到子序列中的话，那么一定有$a_i\leq k$，那么需要减小的子树大小就是$ (v,MAX_0]$中$\leq k$的数个数乘上$cnt_0$，可以用可持久化线段树求出

那么我们可以维护在所有$s_i=MAX_0$中$a_i$的最小值，然后在pushdown的时候根据这个最小值更新子树大小和即可

需要分成两边进行维护

时间复杂度与上一题类似，为$O(n\log^2 n)$

# Feeling Good

## 题目大意

有一个$n \times m$的矩阵$M$，其元素值为0/1.

初始所有元素都是0

每次操作可以翻转第a行的第$i \in[l,r]$的所有元素$M[a][i]$

每次翻转结束后，输出一个矩形左上角为$(x_1,y_1)$右上角为$(x_2,y_2)$使得满足：

- $1 \leq x_1 < x_2 \leq n$, $1 \leq y_1 < y_2 \leq m$
- 矩形的四个角，同侧异色，对角同色。

如果没有任何矩形满足条件，则输出-1
$$
n,m\leq 2000,q\leq 5*10^5
$$

## 算法讨论

首先可以用bitset维护某一行的0/1序列$s_i$

然后至于一行的区间翻转，可以通过记录前缀和或者位运算在$O(\frac{n}{w})$的时间内解决

然后考虑如何输出答案

首先如果$s_i\& s_j=s_i$并且$|s_i|\leq |s_j|$那么显然$i,j$两行是不存在合法解的，因为除去相同的列，那么剩下列两行的01情况是相同的而我们要求是应该不同的

如果不满足这个条件那么就是合法的

然后考虑不合法的情况，需要满足什么条件

如果将所有$s_i$按照$|s_i|$进行排序，那么$s_i\subseteq s_{i+1}$

那么合法情况就是，一定存在$i$，满足$s_i\not \subseteq s_{i+1}$，那么$s_i,s_{i+1}$就一定存在合法情况

那么我们需要维护按照$|s_i|$进行排序的序列，那么可以用set进行维护，同时用另一个set维护合法的$i$位置

那么在更新某一行的时候，首先将其合法的位置在set中删去，然后在按照$|s_i|$排序set中删除，更新之后再加入即可，其中需要求出前驱后继，用set可以方便求出

时间复杂度$O(q\log q+\frac{qn}{w})$

