# 小H的旅行

## 题目大意

![20211223T1](D:\Blog\image\20211223T1.PNG)

## 算法讨论

首先需要将所有从某一个点出发的隧道和天桥找到其终点，对于$y_{i-1}<y_i$这条边上出发的是隧道，对于$y_{i-1}>y_i$出发的是天桥

对于一个隧道来说，需要找到第一个$y_i\leq z$的位置，对于一个天桥来说，需要找到第一个$y_i\geq z$的位置，那么我们就可以用单调栈进行维护，对于隧道的单调栈，按照栈顶纵坐标从大到小排序，天桥的就是相反的

我们对于每一个可能出发或者到达的某一条边的纵坐标都建立一个点，记录从出发点到当前这个点的最短时间

当现在的边是向上的，那么我们就更新天桥的那个单调栈，将终点在当前山坡上的天桥求出，然后将这些纵坐标跟当前边上的出发点一起处理，可以处理出来这些位置的时间，然后扫描一遍即可

对于隧道的那个单调栈来说也是同理的

但是需要注意的是，**出发点在端点上（左右两条边形成V字形），如果是隧道需要归到下一条边上**

时间复杂度$O(n)$

# 小 Y 的旅行

## 题目大意

![20211223T2](D:\Blog\image\20211223T2.PNG)

## 算法讨论

首先需要考虑每一条边的贡献，对于左右两个子树来说，选择的特殊点分别有$x,y$个，其中$x+y=k$

那么这条边在最好情况下是贡献了$2\min(x,y)$次，显然这个上界是可以达到的

那么我们可以设$dp(x,i)$表示$x$子树内存在$i$个特殊点的情况下最大的路程贡献和

转移就是
$$
dp'(x,i+j)=\max dp(x,i)+dp(u,j)+2w_{x\rightarrow u} \min(j,k-j)
$$
其中如果将$g(x,i)=dp(x,i)+2w_{x}\min(i,k-i)$的话

那么
$$
dp'(x,i+j)=\max dp(x,i)+g(u,j)
$$
这个是一个max +卷积，难以进行优化，那么需要找dp本身的性质

可以发现的是，对于$2w_x\min(i,k-i)$这个关于i的函数来说，一定是一个凸函数，那么如果$dp(x)$关于i也是一个凸函数，那么$g(x)$也是一个凸函数

那么剩下的就是max +对于两个凸函数是否可以得到一个凸函数

根据闵可夫斯基和的定义可以知道，如果将DP的第二维看作横坐标，数值看作纵坐标，那么max +卷积就是在做闵可夫斯基和

那么根据闵可夫斯基和的计算过程，我们需要对凸包上所有的向量进行极角排序，然后将左下角加起来，然后按照这个顺序走向量

那么我们可以维护DP数组的差分数组，然后对于向量排序，相当于就是对于差分的数值进行排序，而$dp(x,0)=0$，那么不用单独维护一个左下角的数值

每一次加入价值函数的时候，相当于是将前$\lfloor \frac{k}{2}\rfloor $个差分数值加上$2w$，后$\lfloor \frac{k}{2}\rfloor$减去$2w$，中间会有$k\bmod 2$个位置不变

这个处理的方法有两个

- 一个是用平衡树维护整个差分序列，然后可以支持区间加操作，然后合并的时候复杂度可以做到$O(m\log \frac{n}{m})$，最终的复杂度是$O(n\log n)$
- 也可以将整个差分序列分成三段，每一段用一个堆进行维护，那么加入价值函数的时候，就是全局加。合并的时候，将三段单独进行合并即可（这里可能会存在对于顺序的疑惑，就是可能合并到第二段的数最终排在第一段，事实上是不存在这种情况的，就是如果当前第二段存在数，那么说明最终合并的结果中至少有$\frac{k}{2}$个数比其小，那么其排名不可能在第一段中）
- 这里实现的方法可以用二叉堆暴力启发式合并复杂度$O(n\log ^2n)$，左偏树/其他可并堆，复杂度$O(n\log n)$，前者会被卡掉

# 小H做算术

## 题目大意

![20211223T3](D:\Blog\image\20211223T3.PNG)

## 算法讨论

首先生成子群相当于对于初始集合不断进行求逆，取出两个进行乘除法最终得到的运算封闭的集合加上运算符

那么在乘法群的意义下很难看出大小，由于给出的模数是质数，那么$[1,p-1]$中每一个数都可以用原根的若干次表示处理，进行两个数的乘法相当于在模p-1意义下进行加法，那么就将乘法群转化为了加法群，假设$a_x=w^k$，记作$b_x=k$

对于初始集合中所有数来说，假设这些数与p-1的gcd为g，那么无论进行加法还是减法操作，得到的结果一定都是g的倍数，那么其生成子群的大小就是$\frac{p-1}{g}$

那么问题就变成了求出这个集合中所有$b_x$与p-1的gcd，但是求出$b_x$只能用bsgs求出，时间复杂度是$O(\sqrt n)$的，在这样的时间限制下，需要大量卡常才能通过，考虑一个更简单的做法

就是由于最终求得结果是对于p-1的gcd，那么我们不必求出具体的$b_x$，我们只需要求出$c_x=\gcd(b_x,p-1)$即可，求答案的时候求$c_x$的gcd和求$b_x$的gcd结果是一样的

对于一个数$a_x$来说，其最小的$s$，满足$a_x^s\equiv 1 (\bmod p)$，那么s是等于$\frac{p-1}{\gcd (b_x,p-1)}$的，相当于在加法群下的最小公倍数

那么我们可以像求原根的那样求出$\gcd(b_x,p-1)$，首先我们令$y=p-1$，那么显然$a_x^{y}\equiv 1$，然后枚举p-1的所有质因数$d$，令$y'=y/d$，如果$a_x^{y'}\equiv 1$，那么$y=y'$，否则不变

那么最终我们求出的$y=s$，那么$\gcd(b_x,p-1)=\frac{p-1}{y}$，计算一次的时间复杂度$O(\log ^2p)$

然后回到原来的问题上，由于我们需要支持区间乘上某一个数，而我们无法快速重新计算某一个区间内的$c_x$或者$b_x$

那么我们需要对于计算的最终式子进行再一步修改

我们现在得到的计算式子为$g=\gcd(b_L,...,b_R,p-1)$，那么我们将其差分得到的结构就是$g=\gcd(b_L,b_{L+1}-b_{L},...,b_R-b_{R-1},p-1)$，然后按照之前的做法$g=\gcd(\gcd(b_L,p-1),\gcd(b_{L+1}-b_L,p-1)....)$

那么我们在线段树中维护每一个$\gcd(b_{i+1}-b_i,p-1)$，在线段树中叶子节点求出的方法就是对于$\frac{a_{i+1}}{a_i}$求出对应的值即可

修改只需要单点修改即可，询问区间gcd

时间复杂度$O((n+q)(\log ^2n+\log ^2p))$

