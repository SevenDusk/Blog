# Optimal Insertion

## 题目大意

给定两个序列$a,b$，要求将b中每一个元素插入到a中，求最小可以得到的逆序对数

## 算法讨论

首先需要知道一个结论，就是$b$中在$a$中的相对顺序是升序的，并且插入的位置是在所有位置中产生新的逆序对数最小的那个位置，可以发现的是对于插入的数来说，随着插入的数大小增加，这个位置也是随之增加的

那么说明就是符合这个b升序排列的条件

那么答案就是原来a中的逆序对数+a,b直接新增的逆序对数

### Solution 1

x插入一个位置产生的逆序对，就是这个位置之前$>x$的数个数+这个位置之后$<x$的位置

那么我们从小到大枚举x，用线段树维护每一个位置的贡献，当$x$增加1的时候，需要找到$x+1$出现的所有位置，然后将这些位置的后缀-1，然后将所有x出现的位置的前缀+1

然后需要维护最小值

### Solution 2

由于随着$x$增加，插入的位置单调，那么就可以直接决策单调分治，就是分治函数记录两个区间，$[l,r]$表示插入的数的区间的最优插入位置都在$[L,R]$中

然后计算出中间那个最优位置在哪里，然后左右两边分治

时间复杂度$O(n\log n)$

https://codeforces.com/contest/1601/submission/133003047

### Solution 3

考虑将这个过程倒过来，就是考虑将$A$插入到$B$中，由于B是有序的，依次插入A，设$dp(i,j)$表示当前考虑到A中第i个位置，当前$A_i$插入的位置为$j$

可以发现转移的价值函数是一个绝对值函数，并且带有区间min，那么看作关于j的函数，那么一定是一个凸包

那么可以通过用两个优先队列来维护凸包中的每一个顶点，也可以直接二分

https://codeforces.com/contest/1601/submission/132999482

# Difficult Mountain

## 算法讨论

现在有一个数d，有n个二元组$(s_i,a_i)$，每一次可以选出一个二元组$(s_i,a_i)$满足$s_i\geq d$，然后将$d$设为$\max(d,a_i)$

求最多可以进行多少次操作

## 算法讨论

### Solution 1

首先这个数可能的取值只会在$d$和$a_i$中取

我们可以将所有二元组按照$a$的顺序进行升序排序，如果$a_i\leq d$只要$s_i\geq d$那么就一定可以产生贡献，这里可以发现如果我们当前数为某一个定值的时候，$a_i$较小的位置，我们只需要判断s是否合法即可

那么我们可以用DP进行统计，设$dp(i)$表示当前数的值为$a_i$的时候最大可能操作数，考虑转移到$j,j\geq i$，需要注意的是i，j需要满足$s_j\geq a_i$

那么$(i,j)$中的二元组会在这个数变成$a_j$，之后使用到，那么相当于我们在这个区间询问有多少$s_k\geq a_j$，假设$cnt$个，那么$dp(i)+cnt\rightarrow dp(j)$

直接转移时间复杂度$O(n^2)$

考虑如何快速转移，如果我们可以处理出来$\geq a_i$的s数量前缀和$sum_{a_i}(x)$，那么我们就只需要记录一个前缀min即可，就是$dp(k)-sum_{a_i}(k)$的前缀最小值

注意到我们一开始将$a_i$升序排序，如果我们用线段树/树状数组维护$sum_{a_i}(x)$我们只需要支持后缀减即可

那么再用线段树维护$dp(k)-sum_{a_i}(k)$的最小值

### Solution 2

首先将所有的$s_i<d$去掉

考虑将所有二元组分成两种，一种$a_i<s_i$另外一种$a_i>s_i$，分别称为类型$1,2$

可以发现如果我们选择了$a_i>s_i$的话，当前的数一定会发生变化

如果我们将一个操作看作区间$[\min(a_i,s_i),\max(a_i,s_i)]$的话，如果一个2类型的区间包含了一个1类型的区间，我们一定可以通过替换，将这个第2类型的区间变成第1类型的区间

那么我们将所有包含了1类型区间的2类型区间去除

那就转化为了一个区间不交问题，直接贪心或者DP即可

https://codeforces.com/contest/1601/submission/133003986

# Phys Ed Online

## 题目大意

现在每一个天都有一个购买票的价格$a_i$，购买一张票，如果被激活了，那么这张牌可以连续用k天，给出q个询问，每一个询问给出一个区间$[l,r]$，表示如果一个人$[l,r]$都会需要用票，求最小的代价

## 算法讨论

显然题目所求就是$[l,r]$每k个分一段的前缀最小值和
$$
\sum\limits_{l+kx\leq r} \min \limits_{i=l} ^{l+kx} a_i 
$$
显然对于同一个询问我们需要求的前缀最小值都是模$k$相同的

那么考虑将所有询问离线，然后对于每一种模$k$相同的位置进行考虑

假设当前枚举组都是模$k$等于$p$的位置，那么需要将所有这些位置提出，但同时将两个位置之间区间的最小值求出，也放到数组里面

那么这样数组的长度最多$\times 2$，复杂度仍然正确，如果只考虑这个数组，那么问题就变成了$k=2$的情况，其中$k=1$的时候需要特殊判断一下

那么对于提出来的数组进行考虑，相当于一个区间内所有奇数位置都会产生贡献

我们从后往前扫描，维护一个单调栈，用线段树维护每一个位置的前缀min，然后每一次加入一个元素之后，将当前位置到单调栈上一个元素位置之前的前缀min都赋为当前这个位置的数

那么我们只需要对于所有奇数位置区间查询即可

### Solution 2

可以不同线段树，在维护单调栈的同时，维护一个前缀和，然后区间查询的时候在单调栈中二分找到位置，用前缀和算出答案即可

好像还可以用并查集进一步优化

