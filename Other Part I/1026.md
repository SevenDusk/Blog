# Number of Parallelograms

## 题目大意

给定n个点，求形成多少个平行四边形
$$
n\leq 2000
$$

## 算法讨论

首先枚举两个点，然后计算其向量差，找到共线并且**长度相同**的向量即可

用map存即可

# Different Subsets For All Tuples

## 题目大意

有一个长度为$n$的数列，每个位置上数字的值在[1,m]范围内，则共有$m^n$种可能的数列。分别求出每个数列中本质不同的子序列个数（包含空序列），然后求和，答案对$10^9+7$取模（$1≤n,m≤10^6$）

## 算法讨论

首先对于所有子序列，求出有多少个序列出现过这个子序列

会发现两个子序列如果长度相同其本质是相同的，就是出现的序列个数相同

设$f(i,j)$表示当前匹配到第i个位置，子序列匹配到第j个位置的方案数
$$
f(i,j)=f(i-1,j-1)+(m-1)f(i-1,j)
$$
可以简单得出$f(n,i)=\binom{n}{i}(m-1)^{n-i}$

那么最终答案就是
$$
\sum\limits_{i=0}^m m^i(m^n-f(n,i))
$$

# Bear and Bowling 4

## 题目大意

给定一个序列，求出一个子序列，$a_1,a_2,...,a_m$

最大化$\sum\limits_{i=1}^m i\times a_i$

## 算法讨论

首先记$A_i=\sum\limits_{j=1}^i j\times a_j ,B_i=\sum\limits_{j=1}^i a_j$

那么一段区间的答案就是
$$
A_r+B_r-lB_r-A_{l-1}-(1-l)B_{l-1}
$$
那么对于一个固定的l，需要最大化$A_r+B_r-lB_r$

那么就以$(B_r,A_r+B_r)$作为点，求出上凸包即可

需要动态插入点，用set进行维护，**需要注意一下叉积判断的时候正负性，维护的是上凸包**

# Simple Subset

## 题目大意

给定一个序列，求出其中一个子集，使得子集中任意两个元素之和为质数

## 算法讨论

首先集合中不为1的个数不能超过两个，否则就会产生奇偶相同的数，其和为偶数，不为质数

那么将所有1求出，然后尽量加入1个其他元素，并且这个元素+1为质数

然后与是否能选出两个元素取集合最大的那个

# Beautiful Subarrays

## 题目大意

给定一个序列$a$，求出有多少个区间的xor大于等于k

## 算法讨论

首先枚举区间内的xor和在哪一位比k大，假设为第i位，其中k的第i位为0，那么说明前i位的xor和确定，后面的任意

那么相当于确定一个区间的xor和为多少，这个是方便计算，只需要记录xor前缀和，然后用hash表记录每一个数出现的次数即可

**需要手写hash表，直接用unordered_map速度不够**

# Four Divisors

## 题目大意

求出n以内的数只有4个因数的数个数
$$
n\leq 10^{11}
$$


## 算法讨论

只有四种因数的数，有两种形式，一种是由两个质数相乘得到，另外一种是某一个质数的三次方

其中第二种情况很好处理，直接枚举即可

然后考虑第一种情况，假设$k=p_1p_2$

可以发现$\min(p_1,p_2)\leq \sqrt n$

那么我们可以枚举这个最小值p，那么剩下的问题就是解决$1$到$\frac{n}{p}$中有多少个质数的问题，这是一个经典问题，可以用洲阁筛或者min25筛解决

当然需要设一个阈值，前面的用线性筛预处理，后面使用洲阁筛或者min25筛

# Iterated Linear Function

## 题目大意

设$f(x)=Ax+B,g^{(n)}(x)=f(g^{(n-1)}(x))$

求$g^{(n)}(x)\bmod 10^9+7$

## 算法讨论

手动展开几项可以发现
$$
g^{(n)}(x)=A^n x+B(A^{n-1}+A^{n-2}+...+A+1)=A^nx+B\frac{A^n-1}{A-1}
$$
需要注意的是，**如果$A=1$是不满足等比数列求和公式的，需要特殊处理**

# Another Sith Tournament

## 题目大意

你是一位骑士，与其他n-1个骑士决斗

幸运的是你知道任意骑士i击败骑士j的概率，你还被推选为组织委员。决斗一开始你需要任意选择两名骑士（包括自己）进行决斗，胜利方继续和你另外选择的一名骑士决斗，直到仅剩一人

你非常渴望取得胜利，想知道自己获胜最大概率是多少，注意你是1号。
$$
n\leq 18
$$


## 算法讨论

考虑进行状压DP，由于我们计算的最大获胜概率，就需要从后往前进行DP，**相当于一个DP状态是由之后的状态转移而来**

设$dp(mask,i)$表示当前已经比赛过的骑士集合为mask，当前留下的骑士为i状态之后1号获胜的最大概率
$$
dp(mask,i)=\max\limits_{j\notin mask} p_{i,j}dp(mask\cup \{j\},i)+p_{j,i}dp(mask\cup \{j\},j)
$$
初始状态为$dp(full,0)=1$

答案就是$\max dp(0,i)$

# Lena and Queries

## 题目大意

![20211026](D:\Blog\image\20211026.PNG)

## 算法讨论

首先所有修改操作都是对一段时间区间有影响

那么就可以考虑线段树分治，将所有要加的点加入到线段树上，然后在线段树上遍历的过程中维护一个凸包，然后到查询叶子节点的时候在凸包上二分即可

**需要注意将点加入凸包时候叉积的正负性，还有栈序撤销，一种方便的写法就是每一个都存一个副本，然后当dfs完一个儿子节点的时候，将当前的凸包替换成副本，但空间复杂度就变成了$O(n\log n)$**

时间复杂度$O(n\log ^2 n)$

# Swaps in Permutation

## 题目大意

给定一个排列p，和m对二元组$(a,b)$，每一个次可以选择一个二元组$(a,b)$，然后交换$p_a,p_b$

求可以得到字典序最大的排列

## 算法讨论

对于每一个位置建点，二元组之间建边

那么对于同一个联通块的点，上面的数都是可以任意排列的，那么只需要将原来上面的数降序排序即可

# Xor-sequences

## 题目大意

给定一个数集A，现在你需要构造一个长度为k的序列B，序列B的元素从数集A中任意挑选，要求B中任意相邻的两个数字的异或值二进制表示中1的个数是3的倍数，请问B的有多少种合法的构造方案？两种方案不同当且仅当存在Bi在A中的位置不同。
$$
n\leq 100
$$

## 算法讨论

考虑暴力的做法

每一次确定了一位之后，可以枚举下一位填什么，然后进行转移

显然每一个都是等价的，那么可以用矩阵进行优化

$O(n^2)$枚举两个相邻的数，看其异或和是否合法，如果合法，那么设为1

最初矩阵第一行为1即可

时间复杂度$O(n^3 \log k)$

# Road to Post Office

## 题目大意

Vasiliy 要从家到 d 千米远的警察局去，Vasiliy 有一辆车，但很破旧，每行驶 k 千米就要坏掉，需修复 t 秒才能重新启动，已知 Vasiliy 开车开 1 千米要 a 秒， 步行 1km要 b 秒（a < b）, Vasiliy 可以在任何一个时刻步行，请问 Vasiliy 最少要多少秒才能到达警察局。

## 算法讨论

假设开了x段，代价函数就是
$$
f(x)=\min(d,xk)a+\max(0,x-1)t+\max(d-xk,0)b
$$
显然去掉min,max就是一次函数，所以极值只会在$0,1,\lfloor \frac{d}{k}\rfloor,\lceil \frac{d}{k} \rceil$上取到

**一开始没有注意到min,max，wa了一次**

# Analysis of Pathes in Functional Graph

## 题目大意

有一个n个点n条边的带权有向图（点编号0~n-1），每个点有且仅有一条出边，对于每个点i求出由i出发经过k条边，这k条边的权值最小值和权值和。

## 算法讨论

直接倍增即可

# T-Shirts

## 题目大意

![20211026T2](D:\Blog\image\20211026T2.PNG)

## 算法讨论

首先将所有 T恤排序，然后对于所有的询问统一进行处理，显然单条进行处理没有什么优化的空间，那么就需要用一个可以支持快速区间操作的数据结构进行维护

我们需要用平衡树进行维护，以$v_i$作为关键字进行建树

当前的T恤价格为c的话，那么对于所有$v_i\geq c$的人，需要将$v_i-c$，然后计数器+1

由于$v_i-c$会破坏之间的相当大小关系，那么不能直接打标记

考虑只有$v_i\in [c,2c)$的人才会被破坏大小关系，注意到减c之后，$v_i$变小了至少一半，**那么说明在整个过程中$v_i\in [c,2c)$个数和不会超过$O(n\log n)$个**

那么我们可以将这一段区间的人，暴力从树中删除，然后将$v_i$减去c，然后再插入到平衡树中

而至于$v_i\in [2c,\infin)$的树，不会破坏相当于大小关系在，直接打标记修改即可

需要注意splay可能不支持树中存在两个权值相同的元素，但是一旦两个元素相同了，那么其之后的决策都是相同的，那么可以用带权并查集进行维护这个关系

时间复杂度$O(n\log ^2 n)$

### Solution 2

我们可以对于每一个顾客的钱数在值域上分成$\log V$个块，对于一个钱数为x的人，讲其放到编号为$\log x$的块内，然后对于每一个块都维护当前在这个块中的顾客集合以及钱数，还有一个全局加标记

对于当一个T恤的价格$c$，讨论一下有哪些人会走到下一个格子中，然后讲这些人暴力取出，然后插入到下一个块中

那么我们可以对于每一个块维护一个set实现即可，就不需要手写平衡树

# Two Arithmetic Progressions

## 题目大意

You are given two arithmetic progressions: *a*1*k* + *b*1 and *a*2*l* + *b*2. Find the number of integers *x* such that *L* ≤ *x* ≤ *R* and *x* = *a*1*k*' + *b*1 = *a*2*l*' + *b*2, for some integers *k*', *l*' ≥ 0.

## 算法讨论

首先列出等式
$$
a_1x+b_1=a_2y+b_2\\
a_1x-a_2y=b_2-b_1
$$
然后利用扩展欧几里得计算出一组特殊解

然后求出一组非负整数解，然后求出在范围内的数个数

# Generate a String

## 题目大意

![20211026T3](D:\Blog\image\20211026T3.PNG)

## 算法讨论

首先需要发现，由于我们可以删除字符，在获得特定长度的时候，可能需要先倍长，然后删除一个字符

可以发现的是，如果我们需要删除字符，那么最多只会连续删除一次

否则我们就可以将删除操作放到倍长操作之间，可以减少一次操作

那么设$f(n)$表示得到长度为n的字符串最小代价
$$
f(n)=\min(f(n-1),f(n/2)+x),\ n\bmod 2\equiv 0\\
f(n)=\min(f(n-1),f(n/2+1)+x+y),\ n\bmod 2 \equiv 1
$$

# String Set Queries

## 题目大意

![20211026T4](D:\Blog\image\20211026T4.PNG)

## 算法讨论

考虑进行二进制分组

我们可以对于这个字符串集合用线段树（一开始的大小就是$3*10^5$）进行维护，当加入一个字符串的时候，增加一个下标，然后在这位置上插入字符串

在线段树上的每一个节点上都维护当前区间有哪些字符串，一旦当前节点插入满之后，就将当前所有字符串建立AC自动机

那么查询就是相当于查询一个区间，当在一个AC自动机上查询出现的次数

需要注意的是如果一个节点插入满之后，需要将两个子节点的AC自动机清空，

时间复杂度$O(n\log n)$

### Solution 2

考虑进行根号分治，

对于集合中长度$\leq \sqrt n$的串，插入到Trie中，如果是加入，那么在最末尾的那个元素上+1,否则删除的话就是-1，当查询的时候枚举查询串的所有后缀，在Trie中匹配，每一次到一个新的节点的时候，就加上这个节点的权值即可，然后一旦访问到空节点，就退出循环，由于Trie的深度最大为$\sqrt n$，所以复杂度为$|S|\sqrt n$

然后对于$>\sqrt n$的串，预处理出来其kmp的前缀函数，然后当查询的时候暴力匹配即可，由于这样的串个数$\leq \sqrt n$，查询的复杂度也是$|S|\sqrt n$

那么总复杂度$O(n\sqrt n)$
