# Connecting Vertices

## 题目大意

![20211108T](D:\Blog\image\20211108T.PNG)

## 算法讨论

首先将环破成链，那么两个线段合法的条件就是在数轴上不是相交

那么相当于问题就变成有多少种方案在任意两个点连n-1条边使得图联通，并且两两不相交

设$dp(i,j)$表示区间的答案

那么枚举i连向的位置k，对于$[i,k]$中间的数需要用另一个DP枚举从哪个位置分开使得前缀与i相邻，后缀与k相邻

假设记作$f(i,k)$
$$
dp(i,j)=f(i,k)\times dp(k,j)
$$
时间复杂度$O(n^3)$

# Xor-MST

## 题目大意

给定一个完全图，i与j的边权为$a_i$异或$a_j$，求最小生成树

## 算法讨论

首先将所有数加入到Trie中

我们每一次需要找到两个还不在同一个联通块的节点之间最小的边，那么显然两个节点在trie上的LCA位置开始

由于trie相当于每一次将某一位上0，1集合分开，那么所有两两节点之间的LCA只有n-1个，恰好对应了MST中n-1条边

那么只需要在每一个可能的LCA中查询左右子树的异或最小值即可，我们枚举子树大小较小的那个子树，然后在另一个子树查询即可，这样就是启发式合并的复杂度

时间复杂度$O(n\log ^2n)$

# Credit Card

## 题目大意

Recenlty Luba有一张信用卡可用，一开始金额为0，每天早上可以去充任意数量的钱。到了晚上，银行会对信用卡进行一次操作，操作有三种操作。 1.如果a[i]>0，银行会给卡充入a[i]元。 2.如果a[i]<0 银行从卡中扣除a[i]元。 3.如果a[i]=0 银行会查询卡里的金额。 有两条规则，如果违背信用卡就会被冻结。 1.信用卡里的金额不能大于d。 2.当银行查询卡里的金额时，金额不能为负。 Recenlty Luba想知道最少去充多少次钱，可以使她在接下来的n天里信用卡不被冻结。

## 算法讨论

从前往后进行枚举，同时维护当前卡内最多可以存在的钱MAX和最小可以存在的钱MIN

对于$a_i=0$的情况来说，如果$MAX\geq 0$，那么令MIN与0取max，否则答案加1，将MAX设为d，MIN设为0

对于$a_i\neq 0$的情况，$MAX+a_i,MIN+a_i$，如果$MIN>d$，那么不合法，然后令MAX与d取min即可

最终输出答案

# Counting Arrays

## 题目大意

对于每组数据，给出x和y，求一个长度为y的序列，其乘积为x，允许有负数，求这种序列的个数，对1e9+7取模

## 算法讨论

首先将x进行质因数分解$x=p_1^{r_1}p_2^{r_2}...p_k^{r_k}$

对于每一个质因数进行考虑，对于一个质因数可以放到任意的盒子中
$$
\prod\limits_{i=1}^k \binom{y+r_i-1}{y}
$$
然后考虑正负号的问题，乘上$2^{y-1}$即可

# Subtree Minimum Query

## 题目大意

![20211108T2](D:\Blog\image\20211108T2.PNG)

## 算法讨论

首先将数的dfs序求出

那么每一次询问都是询问区间内小于等于d的最小值

那么我们可以用线段树进行维护，每一个节点都是区间内的所有数，并且按照权值排序，预处理前缀min，区间查询的时候，到达被查询区间完全包含的节点时候二分出对应位置，然后取前缀min即可

d等于查询的节点深度+k

# Swapping Characters

## 题目大意

给你 k个串，每个串长度都是 n，现在问你是否可能这些串是同一个串交换两个位置的字符所产生的，输出这个原串。

## 算法讨论

首先需要预处理出来1号串和其他串不同的位置，如果不同位置大于4，那么一定不合法

然后我们枚举1号串是交换哪两个位置，然后用得到的串去匹配后面的串，同样需要求出有哪些位置不同，显然就是预处理出来的位置加上交换的两个位置，才有可能不同

如果不同的位置>2也是不合法的，对于没有不同的位置来说，必须串中至少存在两个相同字符才可能成立

# Clear The Matrix

## 题目大意

给定一个4×n的元素只为'*'或'.'的矩阵f

你可以不断地选择一个f的子方阵,并将方阵的元素都变为'.'

选择一个k×k的方阵需要代价$a_k$。

问最少要多少代价,才能将所有元素都变为'.'

## 算法讨论

考虑将一列之前的4*4的矩形进行状压，状压的状态就是是否还是X，那么像轮廓线DP一样进行转移，枚举下一个格子，然后我们枚举这个格子替代的格子作为子矩阵左上角的长度

然后对于状压状态进行更新即可

需要注意的是在换新的一列的时候，需要重新对于这个状压的矩形进行标号

# Yet Another Maxflow Problem

## 题目大意

![20211108T3](D:\Blog\image\20211108T3.PNG)

## 算法讨论

首先最大流等于最小割，那么相当于我们要在图中删除若干边使得$A_1,B_n$不连通

首先A,B中最多只会删除一条边（显然，如果有两条边去掉其中靠后的边显然不影响）

假设是$x,y$

那么对于A,B之间的边$(i,j)$，如果$i\leq x,j\geq y$，那么$(i,j)$一定需要被删除，那么我们固定x，用线段树维护$y$的序列，然后对于所有起点在$x$的A,B之间的边，假设终点为j，那么相当于就是将j的前缀+边权

然后维护全局最小值即可

至于修改，由于只会修改A中的边，那么可以将预处理的答案存入数组，相当于单点修改数组中的某一位，然后求最小值，可以用set实现

# Stack Sorting

## 题目大意

给你一排列的一部分,让你补全整个排列使其字典序最大并且经过一个栈调整顺序之后能够顺序输出

## 算法讨论

首先将已经给出的部分加入栈中，然后同时如何栈顶元素可以弹出，那么尽量弹出

得到剩下的栈来说，栈顶元素肯定大于下一个需要弹出的元素，那么其中的数不能在前面出现过，否则就是不合法情况，然后将其中的数从大到小输出，然后弹出栈顶元素，将下一个需要弹出的元素设为栈顶元素+1，然后继续递归考虑即可

# Tree Destruction

## 题目大意

给你一棵树,每次挑选这棵树的两个叶子,加上他们之间的边数(距离),然后将其中一个点去掉,问你边数(距离)之和最大可以是多少.

## 算法讨论

首先一个点到另一个点的最大值是到两个直径端点

那么先预处理出来直径的两个端点，对于不在直径上的点，求出到两个直径的最大值，然后删除这个节点即可

然后对于直径上的点就是按照顺序删除即可

# Mass Change Queries

## 题目大意

给出一个数列,有q个操作,每种操作是把区间[l,r]中等于x的数改成y.输出q步操作完的数列.

## 算法讨论

考虑用线段树进行维护，每一个线段树节点都维护一个tag，表示每一个颜色经过修改之后会变成什么颜色，由于函数复合是满足结合律的，那么我们可以用tag进行延时下传

时间复杂度$O(n\log n 100)$

### Solution 2

考虑进行分块，对于每一个块每一个颜色都用一个list维护一个下标序列

对于修改，先考虑整块的修改

就是我们要将其中一个颜色的list拼接到另一个颜色的list中去即可，这个可以使用splice进行$O(1)$实现（就可以替代vector的启发式合并，时间复杂度少了一个log）

然后考虑对于散块的修改，那么直接在对应颜色x中找到在修改区间内的位置，暴力插入到y颜色对应的list中即可

时间复杂度$O(n\sqrt n)$

![20211108T8](D:\Blog\image\20211108T8.PNG)

# Physical Education Lessons

## 题目大意

![20211108T4](D:\Blog\image\20211108T4.PNG)

## 算法讨论

相当于我们需要支持区间赋值操作和区间和

直接用线段树维护即可

# Imbalance Value of a Tree

## 题目大意

![20211108T5](D:\Blog\image\20211108T5.PNG)

## 算法讨论

求出所有路径上的最大值-所有路径上的最小值就是答案

考虑将所有节点按照a从小到大排序

依次加入节点，然后用并查集维护联通块，那么当一个节点连接两个联通块的时候，所有路径节点分别在这两个联通块的路径中的最大值就是这个节点的权值

# Coprime Arrays

## 题目大意

![20211108T6](D:\Blog\image\20211108T6.PNG)

## 算法讨论

考虑进行莫比乌斯反演

对于长度为n，元素上限为i的答案为
$$
\sum\limits_{d\leq 1} \mu(d)(\lfloor \frac{i}{d}\rfloor )^n
$$
那么我们枚举d，然后在所有$i/d$相同的区间进行差分即可

时间复杂度$O(k\log k)$

