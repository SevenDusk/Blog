# **ABC157F Yakiniku Optimization Problem**

## 题目大意

给定平面上n个点$(x_i,y_i)$，假设选择了$(X,Y)$

那么求出$n$个点中
$$
c_i \sqrt {(X-x_i)^2+(Y-y_i)^2} 
$$
在第k小的值的最小值
$$
n\leq 60
$$

## 算法讨论

首先考虑二分答案$t$

那么可以发现对于第i个点，来说如果$(X,Y)$到$(x_i,y_i)$的距离$\leq \frac{t}{c_i}$的话，那么其距离就是$\leq t$的

那么相当于将$(x_i,y_i)$作为圆心，$\frac{t}{c_i}$作为半径做一个圆

那么如果存在某一个点被至少$k$个圆覆盖，那么说明答案$\leq t$

可以发现的是对于任意多个圆的交集来说，一定存在某一个点是属于其中两个圆的交点

那么也就是说如果检查所有圆的交点的话，那么就可以将最优情况包含在内

那么我们枚举两个圆，然后求出其交点，然后在判断被几个圆所有覆盖即可

时间复杂度$O(n^3\log V)$

**全部使用了long double速度太慢TLE了，改成double就可以了**

# ABC129F **Takahashi's Basics in Education and Learning**

## 题目大意

给定一个序列$s_0,...,s_{L-1}$，其中$s_i=A+iB$，求将这个数列按照顺序拼接起来的数，模m等于多少

保证$s_{L-1}\leq 10^{18}$
$$
L,A,B\leq 10^{18},m\leq 10^9
$$

## 算法讨论

首先我们需要知道每一个数的数位个数

由于数列中最大的数不会超过$10^{18}$，那么我们可以对于每一个数位个数求出其边界

假设当前有n位数
$$
10^{n-1}\leq A+Bi\leq 10^n-1 
$$
然后求出i的范围$[l_n,r_n]$即可

那么对于同一位数来说，化简用等比数列求和是走不通的，题目没有保证$m$是指数，分母上的数在模m意义下可能不存在逆元

那么就需要用一个只含加减乘的运算的算法进行运算，那么可以用矩阵乘法进行计算

假设当前位数为$n$
$$
\begin{bmatrix}
F & x &1 
\end{bmatrix}
\times 
\begin{bmatrix}
10^n & 0 & 0 \\ 
1 & 1 & 0\\ 
0 & B & 1
\end{bmatrix}
$$
其中$F$表示当前拼接形成数模m的答案，x为当前数列中的数

那么对于一个n可以矩阵快速幂快速求出答案

时间复杂度$O(\log ^2n)$

# ABC134F **Permutation Oddness**

## 题目大意

定义一个排列的oddness为$\sum |i-p_i|$

对于求出有多少个n个数的排列满足其oddness为k
$$
n\leq 50
$$

## 算法讨论

首先可以将其看作二分图匹配的模型，oddness就是表示匹配中相连的两个节点编号的绝对值

考虑设$dp(i,j,k)$表示当前考虑到左右两边节点的前i个节点，其中$[1,i]$中还各有$j$个没有匹配，当前oddness为k的方案数

如果将左右两边的$i+1$都和$[1,i]$中没有匹配的节点进行匹配那么有转移$j^2\times dp(i,j,k)\rightarrow dp(i+1,j-1,k+2(j-1))$

如果左右两边的$i+1$目前都不匹配那么有$dp(i,j,k)\rightarrow dp(i+1,j+1,k+2(j+1))$

如果左右两边的i+1互相匹配那么有$dp(i,j,k)\rightarrow dp(i+1,j,k+2j)$

如果左右两边的$i+1$其中有一个与$[1,i]$进行匹配，另一个暂时不进行匹配$2j\times dp(i,j,k)\rightarrow dp(i+1,j,k+2j)$

那么时间复杂度$O(n^4)$

**oddness最大值n=2的时候可以为n^2**

#  ABC164F **I hate Matrix Construction**

## 题目大意

给定$S,T,U,V$和n构造一个$n\times n$的矩阵满足

- 如果$S_i=0$，那么第i行数字的AND和为$U_i$
- 如果$S_i=1$，那么第i行数字的OR和为$U_i$
- 如果$T_i=0$，那么第i列的数字的AND和为$V_i$
- 如果$T_i=1$，那么第i列的数字的OR和为$V_i$

$$
n\leq 500
$$

## 算法讨论

首先可以发现对于每一个二进制位都是独立的，那么相当于我们只需要考虑$U_i,V_i=0,1$的情况

那么首先如果某一行或者一列的AND要求为0，那么说明至少存在一个0，如果为1，那么说明全部为1

如果OR要求为0，那么说明全部为0，如果为1，那么说明至少存在一个1

首先将所有全部填0/1的行列确定，如果出现冲突，那么结束构造

然后如果剩下没有确定的行列个数$\geq 0$，那么可以将剩下的子矩形按照黑白染色进行填上0，1，那么每一行都是至少存在一个1和一个0，那么一定合法

然后考虑存在行或者列只存在一个没有确定的，那么枚举令一维的情况，如果可以已经满足了，那么填那个只有一行/列需要的数字即可

**需要最终判断一下得到的矩阵是否合法，避免所有行或者列都确定的情况下，存在被误判的情况**

那么时间复杂度$O(n^2\log V)$

# ABC155F **Perils in Parallel**

## 题目大意

现在有n个位置，其中第i个位置的坐标为$A_i$，状态为$B_i$

现在有m个操作，其中第i个操作将$[L_i,R_i]$范围内的位置状态进行翻转，求是否可以将所有位置的状态翻转成$B_i=0$的情况，并且输出选择的操作
$$
n,m\leq 10^5
$$

## 算法讨论

首先将所有位置按照$A_i$排序，然后将所有操作的区间转化为在序列上操作的区间

首先对于一个区间操作是难以处理的，由于异或是可以满足可减性的，那么考虑进行对于B进行差分得到的数组记作$c$

那么如果进行第$i$个操作，就是将$c_{L_i},c_{R_i+1}$进行翻转

那么可以将$L_i$与$R_i+1$之间连一条边，对于一个联通块来说，如果$c_i$的异或和等于1，由于每一次操作都是将两个数进行异或，不会改变$c_i$的异或和

需要特殊注意到的是如果$R_i+1=n+1$，那么只会对$c_{L_i}$一个位置进行异或，对于这样的操作不进行连边，然后如果某一个联通块异或和等于1，那么如果存在某一个位置可以被上面这种操作进行操作，那么可以修改某一个位置的$c_i$使得其异或和等于0

至于构造方案，那么就选取这个联通块的一个生成树，然后从叶子开始构造，当前节点x的某一个儿子u满足$c_u=1$，那么将$c_u=0,c_x$异或1即可，这条边对应的操作就要选上

时间复杂度$O(n\log n)$

# ABC128F ****Frog Jump****

## 题目大意

现在有n个位置，编号为0到n-1，现在要选定A,B

使得在一次操作中，先向右跳A单位，然后再向左跳B单位，如果过程中到达n-1那么就停止，并且不能经过相同的位置也不能跳 出$[0,n-1]$的范围

代价为所经过的位置上的数之和，求最大代价
$$
n\leq 10^5
$$

## 算法讨论

首先由于最终需要到达$n-1$，那么$A>B$

可以发现每一个操作结束之后，所在的位置都是$A-B$的倍数，那么可以将$A-B,A$看作一个区间，那么要求所有区间的端点不能在同一个位置

并且所有区间的左端点都是可以被$A-B$整除

那么我们可以枚举$c=A-B$，假设最后一个区间的位置$ck$，那么说明$ck+B=n-1$，那么$B=n-1-ck$，**并且$ck$这个位置是不会被经过的**

那么我们可以在枚举过程记录区间左端点的数字和，同时我们需要预处理出$n-1,n-1-c,n-1-2c...$这些位置的前缀和

那么就可以算出经过位置的数字和，可以将时间复杂度控制在$O(\frac{n}{c})$

那么总时间复杂度$O(n\log n)$

# ABC230H **Bullion**

## 题目大意

现在有k不同的重量的金条，$w_1,w_2,...,w_k$，每一种金条有无限个，现在有无限个代价，每一个袋子的重量为1

其中一个袋子可以装若干条金条和若干个非空的袋子，求出一个总袋子重量为$w\in [2,n]$的所有方案数
$$
n,w\leq 2*10^5
$$

## 算法讨论

首先可以发现的是这个过程很像生成树的过程，那么由于同一个重量的金条和袋子都是视作相同的，那么相当于就是对于无标号有根树进行统计

但是有一点不一样的就是，对于金条代表的节点的数量可以在$w_1,w_2,...,w_k$中任意选择

记$F$表示关于整个袋子重量的生成函数，$H=\sum x^{w_i}$，由于$w_1$不一定等于1，那么需要满足$[x^1]F=0$，然后加上H以满足转移

那么考虑树上的递归结构，就是枚举一个根，然后加上若干子树，这些子树如果是相同的，那么是被认为相同的，那么对于一种子树来说，假设其大小为$k$

那么其生成函数为$(1+x^k+x^{2k}+...)$，而对于子树大小为$i$的方案数有$f_i+h_i$种

那么我们就可以得到生成函数之间的关系
$$
F=x\prod \limits_{i\geq 1} \frac{1}{(1-x^i)^{f_i+h_i}}-x
$$
那么前面这一部分连乘就是欧拉变化的式子，那么根据欧拉变化的讨论，先取ln然后再求导可以得到
$$
\begin{align}
\ln (F+x)&=\ln x+\sum\limits_{i\geq 1} \ln \frac{1}{(1-x^i)^{f_i+h_i}}\\
\frac{F'}{F+x}&=\frac{1}{x}+\sum\limits_{i\geq 1} \frac{ix^{i-1}}{1-x^i}(f_i+h_i)\\
xF'&=F+x+(F+x)\sum\limits_{i\geq 1} \frac{ix^i}{1-x^i}(f_i+h_i)\\
\end{align}
$$
然后转化为某一项的递推式，其中$[x^n]\frac{x^i}{1-x^i}$这个的系数就是$[i|n]$

那么我们有
$$
nf_n=f_n+[n=1]+\sum\limits_{i=1}^{n-1}(f_i+[i=1])\sum\limits_{k|n-j} k(f_k+h_k)\\
(n-1)f_n-[n=1]=\sum\limits_{i=1}^{n-1}(f_i+[i=1])\sum\limits_{k|n-j} k(f_k+h_k)
$$
如果将$\sum \limits_{k|n} k(f_k+h_k)=g_n$的话，那么相当于就是一个分治FFT的形状

然后这里是自己卷自己的形式，那么需要特殊判断一下

就是判断r-l是否已经被计算得出，如果没有那么就是限制到mid，否则$[l,mid]\times [0,r-l]$和$[0,r-l]\times [l,mid]$都需要卷一次

时间复杂度$O(n\log ^2n)$

# ABC219H **Candles**

## 题目大意

现在坐标轴上存在$n$个蜡烛，每一个蜡烛的位置为$X_i$，长度为$A_i$，每分钟长度都会减小1，长度减到0就不减了，现在有人在坐标原点，每一次可以移动$\leq 1$的距离，到达一个位置可以熄灭这个位置上 的蜡烛，求最终剩下蜡烛长度和的最大值
$$
n\leq300
$$

## 算法讨论

首先注意到这个蜡烛最终会停止变短，那么还需要记录其时间，在计算过程中是难以处理的

那么我们不妨让这个蜡烛一直可以燃烧，长度可以为负数，那么我们不能让其计入到贡献中，那么需要将这个蜡烛舍弃，而且需要满足可以舍弃当前为正长度的蜡烛，但是可以发现这样是一定不优的

也就是说在当前操作下的最优解和原来问题的最优解是相同的

那么由于是一个人在坐标轴上移动，那么可以考虑区间DP

设$dp(l,r,i,0/1)$表示当前已经将区间$[l,r]$的蜡烛吹灭，然后在区间之外存在i个被舍弃的蜡烛，然后当前人在左端点还是右端点时候当前剩余蜡烛长度和的最大值

那么在转移的时候，走一步区间外燃烧掉的长度有$(n-(r-l+1)-i)$

然后走到一个新的位置时候，枚举当前这个位置是否被舍弃了，如果被舍弃了，那么i需要减少1，然后将整个蜡烛的长度在DP数值中减去即可

转移有8个转移，就是讨论一下出发位置以及终止位置，还有终止位置是否被舍弃即可

转移是$O(1)$，那么时间复杂度$O(n^3)$
