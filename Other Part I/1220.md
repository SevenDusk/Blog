# Vasya and Big Integers

## 题目大意

给定一个一个数$a$，现在要将a的十进制表示划分成若干段，对于一个段来说不能存在前导0，并且一段的数大小要在$[l,r]$区间中

求划分方案数
$$
a\leq 10^{10^6}
$$

## 算法讨论

首先考虑一个DP，设$dp(i)$表示当前最后一段划分的结尾在$i$的方案数

考虑$dp(i)$可以更新到哪些位置

首先如果$a_{i+1}$等于0的话，那么直接返回，如果$l=0$那么可以将$dp(i+1)$加上$dp(i)$

然后假设$l$的长度为$L$，$r$的长度为$R$

那么从$dp(i)$可能转移到的范围是$[i+L,i+R]$，

- 如果$L=R$，那么能转移的位置只有一个$i+L$，只需要判断a第$[i+1,i+L]$形成的数字是否在$[l,r]$，那么我们可以通过Hash+二分求出一个区间与l,r的LCP长度，那么我们就可以在$O(\log \log a)$的时间判断两个数的大小
- 如果$L\neq R$，那么对于$(i+L,i+R)$是一定可以转移到的，对于$i+L,i+R$这两个位置需要特殊判断一下，判断方式跟上面类似

那么相当于一个$dp(i)$可以转移到一个区间，那么我们可以树状数组进行维护

这样的时间复杂度$O(\log a\log \log a)$

其中求LCP可以将两个串拼接起来，然后预处理出Z函数即可，然后对于区间修改，可以用差分进行维护，因为并不会修改已经确定的位置

这样的时间复杂度是$O(\log a)$的

https://codeforces.com/contest/1051/submission/67662031

# The Shortest Statement

## 题目大意

给你一个有n个点,m条边的无向连通图。有q次询问，第i次询问回答从$u_i$到$d_i$的最短路的长度。保证图联通
$$
m-n\leq 20
$$

## 算法讨论

首先注意到边数不会超过点数太多，那么图就是在一个树的基础上加入不超过20条非树边

那么我们先求出这张图的一个生成树，那么如果我们不经过这些非树边，那么显然距离就是两个点在树上的距离，可以通过求LCA求得

而如果我们经过了非树边，那么我们一定经过某一个非树边的一个端点，这样的特殊点最多有$40$个，假设我们经过的点为x

那么所有经过非树边的路径长度的最小值是
$$
\min \limits_x dis_{x,s}+dis_{x,t}
$$
那么我们可以用dij预处理出来所有$dis_x$

时间复杂度$O((m-n) n\log n+q(\log n+m-n))$

### Solution 2

首先对于原图的生成树中，被非树边覆盖的联通块，单独拎出来考虑

对于其他部分连到这个联通块上的边，显然连接的点的度数是$\geq 3$，那么显然这样的点是$O(m-n)$级别的，对于联通块中其他的点都是度数$=2$，相当于是只存在一个环上

那么我们处理所有$\geq 3$的点之间的最短路，由于其他的点度数都是$=2$，那么我们可以暴力走过这些点，求出从一个特殊点走到另一个特殊点的路径的距离即可，这样复杂度是对的，因为=2度数的点只会被正反走过两遍

最后在特殊点之间用floyd进行处理出最短路

那么询问的时候如果在树上，那么之间询问树上路径距离

否则需要通过联通块中度数$\geq 3$的点走到另一个点去，然后需要处理出来路径上经过的所有特殊点，然后枚举起点和终点，求出最短距离，

时间复杂度$O(n\log n+(m-n)^3+q((m-n)^2+\log n))$

如果$n,q$同阶的话，跟Solution1的复杂度一样（常数小一些），但是细节多了很多，只有在n比较大的时候才有优势

# Distinctification

## 题目大意

假设$S$包含k个二元组$(a_i,b_i)$

我们可以进行若干次操作，一次操作中

- 选择一个$a_i$，如果存在$j\neq i$，满足$a_i=a_j$，那么将$a_i+1$，代价$b_i$
- 选择一个$a_i$，如果存在$j\neq i$，满足$a_i=a_j+1$，那么将$a_i-1$，代价$-b_i$

记$f(S)$表示最小代价，使得S中所有二元组的$a_i$不同

现在给定T，求S等于每一个前缀的时候$f(S)$
$$
n\leq 2\times 10^5
$$

## 算法讨论

首先需要考虑一个固定的S如何求出答案

首先可以发现的是，对于将每一个二元组按照a放到数轴上，对于连续的一段来说，放置的点数可能超过这个段的长度，根据操作性质，可以发现我们在不借助其他段的情况下，只能将多出的数向后填充

但是我们可能存在多个段，那么一个段将所有数放到唯一的位置上之后，可能会跟其他段重合，那么这两个段就可以合并

那么我们对于一个联通块，我们知道联通块中所有位置不能超过联通块中最小的位置，并且最终得到的位置一定形成了一个连续的段

接下来考虑最小代价，首先可以发现的我们可以交换相邻的两个数，并且如果前一个数的$b_i$小于后一个数的$b_j$，那么我们经过交换这两个位置之后，总代价是可以减少的，反之是增加的

那么显然最终最优状态就是所有二元组按照$b_i$降序排列，否则一定可以交换某两个相邻的位置使得代价变得更小

那么我们考虑向S中加入一个新的二元组如何更新答案，我们可以用map维护每一个联通块的最左端点位置，以及这个联通块的内部的二元组数量，然后对于每一个联通块，用线段树维护每一个$b_i$出现的次数以及出现b的和

在合并两个联通块的时候，可以用线段树合并更新答案，相当于我们在归并两个有序数组，那么在线段树合并的过程中需要记录代表右边那个联通块的线段树的后缀和以及数量

还有一个问题就是如果加入的二元组是在联通块内部的，那么我们可以先将这个二元组移到这个联通块的最后同时更新答案，然后按照上面的过程进行线段树合并

时间复杂度$O(n\log n)$

# Up and Down the Tree

## 题目大意

![20211220T1](D:\Blog\image\20211220T1.PNG)

## 算法讨论

首先我们需要预处理出来，树上每一个节点存在多少个叶子节点到这个点的距离$\leq k$，记作$sum(x)$，有多少个叶子节点到这个点的距离$=k$，记作$cnt(x)$

可以发现的是，如果我们从x的节点跳入$u$儿子子树内的一个叶子节点，并且$sum(u)-cnt(u)=0$，那么也就是意味着u子树内不存在到x节点等于k的叶子节点，那么我们一旦进入u子树，那么就不可能从u子树中出来

那么我们可以设$dp(x,0/1)$表示当前所在位置在x子树内并且需要满足最终是否可以跳出x这个子树时最大访问叶子节点数量，其中1表示还要出来，0表示不再出来

那么显然我们有转移，其中$dp(x,0)$的转移就是考虑，我们进入的所有子树都是需要可以跳出来的，然后$dp(x,1)$就是我们在经过其他可以跳出来的子树之后进入一个不再跳出来的子树即可
$$
dp(x,0)=\sum\limits_{u\in son(x)} [sum(u)-cnt(u)\neq 0] dp(u,0)\\
dp(x,1)=\max\limits_{u\in son(x)} (dp(u,1)+\sum\limits_{v\in son(x),v\neq u} [sum(v)-cnt(v)\neq 0] dp(v,0))
$$
其中我们可以维护先预处理$\sum\limits_{u\in son(x)} [sum(u)-cnt(u)\neq 0] dp(u,0)$的值，就是可以做到$O(son(x))$的转移

那么时间复杂度$O(n)$

# Fibonacci Suffix

## 题目大意

![20211220T2](D:\Blog\image\20211220T2.PNG)

## 算法讨论

首先由于所有后缀都是按照字典序排序，那么相当于我们在比较的时候是不断比较一个前缀，而后缀的前缀就是原来串的一个子串

那么我们可以枚举这个前缀（每一次先往后添加0，如果大于k，那么就变成1），那么求出有多少个后缀含有这个前缀，那么相当于就是在$F(n)$中求当前这个枚举的字符串出现了多少次

假设当前枚举的字符串在$F(n)$中出现了$f_n$次，首先如果$|F(n)|\leq m$，那么我们可以直接进行字符串匹配，求出在字符串中出现了多少次

否则对于$|F(n)|>m$的情况，我们预处理出来$F(n)$的长度为m的前缀和长度为m的后缀

那么考虑左右两个字符串，那么有$f_n=f_{n-1}+f_{n-2}$，但是这个字符串可能出现在$F(n-2),F(n-1)$之间，那么利用预处理的前缀和后缀，通过字符串匹配求出出现次数

以$F(n-2)$的前缀$pre$为例，假设当前的字符串为$s$，那么相当于我们要求哪些长度s的前缀可以作为$pre$的后缀出现

那么我们可以利用Z函数求出这个值，我们构造字符串$t=s+'?'+pre$，然后求出这个字符串的Z函数，那么枚举pre函数的位置，如果$|t|-i=z_i$，那么说明长度为$z_i$的前缀是可以作为$pre$的后缀出现的

所有的操作都是可以在$O(m)$的时间内完成

那么总的时间复杂度$O(nm^2)$

**这个时间复杂度还可以进一步优化**，就是注意到在$|F(i)|>m$的情况下$pre_i=pre_{i-2},suc_i=suc_{i-1}$

而我们使用的进行匹配的是$pre_{i-1},suc_{i-2}$，可以发现是存在一个长度为2的循环节，那么相当于我们只需要对于匹配进行计算$O(1)$即可，而不是$O(n)$

这样的时间复杂度就是$O((n+m)m)$的，可以发现的是我们在计算匹配的过程中复杂度只会与$m$有关，而在总复杂度中的n就是递推计算$f$的复杂度，那么显然$f$是可以矩阵乘法快速的求出来的，那么时间复杂度就可以优化到$O((\log n+m)m)$

https://codeforces.com/blog/entry/62411?#comment-463687

$O((n+m)m)$代码 https://codeforces.com/contest/1065/submission/44225229

