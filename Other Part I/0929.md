#  XX Open Cup. Grand Prix of Wroclaw. J [Planet of the Singles](https://official.contest.yandex.ru/opencupXX/contest/17756/problems/J/)

## 题目大意

给定长度为$n$的01串$s,t$，现在有以下三种操作

- 将某一位的0变成1，代价$t_0$
- 将某一位的1变成0，代价$t_1$
- 交换两个相邻位，代价$t_s$

现在要将$s$变换到$t$，求最小代价

## 算法讨论

### Solution 1

首先注意到交换两个位置$i,j$上的数（这两个位置上分别为0和1），需要交换次数就是$|i-j|$，考虑中间的0和1的连续段，往一个方向的交换，只需要经过其中一种的连续段，那么现在有两个方向，那么说明两种连续段都会要被经过，那么就是$|i-j|$

那么可以发现，如果不动已经匹配的位置一定是最优的，那么我们只需要考虑$s_i\neq t_i$的位置，将这些位置记作$a_1<a_2<...<a_k$，记$c_i=s_{a_i}$

那么问题就变成了，现在要将$c_i$变为$c_i\otimes 1$，通过0变1，1变0，交换相邻两个数的操作

#### 正确做法

考虑如果不存在前面两个操作的话，那么要求$c_1,...,c_k$中0/1的个数相同，那么就可以将$c_i=0$的数看作-1，$c_i=1$的数看作1，那么和要为0

那么如果存在前面两个操作的话，那么总体而言就不需要0,1个数相同，但是如果除去那些进行了前两种操作的位置，剩下分成的若干段一定是需要满足0,1个数相同的这个条件

那么相当于我们需要选出来若干个段，使得这些段不相交，段内进行交换，对于不属于任何一个段的位置使用前两个操作，那么就很显然是一个DP了，我们需要处理出来最短的合法段（段内不能再进行一次划分），然后将这些段进行组合

对于段间的代价可以利用前缀和进行维护，但是对于段内的操作就稍微有一点复杂

首先假设1个数-0个数的前缀和为$pre_i$，记$f_i=\sum\limits_{k=1}^i (a_{k+1}-a_k)pre_k$，那么答案就是$\sum\limits_{i=l}^{r-1} (a_{i+1}-a_i)|pre_i-pre_{l-1}|$，由于$[l,r]$是不可以再进行划分的 ，那么也就是说对于$i\in[l,r)$，不存在$pre_i=pre_{l-1}$，由于$|pre_i-pre_{i-1}|=1$，那么对于$i,j\in [i,j)$，满足$[pre_i<pre_{l-1}]=[pre_j<pre_{l-1}]$，就是段内$pre$与$pre_{l-1}$的大小关系是确定的，也就是可以将绝对值符号放到最外面

那么一段的答案就是$|f_{r-1}-f_{l-1}-(a_r-a_l)pre_{l-1}|$

就可以进行DP了，将最小段存到右端点上，设$dp(i)$表示当前考虑到$i$的最小代价，对于$r=i$的所有$l$
$$
dp(i)=\min(dp(i-1)+[c_i=0]t_0+[c_i=1]t_1,dp(l-1)+cost(l,i))
$$

#### 假做法

一开始建出了一个费用流的模型，想着模拟费用流（事实上是可行的），想只考虑0或者1，然后进行匹配，由于从小到大匹配的一定是递增的，但是可以将1变成0，0变成1，然后按照位置从小到大进行讨论

但这个不符合费用流的增广规则，费用流必须要找最短路进行增广

后面想到转化之后，想直接利用一个栈进行贪心选择，遇到与栈顶元素不同的元素，就将其匹配起来，然后对于所有的匹配对，比较直接修改和交换的代价，选择比较小的那个，对于没有进行匹配的元素直接进行修改

但是这样显然不对，当前较少的元素不一定是跟前面的元素匹配，可能是跟后面的元素匹配

比如说$a=2,3,5,6,7,c=1,1,0,0,1$，按照上面的做法就是会$5-3,6-2$匹配，事实上$3-4,6-7$匹配更优



然后进行一些改进，