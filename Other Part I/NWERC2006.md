# D.Ticket to Ride

## 题目大意

给定一张图，$n$个点，$m$条边，并且给出4条路径的起点和终点，需要在图上保留一些，使得4个路径的起点和终点相联通
$$
n\leq 30,m\leq 1000,Testcase\leq 20
$$

## 算法讨论

首先我一开始不知道斯坦纳树这个东西，在思考如何进行状压，后来想起来有这个东西，就去学习了一下斯坦纳树

显然我需要关注的最多只有8个点，但由于路径之间关系有相交和不相交，那么最优解一定是一个森林

那么对于某一颗树来说，可以利用斯坦纳树的方案算出最优解，那么剩下的问题就是如何将4条路径划分成若干个树，依然考虑状态DP

设$f(s)$表示当前已经满足集合为$s$的条件的最小代价

转移就枚举s的子集，然后利用斯坦纳树计算代价

正确性：这样DP可能会把一棵树当作好几棵树进行统计，但是会发现这样一定比当作一棵树劣，那么只要统计过程正确，最终的答案就是对的

时间复杂度$O(2^4(n3^8+2^8(n+m)\log m+3^4)$

空间复杂度$O(n2^8)$​

## 另解

1.就是不需要每一次对于一个集合s都去做一遍斯坦纳树，**这样会重复计算**，只要一开始处理出来全集的斯坦纳树，对于s集合答案就是$\min_{i=1}^n dp(i,s)$，复杂度就是$O(n3^8+2^8(n+m)\log m+3^4)$​

第一次提交：Accepted

# E.The Bookcase

## 题目大意

有$n$个元素，每一个元素有两个属性$(t_i,h_i)$，划分成三个集合$s_1,s_2,s_3$，最小化$(\sum\limits_{j=1}^3\max\limits_{i\in s_j}h_i)*(\max\limits_{j=1}^3 \sum\limits_{i\in s_j} t_i)$
$$
3\leq n \leq 70\\
150\leq h_i\leq 300,5\leq t_i\leq 30\\
Testcase\leq 20
$$

## 算法讨论

注意到贡献是由两个部分构成，其中$\sum\limits_{j=1}^3\max\limits_{i\in s_j}h_i$，只涉及到三个位置，那么考虑从这个部分进行突破

先将元素按照$h$​降序排列，那么可以发现第一个位置的一定会加入贡献中，那么如果设选出后面两个位置为$j,k$

那么对应书架上的数需要在这个位置之后，想办法在DP数值中统计h这一维，在状态中考虑第二部分贡献（因为这个是背包，只能放在状态里面）

那么设$dp(j,k)$表示当前第二个书架和第三个书架的$t$之和分别为$j,k$的最大$h$之和

转移只要讨论一下，当前的$j$是否为$0$，$k$是否为$0$，如果为$0$，那么需要加上当前的$h$，注意不能两个同时加

直接这样做是$O(n^3k^2)$，虽然在CF上也可以通过，但是依然存在更优的做法

考虑分析一下答案上界

如果将$h$​最大的三本书，分别放在三个书架上面，那么后面的书都可以任意放，由于$t\leq 30$​，那么最优的贡献就是$\frac{s}{3}+[0,60]$​

由于$150\leq h\leq 300$​，即使最差的情况也只是最优情况的一半，并且在所有方案中第一本书一定是算入的，那么可以得到$j,k$​的实际上界为$(\frac{s}{3}+[0,60])\frac{3}{2}=\frac{s}{2}$​

实际取$1200$即可，虽然快不了多少，但是常数上更优，并且这种优化方式值得借鉴

时间复杂度$O(n^3k^2)$​

## 另解

1.还有一种常数比较小的做法，就是按h升序排序，然后DP状态是一样的，然后在转移状态的时候强制选当前的位置，计算出贡献，然后加上最后一个位置的h，这样后面有一些已经确定的位置（就是h最大的位置到第二个书架选出的第一本书的位置）就不需要被枚举到，并且也少了统计答案的部分，在转移的时候就算好了

第一次提交：Accepted

# A.Sudoku

## 题目大意

给定两个数独，其中第一个数独已经完成，第二个数独还没有完成，但保证有唯一解

现在有5种操作，旋转，在$3*9$或者$9*3$中交换行和列，交换9 × 3 row segment，3 × 9 column segment，将数字1-9通过排列进行映射

问这两个数独是否在同一个等价类中

## 算法讨论

首先需要将第二个数独填好，这个可以直接进行搜索，就是将每一次找到一个空的位置，然后将所处行和列还有3*3中可以填入的数取交，那么依次枚举即可

然后考虑进行判定

注意到旋转操作相当于交换行列，由于交换操作的存在，可以不考虑旋转了多少度，在判定时候，只要按原来的行列进行判断，然后再按中心对称，交换行列进行判断一次即可

接下来看交换操作，对于行/列交换来说，首先是可以3个3个进行交换，然后可以在3个之内进行交换

最后映射操作最为麻烦，直接处理只能9!进行枚举，显然会超时

考虑本质不同的列交换个数只有$3!^4=1296$，那么考虑枚举每一种列交换，那么只需要看是否存在一组映射满足条件

具体的，在枚举列交换之后，需要枚举第一行是哪一行，以此确定数值的映射，然后用这个映射和枚举的列交换带入每一行，得到每一行数值，然后可以将一行看作一个数，按这个数排序，然后根第一个数独进行比较，如果可以匹配的上，那么就合法，否则$No$​

## 另解

1.dfs搜索列交换，并且一边剪枝一遍搜，有些状态不需要完整搜到就被剪掉了[Submission #14993736 - Codeforces](https://codeforces.com/gym/100722/submission/14993736)

2.不过他没预处理所有状态，每一次都dfs处理出来

3.直接暴力枚举9!的映射操作，然后同样枚举第一行对应着哪一行，求出列交换对应的排列，然后依次求出每一行，压缩成数字排序比较

第一次提交:Accepted

# B.The SetStack Computer

## 题目大意

现在有一个栈，需要支持5种操作

加入一个空集合，复制栈顶的集合并且加入栈顶，对于栈顶的两个集合求交，求并，将第一个集合加入第二个集合中

输出栈顶第一个集合的大小
$$
n\leq 2000
$$

## 算法讨论

首先，可以发现集合之间的关系形成树形结构，其中求并求交需要支持比较两颗树是否同构，那么自然的可以想到Hash，但是由于复制操作的存在，使用一般的树Hash，可以使用与子树内节点个数无关的Hash

同样是由于复制操作的存在，在实现的时候不能直接进行复制，每一个点只能记录儿子，复制操作时候直接继承上一个点的信息

在维护的过程可以保证儿子顺序按Hash值递增，那么在求并求交的时候可以使用归并排序，做到$O(n)$

总复杂度$O(n^2)$​

## 另解

1.在维护儿子的时候不用vector，而是用set，那么在维护hash值的时候，就可以做到$O(\log n)$​插入删除，而set自带的去重的性质，那么求并的时候将size小的插入到size中去，然后求交可以用count函数判断是否两个集合中都有

第一次提交:Wrong Answer

# H.Lineland's Airport

## 题目大意

给定n个点$(x_i,y_i)$​，相邻两个点之间有连线，连线以下代表着石块，现在需要开拓一块长度为l的平地，问需要至少移走多少面积的石块
$$
n\leq 500\\
L\leq 10000\\
$$

## 算法讨论

一开始实在不会做，于是设步长做，后来将每一个位置的答案输出来，发现了在某一些区域之内答案是凸的，于是开始考虑三分

但是整体上仍然没有什么性质，但是由于这个l的线段的起点和终点要么落在两个点之间要么在某一个点上，对于落在某一个点上的可以$O(n^2)$处理出答案，那么需要关注的只有起点落在两个点之间

然后继续设步长打表，发现就是凸的，那么直接三分就行了，在计算面积的时候，需要注意线段有可能没有跨过任何一个点，只需要用梯形算一下即可，否则就是求出于中间所有线段的交点，在扫描的时候动态更新一下当前y坐标的位置以及相应的面积，增加的一定是矩形很好计算

证明：由于图中都是一次函数，其面积也就是二次函数，由于中间的贡献在确定高度下都是固定的，那么只需要

关系两端的二次函数，那么两个二次函数相加还是二次函数，那么就是凸的

时间复杂度$O(n^2\log n)$

第一次提交:Runtime error
