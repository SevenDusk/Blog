# **Row Column Sums**

## 题目大意

现在要对于一个$H\times W$的网格上每一个格子进行填数，范围为$[0,k-1]$，其中要求对于每一行的和模k为$A_i$，每一列的和模k为$B_i$

求出可以填数中最大的那个

## 算法讨论

首先在确定一个合法的情况下，可以选取其中一个子矩阵，然后将四个角落的格子以对角线上两个角落填的数不同的方式填上+1,-1

比如+1-1

​		-1+1

可以对方案进行调整，如果将左上角右下角不填，那么就可以对与某一行和某一列同时进行+1或者-1

首先考虑什么时候不存在方案，那么$\sum A_i \not \equiv \sum B_i(\bmod k)$

然后需要将所有的位置设为$k-1$，然后将方案进行调整，由于格子中所有数都为$k-1$，那显然如果进行加法肯定是不优的，那么只能进行减法

那么对于第$i$行来说，其需要进行$C_i=W(k-1)-A_i$次调整，对于一列来说，其需要进行$D_i=H(k-1)-B_i$次调整

那么显然$\sum C_i\equiv \sum D_i(\bmod k)$，那么假设$f=\min(\sum C_i,\sum D_i),g=\max(\sum C_i,\sum D_i)$，那么$g=f+xk,x\in \mathbb{N}^*$，那么根据上面的调整方法，每一次可以同时给一行和一列进行-1实现，那么说明至少需要$g$次操作才能完成

但是注意到进行这样一次的操作之后总和-2，但如果将-1放到第$i$行第$j$列的话，那么每一次只会-1，并且对于一个格子来说其最多会被操作$\max(C_i,D_j)<k$，那么不会减到k-1

那么答案就是$WH(k-1)-g$

时间复杂度$O(w+h)$

https://atcoder.jp/contests/arc133/submissions/28694571

### 错误做法 1

https://atcoder.jp/contests/arc133/submissions/28684603

就是在计算$C_i,D_i$的时候，需要注意当前第一行和第一列也是填上了$k-1$，那么这一行需要修改的次数就是$C_i=W(k-1)-A_i$，而不是$C_i=(W-1)(k-1)-A_i$

### 错误做法 2

https://atcoder.jp/contests/arc133/submissions/28685340

应该是打错了，在将所有格子填上$k-1$之后，需要将某一行的和进行调整，此时并不是将k-1变成$A_i$就可以了，否则并不满足这一行和在模k的意义下等于$A_i$的限制

### TLE随机做法

https://atcoder.jp/contests/arc133/submissions/28693118

首先任意交换两行或者两列问题的答案是不变的，然后可以先将除了第一行和第一列以外的位置都填上k-1，那么此时就可以唯一确定第一行和第一列的值

然后此时不一定是最优的情况，那么根据上面最开始叙述在满足限制的情况下对方案进行调整的方案，就是将一个矩阵的四个角对应+1,-1

那么这里唯一特殊的位置就是最左上角的这个位置，显然选取这个位置作为这个子矩阵的左上角会比选择其他位置更优，由于一次需要对于一行和一列同时进行操作，相当于在这两个位置组成的二元组的所有循环中找到和最大的一个

可以发现由于两个元素的差尽可能小的情况更优，那么进行排序，然后按序配对即可

但是在减少某一对变量$(a,b)$的时候，同时维护左上角的值，由于如果将左上角的值加成$k$，那么对总答案的贡献会-k，而程序中是直接将$(a,b)$其中最大的那个减成$k-1$，这样会对之后的操作产生影响，并且难以确定当前是最优的

所以需要随机左上的那个元素是哪个，做一次算法正确的概率理论上是$\frac{1}{n}$（不知道分析是否正确）