# 积木

## 题目大意

![2021-10-14 17-47-42屏幕截图](D:\Blog\image\2021-10-14 17-47-42屏幕截图.png)

## 算法讨论

首先可以$2^{12}$枚举*位置是否要填，然后现在图中只剩下o的情况

### Solution 1

首先一个o周围有一个格子被占据了，或者在边界外，那么这个o填的积木方向就是确定的，那么在边界上的o的方向一定已经确定了，然后将影响到的格子的方向也确定掉，还有就是两个格子相邻的情况

当然过程可能会存在冲突的情况，也就是说某一个o周围的格子至少存在两个被占据了，那么当前情况的方案数就是为0

考虑将一个o周围的格子称为蓝色格子，那么如果两个格子之间存在公共蓝色格子，那么就需要连一条边，**需要注意的是如果存在两个公共格子就需要连两条边**

然后显然每一个联通块都是独立的，那么只需要单独处理其中每一个联通块的方案数，然后将所有联通块的方案数乘起来即可

首先会发现，如果这个联通块没有环的话，第一个点可以产生4个蓝色格子，后面每一个点都会产生3个蓝色格子，那么最终这个联通块的格子数量为$3\times cnt +1$

那么如果这个联通块存在$k$个环的话，蓝色格子数量就是$3\times cnt+1-k$，由于至少需要$3\times cnt$个蓝色格子，那么说明$k\leq 1$，其他情况方案数都为0

- 首先考虑$k=0$的情况，那么蓝色格子有$3\times cnt+1$，那么说明在放置积木之后存在一个格子空闲，那么考虑枚举是哪个格子多余，那么周围那个o的放置方向就一定确定了，然后会影响周围的o，然后扩展到整个联通块，那么唯一确定一种放置方案，那么方案数为$3\times cnt+1$
- $k=1$，如果确定了环的放置情况，那么其他部分都是确定的，环上显然有两种放置方案

只要将所有上面分析结果相乘即可

如果$*$的个数有$c$个，那么时间复杂度$O(2^c nm)$

### Solution 2

考场做法

首先不一样的就是，我是考虑周围格子与o位置的距离$\leq 2$的12个格子，然后这样形成的联通块

前面都是一样的，就是分析联通块的贡献时候不大一样，我是直接进行搜索，枚举联通块中一个o的放置方向，然后根据周围的影响确定其他的格子方向

确定方向也是求出周围存在多少个占据的格子，**如果$\geq 2$，那么直接返回0，然后枚举4个方向**，有了这个就保证枚举的复杂度至于答案大小有关

**这里枚举的顺序一定要是bfs序或者dfs序，否则会退化成指数级，实践中bfs序更好（这是由于，可能dfs会达到很深的深度，然而在另一个分叉却不合法）**

**还有一个剪枝就是，枚举12个$*$涉及的点集是有限，会存在某一个联通块不含任何的$*$，那么考虑对于当前枚举的联通块点集进行记忆化，这里可能需要hash一下**

比赛的时候这两个剪枝都没加，但是数据比较水过去了，TC上被强数据卡掉了，加上这两个剪枝16s -> 1.6s，虽然只枚举了答案次，但是由于搜索树的深度最坏是$O(n)$的，那么时间复杂度$O(2^cnm\max(n,m))$
