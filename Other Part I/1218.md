# 矩阵

## 题目大意

![20211218T1](D:\Blog\image\20211218T1.PNG)

## 算法讨论

首先可以发现的是，最后一列是最特殊的一列，那么我们单独维护这一列的信息

对于最后一列来说，每一次操作都是需要求出这一列形成的序列中第k个位置上的编号，然后支持任意位置删除和在末尾加入新的元素

那么我们可以考虑开一个n+q大小的树状数组，对于原来这一列中第$i$个位置是对应着树状数组的第$i$个位置，对于第i个询问添加在序列最后的位置对应着树状数组中第$n+i$个位置

初始的是树状数组中前n个位置权值都是1，然后当删除加入操作都是可以简单维护，然后求第k个位置可以使用树状数组二分

那么最后一列的问题就解决了

然后考虑每一行的问题，我们可以预处理出来所有在这一行的询问，然后按照顺序进行枚举，我们需要求出落在原来这一行中的询问集合和没有落在原来这一行中的询问即可

这个可以通过树状数组进行查询，如果当前剩下的原来的位置小于询问的列坐标，那么说明这个询问时落在原来的位置之外的，那么可以将y减去当前剩下的原来的位置数量即可

这个仍然可以用树状数组实现

然后对于那些在原来位置之外的询问，那么可以通过维护类似最后一列的树状数组进行操作，需要注意的是我们需要用vector来实现这个树状数组，以保证空间复杂度正确

这样的时间复杂度$O(n\log n)$

# 序列

## 题目大意

![20211219T2](D:\Blog\image\20211219T2.PNG)

## 算法讨论

首先考虑一个暴力的DP

设$dp(i,j)$表示当前$A_i=j$且前i个数都是满足条件的最小代价

那么有转移
$$
dp(i,j)=(\min \limits_{k=i-R}^{i-L} dp(i-1,k))+|A_i-j|
$$
可以发现的是，关于$j$的函数$dp(i,j)$是一个下凸的分段函数，如果需要证明这个，那么可以考虑归纳

首先对于$i=1$的情况有$dp(1,j)=|A_1-j|$，绝对值函数显然是下凸的分段函数

对于$i>1$的情况，由于一个下凸函数加上另一个下凸函数仍然可以得到一个下凸函数，那么我们只需要说明$\min \limits_{k=i-R}^{i-L} dp(i-1,k)$是一个下凸函数即可，首先我们可以将整个函数向右平移$L$个单位，然后相当于对于前面R-L长度的区间中取最小值，显然对于斜率大于0的右半凸包才会改变函数的数值，那么相当于将右半凸包再向右平移$R-L$个单位，最终得到的是一个下凸函数

那么我们就可以用大根堆维护左半凸壳的端点，相邻节点形成的边的斜率变化为1（那么说明堆里面可能存在多个相同的节点），用小根堆维护右半凸壳的端点即可

当加入一个绝对值函数的时候，相当于在$A_i$左侧的所有直线的斜率-1，右侧所有直线的斜率+1

那么如果$A_i$落在左右凸包之间，那么对于左右凸包各自加入一个$A_i$端点

如果$A_i$落在左凸包，那么将左凸包的横坐标最大的端点加入右凸包即可，然后由于$A_i$左右两个直线的斜率相差了2，那么需要加入两个$A_i$，如果$A_i$落在右凸包的时候也是类似的

但是需要注意一下函数的范围，对于第i个函数其范围就是$[1+(i-1)L,m]$，那么可以发现的是只要我们第一次维护凸包的时候控制在范围$[1,m]$，那么之后维护出来的就一定是合法的，但是对于左凸包的维护需要注意加入$A_i$的时候，如果超出范围那么不能加入到凸包中，如果左凸包空了，那么加入当前函数范围的端点即可

还需要维护一下这个下凸函数的最小值，这个是简单的

时间复杂度$O(n\log n)$

# 树

## 题目大意

![20211218T3](D:\Blog\image\20211218T3.PNG)

## 算法讨论

同样需要考虑一个暴力DP

设$dp(x,i)$表示x子树内所有叶子节点到x的距离等于i的最小代价

记$g(x,i)=\min \limits_{j} dp(x,j-w_{x\rightarrow fa_x})+|i-j|C_{x\rightarrow fa_x}$这个表示当x子树加上x到父亲的这条边的时候，叶子距离等于i的最小代价

那么有转移
$$
dp(x,i)=\sum \limits_{u\in son(x)} g(u,i)
$$
由于下凸函数相加仍然得到下凸函数，那么重要的转移就是在$g$的转移上

同样的我们需要证明$dp(x),g(x)$都是一个下凸函数，其中我们只需要说明$g$是下凸函数，那么就可以说明$dp(x)$是下凸函数

可以发现的是，对于g的转移，首先是将所有函数向右平移$w_i$个单位，然后相当于对于凸包上的所有边的斜率$<-C$或者$>C$的边都删除掉，其他位置的函数值不会发生改变，并且被更改的位置的点最优的j就是斜率在$[-C,C]$之间形成的凸包的左右两个端点

那么显然修改之后的函数仍然是一个下凸函数

那么我们需要将若干下凸函数进行相加合并，那么我们可以用启发式合并实现，需要注意的是一次合并的复杂度只能跟较小的凸包中点的个数有关

那么对于加入一个凸包来说，相当于就是加入若干条线段，然后在线段范围内的所有线的斜率需要加上这个线段的斜率即可

**那么相当于需要支持一个区间加的操作，那么显然我们维护凸包无法简单的使用线段树进行维护，那么我们就可以考虑差分**，对于凸包上的每一个点维护左右两个线段斜率的差值，然后同时维护出最左边和最右边直线的斜率即可

那么在加入一个线段时候，就只需要修改两个端点即可，我们可以用map维护所有端点

那么首先将小凸包中的所有点加入到大凸包中，然后对于小凸包中的所有线段的两个端点更新维护的值即可

然后将两个凸包最左和最右两个直线的斜率相加即可

然后就是如何构造方案，首先我们需要求出最小的$dp(1,i)$然后递归的进行构造方案，我们构造的主体是对g进行构造

其中观察g的转移，可以发现在斜率$\in [-C,C]$的这个凸包区间中，最优方案数就是原来的$dp(x,j-w_{x\rightarrow fa_x})$，那么直接递归下去更新即可

然后考虑在区间外的位置，那么一定是在区间内形成凸包的最左边或者最右边那个端点更新的，那么我们在计算凸包的过程中对于每一个点记录一下这两个端点即可

时间复杂度$O(n\log ^2n)$

