# ARC125C LIS to Original Sequence

## 题目大意

给定长度为$k$的上升序列$a$，求出字典序最小的长度为$n$的排列，使得其LIS为$a$

## 算法讨论

像这种题应该想到递归构造，感觉我对这个递归构造很不熟悉。。。

首先由于是排列，如果我们处理好第一个元素，然后将其他元素离散化，就可以变成一个规模更小的问题

那么首先考虑一些特殊情况

如果$k=1$，那么唯一一种合法的排列就是$n,n-1,...,1$

如果$a_1=1$，那么显然第一个位置放$1$最优，那么就转化为$n'=n-1,A=\{a_2-1,a_3-1,...,a_k-1\}$的问题

那么需要考虑的就是$a_1>1$​的情况，由于需要构造的是字典序最小的情况，可以构造$a_1,1$的情况，显然这样是合法的，那么递归下去构造就可以了

# ARC125D Unique Subsequence

## 题目大意

给定一个长度为$n$的子序列，求出有多少个子序列满足只有唯一的方法得到这个子序列
$$
n\leq 2*10^5
$$

## 算法讨论

首先的想法就是类似本质不同子序列的DP方式进行DP

还需要注意到，如果一个字母出现了多次，那么结尾不是在最后一个位置上的子序列，都不是合法的子序列

那么考虑设$f(i)$表示只考虑原来序列前$i$个元素时候合法子序列在$i$结尾

根据刚才的性质，那么如果上一个字符是与当前字符不同的，那么只有最后出现的那个位置有用

然后考虑上一个字符与当前字符相同，那么就需要这个字符在子序列中出现的次数等于在序列中出现的次数，那么根据归纳，那么就只要找到上一个出现的位置即可，前面的不予统计
$$
f(i)=\sum\limits_{j=last_{a_i}}^{i-1} [j=last_{a_j}]f(j)
$$
那么就是这个形式的转移，可以直接树状数组进行维护，时间复杂度$O(n\log n)$

# ARC125E **Snack**

考虑建立最大流模型，建立源点汇点$s,t$

对于$n$种糖果建立$n$个点，$s\rightarrow i$，容量为$a_i$

对于$m$个人建立$m$个点，$i+n\rightarrow t$，容量为$c_i$

然后$i\rightarrow j+n$，容量为$b_j$

然后求出$s$到$t$的最大流，就是答案

直接建图跑最大流，显然会超时，那么就需要模拟这个过程（由于这个图很特殊就可以这样干）

**首先需要讲最大流转化为最小割**

显然可以割三种边，假设前$n$​个点集合$S$​中的点与源点之间的边被割掉了，$m$​个人中集合$T$​中的点与汇点之间的边被割掉了

那么这个割的方案代价就是
$$
\sum\limits_{i\in S} A_i +\sum\limits_{i\in T} C_i+\sum\limits_{i\notin T}(n-|S|)B_i
$$
考虑枚举$S$的大小$k$，然后显然第一部分就是取出$A$中最小的$k$个，然后改写一下式子
$$
\sum\limits_{i\in S} A_i +\sum\limits_{i=1}^m (n-k)b_i+\sum\limits_{i\in T}(C_i-(n-k)B_i)
$$
那么我们就要最小化$\sum\limits_{i\in T}(C_i-(n-k)B_i)$这个式子

显然将所有$C_i-(n-k)B_i\leq 0$的加起来就是结果

这个可以预处理得到

# ARC125F Tree Degree Subset Sum

## 题目大意

给定一棵树，求出有多少个二元组$(x,y)$满足存在选出恰好$x$个节点，使得其这$x$个节点的度数和为$y$
$$
n\leq 2*10^5
$$

## 算法讨论

首先需要对这个二元组进行一点变化$(x,y)\rightarrow (x,y-x)$，就相当于将所有节点的度数减一

那么注意到$\sum\limits_{i=1}^ndg_i-1=2(n-1)-n=n-1$​

那么所有不同的$dg_i-1$​最多只有$\sqrt n$种，那么做背包的时候一维可以减少很多状态

但是这样做背包还是需要记录两维状态，一个是个数一个是度数和

但是由于这是一个树的结构，那么$dg_i=1$​或者$dg_i=2$​的节点数量是$\geq \frac{n}{2}$的，那么对于度数和相同的子集来说，使度数和不变就是可以加$dg_i=1$或者将某一个数拆分成两个，由于等于1的节点很多，那么个数变换应该是连续的

那么做背包的时候只需要记录一下可以得到的最大/小集合大小，那么方案数就是大小之差

转移的时候需要用单调队列维护一段区间内的最大/小值

时间复杂度$O(n\sqrt n)$