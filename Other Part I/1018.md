# SortingSubsets

##  题目大意

给定一个序列$a$，要求将这个序列排序，可以选择一些位置集合，任意排列集合位置里面的数，求最小需要多大的集合

## 算法讨论

首先将$a$排序，然后如果一个位置原来的数与排序之后的数不同，那么这个位置就一定需要加入位置子集中，那么最小子集大小就是涵盖所有这样的位置集合

# XMarksTheSpot

## 题目大意

现在$n\times m$的网格上有三种格子`O . ?`其中$?$既可以是O也可以是.，现在要求对于所有情况，求出最小覆盖所有O的矩形面积，然后求和

?个数不超过19

## 算法讨论

首先需要枚举所有?是取O还是.

可以预先处理原来格子就是O的最小覆盖矩形，也就是四个边界，然后将枚举中新增的O与四个边界分别取max,min即可

这样的复杂度就是$O(k2^k)$

**如果不预处理的话，时间复杂度$O(2^k nm)$这样会TLE**

# LastDigit

## 题目大意

将一个数每一次去掉最低位，然后求和，给出$s$，要求构造一个数通过这样的过程结果为s

## 算法讨论

考虑每一个位的贡献，会发现是形如$x\times 111111...$的形式，由于构造的数位数最多就是$s$，那么我们从高位到低位枚举，每一次取最大的$x$，然后将$s$减去$x\times 11111...$

然后递归考虑，如果最终s不能减到0的情况，那么就是无解

# RepeatStringEasy

## 题目大意

称一个字符串$s$为好的，当且仅当这个s可以拆成两个字符串拼接起来，给定一个字符串$s$，求出最长好字符串

## 算法讨论

可以将s分成两部分，然后对于两部分求最长公共子序列

# DivisibleSetDiv2

## 题目大意

给定数组$b$，要求判断是否可以构造数组$x$，记$m=\sum x_i$，使得$b_i x\geq m$
$$
n\leq 50,b_i\leq 10
$$


## 算法讨论

可以枚举$m$，可以发现m的上界是$O(nb)$级别

那么需要满足的条件就是
$$
\sum\limits_{i=1}^n \lceil \frac{m}{b_i}\rceil\leq m
$$
构造方案就是将多余的数字任意放到某一个数上即可

# Arrfix

## 算法讨论

给定序列$A,B$和一个集合$F$，要将$A$中$|F|$位置替换成$F$中的一个数，最小化$\sum\limits_{i=1}^n [A_i\neq B_i]$

## 算法讨论

首先枚举初始序列$A,B$不同的位置，然后在$F$中找，如果找到了，那么将$A_i$替换成$B_i$，将$B_i$在$F$中删去

结束这个过程之后，枚举剩下$F$中的每一个元素，优先放到与$B_i$相同的位置，如果找不到，然后找$A_i\neq B_i$的位置，如果还是找不到，那么就随便放一个还没有被放过的位置

# BearPasswordAny

## 算法讨论

给出$x$数组，其中$x_i$表示长度为i的相同字符字符串作为子串在原串中出现了多少次，要求构造一个只含$a,b$两种字符的字符串，满足条件

## 算法讨论

首先考虑将原串极长相同子串缩成一段，假设这一段的长度为$len$

那么可以对于i贡献$len-i+1$

那么对$x$做一次差分，得到是长度的前缀和，然后再做一次差分，得到每一种长度的个数，如果中间出现了负数，那么判断无解

还需要所有长度的段长度之和等于n

否则就可以构造了，对应长度的段，然后将这些段拼接起来即可

# DistinguishableSetDiv2

## 题目大意

给定n个人，m个问题，给出每一个人对于每一个问题的回答，求出有多少个问题的子集，可以将所有人区分出来
$$
n\leq 50,m\leq 10
$$


## 算法讨论

可以直接枚举这个子集

只要出现有相同字符串的情况，那么就说明这个子集无法区分出所有人

时间复杂度$O(n2^m)$

# BiconnectedDiv2

## 题目大意

现在有n个点，其中第i个点向第i+1,i+2个点连无向边，给出边权，需要保留一些边，使得这张图为点强连通图，并且最小化保留边的边权

## 算法讨论

首先如果一个点的度数$<2$，这个其他点到这个点的路径是确定的

那么一个点没有被某一个条边跨越，那么这个点一定是割点，应为从这个点左边走到右边一定要经过这个点

那么说明所有跨越长度为2的边都要保留

这样只有左右4个点度数为1，那么只需要加入最左边和最右边的边即可，至于中间长度为1的边，只保留为边权为负数的边

# Dubs

## 题目大意

定义一个数是好的，要求它至少包含两位数字，两个最低有效数字相同 

给你两个长整数：L 和 R。计算 L 和 R 之间有多少好的数

## 算法讨论

首先转化为计算$\leq x$中有多少个好的数，记作$f(x)$

那么可以将最后两位看作同一位，将x限制变成$\leq x$最大的好数，那么变化之后答案就是最大的好数将最后两位看作一位的数字大小

答案就是$f(r)-f(l-1)$

# Sunnygraphs2

## 题目大意

Hero 刚刚构建了一个非常具体的图表。他从 n 个孤立的顶点开始，标记为 0 到 n-1。对于每个顶点 i Hero 然后选择一个顶点 a[i]（除了 i），并添加了一条连接 i 和 a[i] 的边。通过这种方式，他创建了一个具有 n 个顶点和 n 个边的图。请注意，如果 a[x]=y 且 a[y]=x，则顶点 x 和 y 由两条不同的边连接。 Hero 现在想要执行以下程序： 添加一个新的孤立顶点数 n。 选择原始顶点的子集 M。 对于 M 中的每个 x，擦除顶点 x 和 a[x] 之间的一条边。 对于 M 中的每个 x，在顶点 x 和 n 之间添加一条新边。 Hero 的目标是创建一个最终图，其中顶点 0 到 n-1 都在同一个连通分量中。 （即，必须有一种方法可以通过沿着一条或多条连续边从任何其他顶点到达这些顶点中的任何一个，可能沿途访问顶点 n。）请注意，Hero 并不关心顶点 n 是否在同一组件中作为其他顶点：两种可能性都很好。在上述过程的第 2 步中，Hero 有 2^n 个可能的子集可供选择。如果 M 产生具有所需属性的图形，则选择 M 是好的。计算 2^n 种可能性中有多少是好的选择。返回该计数为 long。 

## 算法讨论

首先对于每一个联通块进行考虑，可以发现每一个联通块都是一个基环树

一个联通块需要全部连到n上面，那么如果没有选择环上的节点，是不能选择其他的节点，假设记作这个联通块的大小为$k$，环上有$a$个节点，那么这个联通块的方案数就是$2^k-2^a$

然后将所有联通块的贡献乘起来即可

需要特殊注意一下，图中只存在一个联通块的情况，是可以不选择任何节点连到n上面的，那么答案需要+1

# NonDeterministicSubstring

## 算法讨论

给定两个字符串：A 和 B。A 中的每个字符要么是“0”，要么是“1”。 B 中的每个字符都是“0”、“1”或“?”。 如果我们可以通过更改每个 '?' 将 B 更改为 C，则字符串 C 与 B 匹配。 在 B 中要么是“0”，要么是“1”。 '?' 的不同出现 可以改成不同的数字。 例如，C = "0101" 匹配 B = "01??"。 请注意，C 中的每个字符必须是 '0' 或 '1'，不能有任何 '?' 剩余。 考虑与 B 匹配的所有可能的字符串。这些字符串中有多少是作为（连续的）子字符串出现在 A 中的？ 计算并返回它们的编号。 请注意，我们只计算每个好的字符串一次，即使它在 A 中出现多次。 

## 算法讨论

直接枚举A中所有长度为$|B|$的子串，然后检查非？位是否相同，如果相同，那么记作出现一次

# ParenthesesDiv2Medium

## 算法讨论

给定一个括号串，可以翻转某一位的，构造一组方案使得需要翻转的位置最少，并且要求不超过$\frac{n}{2}+1$

## 算法讨论

考虑维护前缀左括号减右括号的数量s，如果某一位$<0$，那么将这一位的$($翻转为$)$

如果最后s不等于0，那么将最后$\frac{s}{2}$个$)$翻转为$($

可以发现，每隔两个最多只有一次翻转，那么是符合条件的

# SegmentsAndPoints

## 题目大意

给定$n$个点，$n$个区间，要求点和区间之间进行匹配，使得每一个区间匹配的点都是在区间范围内的，判断是否合法
$$
n\leq 100
$$

## 算法讨论

考虑从每一个点连向包含这个点的区间

显然连出的图是一张二分图，然后跑二分图最大匹配

如果存在完美匹配，那么是可行的

# DoubleWeights

## 题目大意

给定一张图，每条边的边权为$(a,b)$，定义一个点到另外一个点的距离为两种边权和的乘积，求出0到1的最短路
$$
n\leq 20,a,b\leq 9
$$

## 算法讨论

设$d(i,j)$表示走到第i号点，第一种边权和为$j$的最小第二种边权和

然后就可以进行最短路转移

最终答案就是
$$
\min j\times d(i,j)
$$

# DivFreed2

## 算法讨论

给定$n,k$，求有多少个序列$A$满足数组的长度为 n。 每个元素都是 1 到 k 之间的整数，包括 1 和 k。 只要 A 和 B 是数组的两个连续元素（按此顺序），我们就有 (A <= B) 或 (A mod B != 0)。 
$$
n\leq 10,k\leq 10^6
$$


## 算法讨论

考虑容斥，考虑第三个条件的反面
$$
A>B,B|A
$$
那么注意到方案数至于长度有关，那么可以设$f(i,j)$表示长度为i的序列，最后一位填的是$j$的方案数
$$
f(i,j)\rightarrow f(i+1,jk)
$$
这样的时间复杂度为$O(nk\log k)$

然后枚举哪些位置被钦定不满足条件，处理出来极长连续段的长度，然后将预处理出来的方案数相乘，最后乘上(-1)系数即可

# MoveStonesEasy

## 算法讨论

考虑两个位置之间会被经过多少次

那么就是某一边A的和与B的和差的绝对值

显然可以取到这个上界

那么将所有位置的和求和即可

# TopBiologist

## 算法讨论

给定一个只包含三个字符的字符串，求出最小的字符串，使得不为其子串
$$
n\leq 2000
$$

## 算法讨论

显然答案的上界为6，因为$4^6> 2000$

那么从1开始枚举长度，搜索出来所有的情况，然后如果没有出现就是答案

# BearChairs

## 算法讨论

现在排成一列的椅子，有n个人要就座，第i个人要求坐在编号至少$a_i$的椅子上，并且要求任何两个人编号差的绝对值$\geq d$，在所有合法椅子中找到编号最小的椅子坐下

求出所有人的位置

## 算法讨论

首先假设当前处理到第i个人，那么显然第i个人可能的座位为$pos_j+d,pos_j-d$，还有$a_i$

那么只需要检查这些位置离最近的人距离是否$\geq d$即可

这个可以用set维护位置集合即可，只需要支持查前驱后继

