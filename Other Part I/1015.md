# Defects

## 题目大意

现在给定一个长度为$w$，高度为$h$的长方形，边界上有若干点，给出坐标，求出在边界上的一个点使得到给出点的距离和最大，这里的距离定义为两个方向走到这个另外一个点的距离最小值
$$
w,h\leq 50
$$

## 算法讨论

首先将长方形在$(0,0)$处断开，形成一条链，那么每一个点在数轴上的位置也是可以计算出来的

然后考虑想象一个直接距离为$w+h$的双指针在这条链上不断移动，其中数轴上较大的那个指针代表放置的点，那么可以发现指针之间的点到这个放置点的距离就是向正方向移动，之外的点都是向负方向移动

当这两个指针都不经过任何一个点的时候，会发现如果内部的点数量大于外部点的数量，那么双指针尽量变小是更优的，那么说明最优解一定取在$x_i$，或者$x_i+h+w$的位置上，直接检查这$2n$个位置即可

# Runway

## 题目大意

给定n个区间$[l,r]$，按顺序加入到数轴上，重叠位置是取最后一次加入的区间，加入过后，如果存在**线段（而不是点，The patches题目中代表的意思是线段）**属于某一个区间，那么这个区间需要计入答案

## 算法讨论

注意到值域很小，可以直接暴力修改

由于求的是线段，那么如果$l_i=r_i$就跳过，否则修改$[l_i,r_i)$内的数，记录最后一次覆盖的编号即可

# FirstToLast

## 题目大意

定义$f(x)$为将x的十进制表示的最左边的数字删去，然后加到最右边得到的结果

给定$p,q$，求最小的$x$，使得$f(x)=x\times \frac{p}{q}$

## 算法讨论

假设n表示x的位数，a表示x最高位的数字
$$
f(x)=(x-a\times 10^{n-1})\times 10+a=x\times \frac{p}{q}\\
(10-\frac{p}{q})x=(10^n-1)a\\
x=\frac{q(10^n-1)a}{10q-p}
$$
需要注意的是，**题目要求的是正整数**，所以如果$10q-p\leq 0$，直接返回-1

否则枚举$n,a$，检查解出的x是否符合条件即可

# LazyCat

## 题目大意

现在猫在原点，有n个老鼠，第i个老鼠离猫的距离为$pos_i$，其逃离的速度为$speed_i$，现在有m个帽子，每一个帽子可以被扔出d的距离，如果存在一只老鼠的距离$\leq d$，那么这只老鼠会被抓住，第i帽子扔出后需要休息$rest_i$时间

求最多可以抓到多少个老鼠

## 算法讨论

首先计算出每一只老鼠逃出d范围的时间
$$
t_i=\lceil \frac{d+1-pos_i}{speed_i}\rceil
$$
然后按照时间从小到大排序，然后显然按照rest升序的扔帽子一定最优，所以将rest升序排序

然后rest匹配可以抓到的老鼠中$t_i$最小的，将时间充裕的留到后面再抓，显然这样最优

# PowerDigit

## 题目大意

求出$x^y$的第k位数字

## 算法讨论

等价于求
$$
x^y\equiv ans (\bmod 10^{k+1}) 
$$
直接计算即可，需要判断一下，x需要乘方多少次，才能存在第k位数字，如果不够，那么输出-1，还需要特判x=0的情况



# StepHopJumpMedium

## 题目大意

现在有n个格子，每一个格子如果存在陷阱，那么就不能通过，现在可以从一个格子走到右边的第1，2，3个格子，求从1号格子走到n号格子的方案数

## 算法讨论

设$f(i)$表示走到第i个格子的方案数

- 如果第i个格子不能经过，那么$f(i)=0$
- 如果第i个格子可以经过，那么$f(i)=f(i-1)+f(i-2)+f(i-3)$

# LooRollPyramid

## 题目大意

现在要求将积木搭成$A$层的金字塔，从下往上搭，已经使用了B个金字塔，求最少还需要多少个积木，使得当前这一层搭满
$$
A\leq 10^9,B\leq 10^{18}
$$

## 算法讨论

首先需要判掉$B=0$的情况

那么从下往上x层需要积木数量为
$$
A+A-1+A-2+...+A-x+1=\frac{(2A-x+1)x}{2}
$$
那么可以二分出最小的x使得$\frac{(2A-x+1)x}{2}\geq B$

那么答案就是$\frac{(2A-x+1)x}{2}-B$

# MarsHabitats

## 题目大意

现在要求构造一张n个点的无向图（可以存在自环和重边，边有边权），要求每一个点的度数恰好为3，并且需要满足给出从0号点到每一个点的距离

## 算法讨论

首先由于一个点要么有一条边连向其他点，要么有三条边连向其他点，那么说明如果n为奇数，那么就一定不满足这个每一个点恰好度数为3的限制

那么只需要考虑n为偶数的情况

那么可以考虑构造树的情况，并且深度较深的节点的最短路大于深度较浅的节点的最短路长度，那么首先将所有节点的最短路升序排序，然后将前3个连向0，后面每两个为一组，连向之间的节点即可，至于两个点之间边的边权就是两个点最短路距离之差

# CircularParking

## 题目大意

现在有n个格子的环形停车场，给定$A,B,C$，那么第i辆汽车最先到达$(Ai^2+Bi+C)\bmod n$这个位置，然后如果这个位置存在汽车，那么走向下一个位置，直到走到空车位

求所有车走过距离之和

## 算法讨论

首先破环成链，然后将数组复制一遍，然后按照这个计算过程求出第i个位置，然后用树状数组维护一段区间是否存在空车位

然后二分需要走过的长度，用树状数组检查二分范围之内是否有空车位即可

时间复杂度$O(n\log ^2n )$

# JoinAClub

## 题目大意

现在有n个人，每一个人可以先创建一个俱乐部，然后邀请一个朋友加入，然后不断重复邀请的过程，求出一个俱乐部最多可以有多少个人

并且构造邀请顺序

## 算法讨论

如果将朋友关系建边，那么答案就是最大的联通块大小，至于构造顺序就是可以用dfs序即可

**需要注意的是n的范围有500而不是50，需要开大数组**

# SimilarDNA

## 题目大意

给定两个字符串$s,t$，判断最小编辑距离是否小于等于2

## 算法讨论

设$f(i,j)$表示s前i个字符形成的子串，与t前j个字符形成的子串的最小编辑距离
$$
f(i,j)=\min(f(i-1,j-1)+[s_i\neq t_i],f(i-1,j)+1,f(i,j-1)+1)
$$
直接进行转移即可

时间复杂度$O(n^2)$

# IOISureWinner

## 题目大意

现在有n个问题，第$i$个问题的分数为$a_i$，解决的概率为$p_i$，求使得最终分数至少为$m$的概率
$$
n\leq 50,\sum a_i\leq300 
$$


## 算法讨论

考虑进行背包，设$f(i,j)$表示前i个问题中，获得的分数为j的概率
$$
f(i,j)=p_if(i-1,j-a_i)+(1-p_i)f(i-1,j)
$$
那么时间复杂度$O(n(\sum a_i)^2)$

# LimitedDifferences

## 题目大意

给定一个长度为n的序列S，定义$D(s)$为长度为$n-1$的序列，$D(s)_i=|s_i-s_{i+1}|$

给定$n,V$要求构造一个长度为n的排列序列$s$，使得$D(s)$中只存在$V$种不同数字

## 算法讨论

考虑这个V种不同数字为$1,2,...,V$

考虑将差分数组设为$+1,-2,...,(-1)^{V+1}V$

然后令$s_i=1$，可以发现$s_{1...V}$是构成了一个V的排列，就完成了D(S)存在V种不同数字的要求，那么剩下的数字按照最简单的方式差为1排列即可

就是对于$i>V,s_i=i$

# CubeTower

## 题目大意

要求将h分成n个正整数的和，定义一种拆分的方式的代价就是所有正整数的立方和，求所有方案代价最大值减代价最小值
$$
h,n\leq 10^6
$$

## 算法讨论

由于代价与数量不是线性关系，那么显然最大的方案就是将h拆成$n-1$个1和一个$h-n+1$最优

而最小方案就是将$h$尽量平均拆到这$n$个数里面

直接计算差就可以了

# MarriageAndChargingChallenge

## 算法讨论

现在给定长度为$L$的环，环上有n个特殊点，可以再这里获得$a_i$点分数，但是每走一个单位长度需要花费一点分数，一开始点数为0，求有多少个出发点出发可以走完一圈

## 算法讨论

首先由于一开始的点数为0，那么初始点一定在这个n个特殊点中

然后可以断环成链，将数组复制一份，不过复制这一份的坐标需要$+L$，然后可以方便的进行计算

# PoisonedSwamp

## 题目大意

给定$n\times m$的网格，要求从某一个格子出发，网格上最多有一个金币，网格上还可能存在陷阱，用数字1-9表示，上面的数字表示走到这个陷阱失去的生命，如果失去的生命$\geq 10$游戏结束，还存在$S$表示走到这个格子上可以获得所有失去的生命，求最终是否能获得这个金币

## 算法讨论

设$f(x,y,d)$表示当前在$(x,y)$失去了d点生命是否可行

转移直接dfs枚举下一步走到哪个位置，然后将生命值按照这个格子的效果进行加减，如果$d\geq 10$，那么就不需要继续dfs，如果已经枚举过也不需要继续

这样就可以保证dfs次数等于状态数

# TheQuestForGold

## 题目大意

给定$n\times m$的网格，图上有恰好一个终点起点，若干陷阱，主角不知道陷阱的位置，但是如果走到一个陷阱的周围4个格子，那么就会知道周围存在陷阱，问最终主角是否可以到达终点

## 算法讨论

首先如果进入了一个周围存在陷阱的格子，那么显然不会再往前走，只会原路返回

那么在dfs过程中遵循这个规则即可

只需要看最终终点是否被遍历到了

# PlanningTrips

## 算法讨论

给定n个数，底数a，第i个数为$a^{num_i}$，求最小的k，满足$a^k\geq \sum\limits_{i=1}^n a^{num_i}$
$$
a,num_i\leq 10^9
$$


## 算法讨论

首先可以用map记录每一个指数存在多少个，然后需要考虑进位的情况，从小到大枚举存在的指数，如果指数前面的系数$\geq a$，那么就是存在向下一位的进位

如果最终处理完进位之后，所有指数前面的系数和$=1$的话，那么答案就是最大指数，否则就是最大的指数+1

**一开始的时候是判指数前面系数$>0$的个数=1，就是最大指数，有可能最大指数之前的系数为2，答案就出错了**

# LogiciansAndBeer

## 算法讨论

如果一旦出现了-，那么后面所有人都需要说-，否则就是不合法，因为只要存在一个-就说明至少有一个人不要啤酒

那么所有的？和+都是在-之前出现

由于+是确定所有人的情况，那么只能在最后一个位置出现，那么这种情况就是前面全部都是？，最后一个+，显然答案就是总人数

否则给出合法的字符串就是形如$?????....----$的样子，不会出现+，因为前面的人不知道后面的人的情况

那么最小答案就是前缀？的值，因为如果？自己不要啤酒，那么他就得到足够的信息说出-

# OrganicChemistry

## 题目大意

现在有三种原子，HONC，分别需要有1，2，3，4个化学键，现在抹去了所有的氢原子，给出其余原子的成键情况，求需要补上多少个氢原子

## 算法讨论

答案显然就是将化学键建出的图中，一个点需要化学键数-在图上的度数

# ChristmasLightsFixing

## 题目大意

现在有1到n的有序序列，求字典序第k小的子集

## 算法讨论

首先一个大小为m的子集方案数为$\binom {n}{m}$

根据这个求出第k小的子集大小为多少，就是找到组合前缀和一个大于k的位置s

然后从前往后一位一位确定，比如当前子集中第i个，强制选择第j个位置的方案数为$\binom{n-j}{s-i}$

也是按照同样的方法确定

# VertexMove

## 题目大意

现在有三边长为a,b,c的三角形，将某一个点移动1单位长度，求最大面积

## 算法讨论

画一下图会发现，显然移动的方向与该顶点到对应边的高所有直线一致

那么根据几何知识可以简单解出高，求出贡献

# RearrangePages

## 题目大意

给定n，保证n为偶数，其中$\frac{n}{2}$页为图片，要求排到1,3,5...页上，另外的排到0,2,4...页上，每一次只能交换相邻的两个位置，求最小交换次数

## 算法讨论

首先将每一页的对应关系求出，然后答案就是对应关系那个排列的逆序对个数

对应关系显然不会有跨越的情况，那么依次对应即可

求逆序对个数可以用树状数组求

时间复杂度$O(n\log n)$

# JumpAcrossTheRiver

## 题目大意

现在有n+1个位置，第0个位置在坐标原点，给出i与i+1的距离差，只能停留在这些位置上，每一个可以跳不超过m的距离，求最小的m使得在不超过k次的跳跃从0跳到n

## 算法讨论

首先二分m，然后设$f(i)$表示跳到第i号点，至少需要的步数
$$
f(i)=\min\limits_{d_i-d_j\leq mid} f(j)+1
$$
那么可以用过单指针对于每一个i求出最小满足条件的j，然后注意到贡献只和$f(j)$有关，那么可以直接单调队列优化即可

时间复杂度$O(n\log d)$

# IncreasingJumps

## 题目大意

给定n个青蛙的位置，要求他们跳成连续的一排位置，第i次操作可以指定一个青蛙向左或者向右跳i的距离，构造一组方案

要求操作次数$\leq 1000$
$$
n\leq 10,a_i\leq 50
$$


## 算法讨论

首先将所有青蛙按照位置坐标排序，那么我们最终构造的位置就是$a_n-n+1,...,a_n$，那么可以知道每一个青蛙需要跳到的位置，进而算出相差绝对值$d_i$

那么可以找一个最小的$x$满足$x,x+d_i$都没有被用过，然后根据$d_i$的正负性确定第$x,x+d_i$次操作将第i个青蛙向哪个方向跳

可以对于前n-1个青蛙都这样进行

由于不能存在操作序列中的操作不对任何一只青蛙进行操作，那么就需要将不用的操作正负交替作用在第n只青蛙上，然后利用后面+-交替替换调整即可



