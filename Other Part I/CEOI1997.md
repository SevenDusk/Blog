

# Hexadecimal Numbers

## 题目大意

假设集合$S$中的所有数在$16$进制表示下，最多有$8$位，且每一位上的数字都是不同的

求出这个集合$S$中第$n$大的数

## 算法讨论

可以从高位向低位确定，假设当前是确定到第$i$位，并且已经使用了$j$个不同的数字，那么剩下位置所有可能方案数就是$A_{8-i}^{16-j}$，比较一下当前$n$是否大于这个值，如果大于那么说明这一位还可变得更小，那么就向下减1

需要特殊注意的是，如果存在前导$0$，是不能算作出现的数字的，每一判断的时候需要算出当前前导$0$的个数，然后才能统计出现过的数字

第一次提交:AC

# Integer Intervals

## 题目大意

给出$n$个区间，现在需要选出一些点，使得所有区间至少覆盖了2个点，求选出的最少点集
$$
n\leq 10000
$$

## 算法讨论

这种区间覆盖的问题，一般来说都是将区间按照右端点排序，当将右端点移动+1的时候，最优的方案就是放在

$i$这个位置上，如果不够再往前替补

可以证明这样一定最优，证明都是类似的

证明：就是由于是按右端点排序的，那么当前找到右端点为i的区间时，只有$\leq i$的位置上会被覆盖到，如果当前不选，留给后面的区间选，由于区间是连续的，即使没有覆盖到当前这个位置，相对靠后的位置也会被覆盖到，对之后的区间影响只会不会更优，如果覆盖到这个位置，改为当前这个区间显然更优

实现的时候不需要将区间存下来，由于值域很小，直接利用桶进行统计就可以了

时间复杂度$O(n)$

第一次提交:AC

# Dominoes

## 题目大意

现在每一个位置上有两个数$(a_i,b_i)$，上面是$a_i$，下面是$b_i$，可以将一些位置上下数交换，然后使得上面数之和与下面数之和的差的绝对值最小，求最小交换次数
$$
n\leq 1000,0\leq a_i,b_i\leq 6
$$

## 算法讨论

很裸的背包题

假设现在对上面的数进行背包统计,$dp(i)$表示上面的数和为$i$的时候，最小的交换次数
$$
dp(i)=\min(dp(i-a),dp(i-b)+1)
$$
**在转移的时候需要注意$a,b$有可能等于$0$，使用滚动数组的时候，不能先将$dp(i)=inf$​，需要用一个变量记录这次转移的结果（错误点）**

第一次提交:Wrong Answer

# River Crossing

## 题目大意

河中有$n$个柱子，每一个柱子都会周期性的上浮和下沉，周期的前$a_i$时间是上浮的，后面$b_i$的时间是下沉的

一个人可以跳到周围$5$个柱子上，左岸为$0$，右岸为$n+1$​，求出到达右岸的最小时间
$$
n\leq 1000,a,b\leq 5
$$

## 算法讨论

注意到$a,b$​很小，又是跟取模相关的，并且上一段与下一段不是连续的，那么可以自然的想到，可以利用所有位置的$a+b$​的$lcm$（1到10的lcm为2520）​​为一个大周期，利用这个周期进行取模

如果DP的话，设$dp(i,j)$​表示到第$i$个位置时，时间模$lcm=j$的最小时间，稍微推一下转移式子会发现，跟有没有取模并没有关系，并且考虑在lcm附近的那个周期，所有位置都沉下去的，那么相当于就是隔绝了前一个大周期和后面一个大周期的关系，那么答案最大为$lcm$

那么就枚举答案，同时维护当前时间可以到达哪些位置，如果可以到达就是输出答案

时间复杂度$O(2520n)$

第一次提交：AC

# Shooting Contest

## 题目大意

每一列有恰好两个白色格子，现在需要从每一列中选出一个白色格子，使得每一行都有格子被选，构造一组方案
$$
n\leq m\leq 1000
$$

## 算法讨论

显然的矩阵选数模型，对每一行建立点，每一列建立点，然后如果存在白色格子，就将对应的行点和列点连起来，得到的图就是一个二分图

由于每一行必须有一个选，那么这个二分图的最大匹配数量$=n$

然后剩下没有匹配的列点，就任意选

时间复杂度$O(n\sqrt n)$

第一次提交:AC

# The Cave

## 题目大意

给定一张图，分成外层内层，外层有$k$​​​个点，并且是一个环，然后每一个点恰好有三个边，并且所有边不在顶点相交，边有0/1的边权，构造一个哈密顿回路并且满足边权和最小，**保证去掉只连接外层节点的边得到的图就是一个二叉树**
$$
n\leq 500
$$

## 算法讨论

假设先不管外层的边，那么可以发现所有外层节点就是树上的叶子，那么一个大致思路就是利用叶子之间的边来从不同的子树跳到另一个子树

接下来两个思路开始分叉

### Solution 1

考虑外层的环到底有什么用，一个最简单的猜想就是构造出来的哈密顿回路就是沿着这个环的顺序进行走，然后中间穿插一些内层节点的路径，我一开始认为这个结论是错的，后来发现有所有路径不相交这个条件，那么不可能存在跨过一个外层节点的情况

那么外层节点的顺序就可以确定了，然后就是确定内层节点的顺序，由于只能是相邻两个环上的位置通过树上的路径走，那么所有可能的路径只有k条，那么就需要利用这k条路径覆盖所有树上节点

同时题目需要保证边权最小，由于如果选择走树上的路径，那么一定不会经过环上的路径，那么不妨让所有路径的权值和减去环上这条边的权值，作为这条路径的价值，然后利用这个价值进行DP

设$dp(i)$表示$i$子树中所有内层节点都被覆盖的最小权值和，转移的时候枚举所有LCA在i的路径，然后将子树内不在路径的最高点所有dp和加起来，在加上这个路径的权值进行更新

需要注意一点，1号节点需要特殊处理，枚举两边的是否走树上或者环

输出方案的话，在DP过程中记录，最优方案下选用的是哪条路径，那么输出直接暴力在树上跳就可以了

至于DP的实现方式，我一开始写的是$O(n^2)$，就是路径起点不断跳到$LCA$​，事实上可以通过在DP的过程中，求出每一个节点去除一个儿子覆盖的最大价值（由于只有2个儿子，只要分别求就可以，好像也可以扩展到不是二叉树的情况），然后求一个前缀和，然后就可以做到$O(1)$转移

### Solution 2

另一种方案事实上是差不多的，但是实现起来更简单

我理解的就是，先将所有叶子节点根据环上的顺序进行排列，然后相当于dfs的时候从左往右进行枚举，然后可以发现，一个节点要么从左儿子进来，然后右儿子出去；从根进来，从左儿子或者右儿子出去

那么就可以用DP统计了

$dp(x,0/1/2)$表示x子树完全被覆盖，左儿子还没有被覆盖，右儿子还没有被覆盖，的权值最小和

然后输出方案的话，对于每一个DP状态记录转移过来的状态是哪一个，然后倒推回去

时间复杂度$O(n)$

