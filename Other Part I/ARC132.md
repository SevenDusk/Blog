# **Between Two Binary Strings**

## 题目大意

给定两个01个数相等的01串，然后现在可以交换两个位置，记$dis(s_1,s_2)$表示将$s_1$变成$s_2$的最小操作次数

然后如果$dis(s_1,s_3)+dis(s_3,s_2)=dis(s_1,s_2)$，那么称$s_3$是在$s_1,s_2$之间，求所有合法的$s_3$相邻两个位置相同的最大数值
$$
|s|\leq 3\times 10^5
$$

## 算法讨论

考虑如果将$s_1$转化为$s_2$

相当于将所有$s_1$中的1与$s_2$中1的位置进行配对，假设$i$位置上的1对应着$p_1$，然后$dis(s_1,s_2)$就是$\sum |i-p_i|$

那么一个经典的做法就是，记录两个串前缀的1的个数差$d$(s-t)，考虑每两个相邻位置被多少$a_i$个1经过，那么就是$a_i=|d|$，也可以根据d的正负确定1经过的方向

对于极长的连续$a_i>0$的段，那么相当于要将这一段的1不断向后移动

**那么这里就需要注意到，在这一段中s串的1个数的前缀是不断减少的，并且最终是减少到t串的1出现次数的前缀**

对于$a_i<0$的段也是同理，不过此时前缀是不断增加的

由于所有合法的中间串都是在移动的某一个时刻，那么说明其1的前缀和都是在s,t的前缀和之间

假设s,t的前缀和记作$s_i,t_i$，中间串的前缀和$x_i$

那么需要满足$x_i\in [\min(s_i,t_i),\max(s_i,t_i)]$

由于我们需要最大化相邻两个位置相同的数量，那么我们考虑构造的中间串是尽可能不要改变出现的字符

那么就是不断填某一个字符，直到某一个位置不满足条件就替换成另一个字符即可

### Solution 2

首先对于$s_1,s_2$来说，其01对应的位置是不变的，然后01之间的相对顺序会发生改变

对于发生改变的01相对顺序来说，在过程中可以做到任意一种顺序（在不改变0内部的顺序和1内部的顺序的前提下）

那么可以将原来0序列分成若干段，也可以确定1在哪一段，在段内可以任意插入

那么我们需要最小化最终的连续段数量，如果插入的段是开头或者结尾代价为1

否则代价为2

那么贪心的做法就是将所有区间按照右端点排序，然后不断贪心的加入即可

然后需要按照第一个位置是否插入1进行分类讨论



比赛的时候都在往一个方向思考，就是在将$a_i$按照正负性分段之后讨论相邻两端开头和结尾的字符，并且在固定字符之后最小化段内01连续段个数，但有很多种情况，每一种情况都是很多的特殊情况，没有换一个角度想，要注意到所有合法的串本质是什么，用一个简单的条件进行刻画，一开始的方向是错误并且很复杂的，导致后面一直在原地转，在一定时间之后应该跳出这个方向，在最开始的做的时候有没有其他的入手点/特殊性质

前10做法

Solution 1: tourist,aaa1a,SSRS

Solution 2:qazswedx,jiangly,Alan_boyfriend,rainboy,Mr_Eight,tzxydby

# **Paw**

## 题目大意

现在给定一个长度为n的串，其中元素有.<>三种，不断进行如下操作

- **随机选择一个.**然后在随机选择向左向右两个方向走，如果向左走，那么将走过的格子变成<，如果向右走，那么将走过的格子变成>，直到走到边界或者走到另一个.

求最终得到序列的<的期望
$$
n\leq 10^5
$$

## 算法讨论

首先由于上一次选择的走过的路径可能被后面的覆盖掉，那么可以考虑**倒过来**考虑，那么当前走过的位置就直接确定为最终的结果

首先考虑最后一个.显然这个要么将一个前缀变成<要么将一个后缀变成>

假设将后缀变化了>，那么在这个后缀中其他的.如果要向左走，那么会遇到最后一个.就会停下，不会再修改之前的位置

**那么就可以发现这些操作最终的影响就是将一个前缀变成<，将一个后缀变成>，并且这两个前缀和后缀的起始位置就是两个相邻的.，而这两个相邻的.中间的位置都是不会被经过的**

假设.的个数有k个，那么最终状态种类只有k+1种

考虑第i个.位置与$i+1$个.位置之间的贡献，假设其位置分别为$p_i,p_{i+1}$

那么最终会将$[1,p_i]$这些位置变成<，将$[p_{i+1},n]$这些位置变成>，对于$(p_i,p_{i+1})$这些位置是不变的

那么我们现在需要算出这种情况的概率

考虑过程中$[1,p_i]$还剩下$k$个.没有被选过，那么在这里面选出的一个位置的方案数是k，每一个位置有两种情况，那么总的方案数就是2k，但是由于当前最后一个位置不能向右走（否则就会将$(p_i,p_{i+1})$内的位置进行修改），那么合法的方案数就是$2k-1$

而左右两边的概率是独立的

那么概率就是
$$
\prod \limits_{k=1}^{i} \frac{2k-1}{2k}\times \prod \limits_{k=1}^{cnt-i} \frac{2k-1}{2k}
$$
然后将概率乘上<的个数即可

时间复杂度是$O(n)$的



在算概率的时候有一种递推的实现方法，就是可以递推出当前位置是>的概率和保持不变的概率，然后就可以求出<的概率

记$f_s=\binom{2s}{s}\binom{2cnt-2s}{cnt-s}$

如果$i\bmod 2=1$，那么$stay=f_s$，其中$R_i=R_{i-1}$

然后如果i是2的倍数，那么就需要将$R_i$加上上一个保持不变的概率（因为此时后缀都是变成>）

https://atcoder.jp/contests/arc132/submissions/28176272

我一开始没有发现这些的操作的最终影响是什么，而是按照倒过来做的思路列出比较复杂的式子，并且复杂度难以降低，应该去想一下最终状态的形式

https://atcoder.jp/contests/arc132/submissions/28172821

