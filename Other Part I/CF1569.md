# A.Balanced Substring

## 题目大意

给定$n$字符串，只包含a,b求出一个子串满足a,b数量相同

## 算法讨论

统计前缀和，然后枚举即可

时间复杂度$O(Tn^2)$

# B.Chess Tournament

## 题目大意

有n个进行比赛，两两会进行一场比赛

现在有两种人

1.要求不输任何一场比赛

2.要求至少赢一场比赛

构造一种比赛结果满足所有人的要求

## 算法讨论

首先如果没有2，那么所有人平局即可

那么2只能赢2的人，那么2要么没有，要么$\geq 3$

那么2之间赢一场即可

# C.Jury Meeting

## 题目大意

现在有n个数，每一轮按照排列$p$的顺序，给每一个数减一，如果当前的数$=0$则跳过

要求计算有多少个$p$满足不存在某一个数被连续减去了1
$$
n\leq 10^5
$$

## 算法讨论

首先如果存在$\geq 2$个最大值（就是数值相同的最大值），那么显然所有排列合法

那么考虑只有唯一的最大值$MAX$的情况，考虑次大值$a$

如果$a<MAX-1$的话，进行$a$过后场上只剩了一个$MAX-a$非零的数，并且$MAX-a\geq 2$，那么就会连续进行两轮，不合法

那么$a=MAX-1$，那么显然最大值不能放在所有次大值之后，如果有$b$个次大值，那么方案数就是
$$
n!-A_{n-b-1}^nb!
$$
时间复杂度$O(n)$

这个模板

```c++
// assume -P <= x < 2P
int norm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, int b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(norm(x)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(norm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
};
```

norm表示将x的范围限制到$[0,p-1]$中

pow进行快速幂

结构体Z中重载对应的四则运算

# D.Inconvenient Pairs

## 题目大意

现在有一个大小$10^6$的网格，其中有n个竖线是可以走到的，m个横线是可以走的，给出k个网格上的坐标，求出其中有多少对$(a,b)$，a到b的最短路不等于其曼哈顿距离
$$
n,m\leq 2*10^5,k\leq 3*10^5
$$

## 算法讨论

首先每一个点至少被一个道路经过

如果某一个点被两条道路经过，那么这个点到任意一个点的距离都是等于其曼哈顿距离

那么现在只需要考虑被一条道路经过的点

首先如果一个点是被横向道路经过的和另一个被竖向道路经过的点，其距离就是曼哈顿距离，所有不用考虑两种点之间的贡献

那么只需要单独考虑其中一类即可

以点被竖向道路经过为例

两个点之间的距离为曼哈顿距离当且仅当两个点之间存在一条横向边，那么只需要将所有横向边和这些点的纵坐标一起排序，两条横向道路的之间的点，互相距离不等于曼哈顿距离

只要扫描过去就可以了

时间复杂度$O((m+n+k)\log k)$

# E.Playoff Restoration

## 题目大意

现在有$2^k$个队伍进行比赛，每一场比赛会决出一个胜利者，失败者淘汰，总共会进行$2^k-1$轮比赛，现在给所有队伍排名，其中在决赛获胜的队伍排名1，在决赛淘汰的额队伍排名2，在半决赛淘汰的队伍排名3，$\frac{1}{4}$决赛淘汰的队伍排名5，依次类推

现在给定A，设第i个队伍的排名为$p_i$，定义$h=(\sum\limits_{i} iA^{p_i})\bmod 998244353$

给定$k,A,h$要求还原出一组合法的排名

![img](D:\Blog\image\18b75d06ee089381d70fde549f3e24a74f392cb9.png)
$$
k\leq 5
$$

## 算法讨论

首先将$h$除以$A$，使得排名变为0,1,2,4,8,16

首先由于$2^k\leq 32$直接枚举每一场比赛的情况显然不可行，但是注意到$2^{k-1}\leq 16$，**枚举每一场比赛的情况就可以了**

那么考虑将最初一轮比赛和后面的比赛分开考虑，那么后面一轮的比赛就是$2^{k-1}$个队伍比赛，考虑直接枚举每一场比赛的结果，然后对于第$i$支参赛队伍求出其排名为$p_i$

显然第$i$个参赛队伍是从最初的$2i,2i-1$中的一个，如果是$2i$

那么贡献是$2iA^{p_i}+(2i-1)A^{2^{k-1}}=2i(A^{p_i}+A^{2^{k-1}})-A^{2^{k-1}}$

如果是$2i-1$，那么贡献为$2iA^{p_i}+(2i-1)A^{2^{k-1}}=2i(A^{p_i}+A^{2^{k-1}})-A^{p_i}$

注意到只有后面减去的部分不一样，并且所有$p_i$组成的集合是固定，那么说明与$i$无关，$A^{2^{k-1}}$也是固定的，那么首先预处理出来所有情况的贡献，令最初$a=\{0,1,2,2,4,4,4,4...\}$，然后枚举每一位是$A^{2^{k-1}}$还是$A^{a_i}$，将和存到unordered_map中，

那么利用之前求出的$p_i$，算出$sum=\sum\limits_{i=1}^{2^{k-1}}2i(A^{p_i}+A^{2^{k-1}})$

在unordered_map中查询$sum-h$，得到预处理结果，对每一位按照$p_i$的数值还原即可

求出$p_i$的过程就是可以建出树，然后dfs一遍求出每一个节点被淘汰的队伍即可

另一种方法同样还是要折半，但是可以直接枚举每一个人的排名情况，因为本质不同的方案数量是不多的，那么就全排列枚举就可以了

并且要对两种情况分类讨论，讨论一下冠军的位置

https://codeforces.com/contest/1569/submission/128239230

**分离变量$i$，使得只有顺序的问题，枚举的量都是固定，然后才能进行折半搜索的思想**

# F.Palindromic Hamiltonian Path

## 题目大意

给定一个$n$个点$m$条边的无向图，要求给每一个点表一个字母，字母的为前$k$个小写字母，求有多少种方案使得，图中存在一条哈密顿回路，使得按照顺序写下的字符串组成了一个回文串

保证$n$为偶数
$$
n\leq 12,k\leq 12
$$

## 算法讨论

首先考虑得出节点之间是否相等的关系，那么显然在一个回文串里面位置对称的两个节点上的字母一定是相同的，那么相当于是形成了一个匹配的关系

那么去枚举这样的关系，假设左边节点集合为$a$，右边节点集合为$b$，表示$a_i,b_i$号节点在回文串中位置是对称的，为了避免重复我们假设$a_i<b_i$（Important!!，一开始没有管这个，需要多枚举一个阶乘的复杂度，后面的DP事实上可以处理顺序的问题，从2800ms 直接变成150ms）

那么合法的哈密顿路径就可以用一个DP求出是否存在，设$dp(s,i)$表示当前已经经过集合$s$中的匹配对，当前在$i$匹配对，令$ok_{i,j}=(mp_{a_i,a_j}\and mp_{b_i,b_j})\or(mp_{a_i,b_j}\and mp_{b_i,a_j})$（这里有两个条件就是可以处理顺序的问题，一开始只写了前半段）

转移就很简单了，枚举没有出现过的点$j$，如果$ok_{i,j}=1$那么就可以转移

那么判断一个匹配是否合法就可以在$O(2^{\frac{n}{2}}n^2)$的时间内做完

然后考虑染色，由于可能存在多个对都是染同一个颜色的，相当于将这些对进行分组，如果分成了$k$组，那么方案数就是$A_{k}^n$，由于可以会有重复，那么就需要枚举哪些对要染同一种颜色，将方案搜索出来，一个麻烦的地方就是如何判重，对于组形成的集合我们需要进行集合hash，就是对于所有可能的组给其赋值一个随机的64位整数权值，一个集合的Hash值就是所有元素的权值的异或和	

考虑$dfs(s,h,cnt)$表示当还有集合$s$的对没有决定，前面已经确定的染色Hash值为$h$，已经分了$k$个组，由于要避免重复枚举，那么强制当前$s$中最大的那个选在当前组，然后枚举子集转移即可

时间复杂度$O(\binom{n}{\frac{n}{2}}(2^{\frac{n}{2}}n^2+(\frac{n}{2})!))$

一些细节差异：

- 对于去重的过程要么手写Hash表或者用vector存下来排序
- 得到$a,b$的过程可以用搜索的方式得到，就是记录当前还没有进行匹配的点集，然后强制选标号最大或者最小的点，枚举匹配点即可，这样就可以避免枚举排列的无用枚举

https://codeforces.com/contest/1569/submission/128239230

**处理重复计算本质相同的问题可以钦定选择最大或最小，确定大小关系**

1.为了避免重复我们假设$a_i<b_i$

2.由于可能存在多个对都是染同一个颜色的，相当于将这些对进行分组，如果分成了$k$组，那么方案数就是$A_{k}^n$，由于可以会有重复，那么就需要枚举哪些对要染同一种颜色，将方案搜索出来，一个麻烦的地方就是如何判重，对于组形成的集合我们需要进行集合hash

3.强制当前$s$中最大的那个选在当前组

