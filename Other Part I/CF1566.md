# F.Points Movement

## 题目大意

现在数轴上有$n$个点，$m$个区间，每一次操作可以将n个点中的一个向左或者向后移动一格，要使得所有区间至少在某一时刻覆盖了某一个点，求最小操作数
$$
n,m\leq 2*10^5
$$

## 算法讨论

首先可以去掉已经覆盖了点的区间，然后可以发现如果存在一个区间完全包含了另一个区间，那么可以去掉大的区间

那么剩下的区间如果按照左端点排序其右端点是递增的，剩下的点都是在区间之间的空隙中，那么可以找到这个点到下一个点之间的所有区间，将左端点比第$i$个点$a_i$大第一个区间记作$pos_i$

### Solution 1

可以发现对于任意一个点其去走过的范围一定是原区间序列中的一个区间，那么可以设$dp(i)$表示第$i$个区间之前的所有区间都已经走到过了的最小操作数

考虑如果一个点$a_i$既要向左走到$l$又要向右走到$r$，最小的操作数应该是
$$
\min(2(a_i-l)+r-a_i,a_i-l+2(r-a_i))
$$
如果只需要往一个方向走，那么只要求距离就可以了

从小到大考虑点，那么显然这个点向左走的的范围为$[pos_{i-1},pos_i]$，向右走的范围为$[pos_i,pos_{i+1}]$，那么只需要在向左走的范围记录上面两个值的最小值，然后向右更新的时候取$\min$就可以了

[Argentina Submission #128649875 - Codeforces](https://codeforces.com/contest/1566/submission/128649875)

ID [Argentina](https://codeforces.com/profile/Argentina)

### Solution 2

大体思路跟Solution 1 类似，但是是枚举被点分成了若干段的区间，比如说$a_i,a_{i-1}$之间的区间集合为$s_i$，其中$s_i$需要包含$[a_i,a_i],[a_{i-1},a_{i-1}]$，然后考虑设$dp(i,0/1)$表示第 i个点向左边走1次还是2次的最小操作数

然后枚举之前状态是走了几次，当前走到哪里即可转移

[Jiangly Submission #128630650 - Codeforces](https://codeforces.com/contest/1566/submission/128630650)

ID [jiangly](https://codeforces.com/profile/jiangly)

缺点：比赛的时候没有调出来，一开始想的第一个做法非常复杂，后面再想更简单的做法，虽然简单了一点但还是有很多细节（说明可能还要继续思考简化细节），有一个细节写代码的时候忘记了，在思考的过程中是想到了，但是没写到草稿纸上，导致写到那部分代码的时候忘记了这个细节，然后写代码的时候速度比较慢，可能写的时候比较急导致好几处变量名字打错，查了挺久的

# G.Four Vertices

## 题目大意

给定$n$个点$m$条边的无向图，有$q$个操作，每一次可以加上一条边或者删去一条边，每一次操作完都要选出四个不同的点$a,b,c,d$，使得$a$到$b$的最短路加上$c$到$d$的最短路之和最短
$$
n,m,q\leq 10^5
$$

## 算法讨论

首先至少$(a,b),(c,d)$中至少有一个路径的长度为$1$，否则肯定可以缩短其中某一个的长度

- 如果$(a,b),(c,d)$的长度都为1，那么相当于是选出两条没有公共端点的边，使得其边权和最小
- 假设$(a,b)$的长度为1，$(c,d)$的长度大于1，如果$(c,d)$路径中不含$a,b$，那么一定可以缩短成长度为1的路径，转化为第一种情况，如果包含一个点，那么显然可以缩成长度为2的路径，如果包含两个点，那么总路径可以拆分成两个长度为1的路径，转化为第一种情况

那么最优解有两种形态，一个是一个点上挂三个其他的点，一个是选出两个没有公共端点的边

第一种情况可以对于每一个点用set维护有这个点为端点的所有边，将这个set记作$s_i$，然后每一次选出前三小的边权，放到一个set中，加入或者删除边的时候，更新两个端点的边set，然后在更新答案的set即可

主要是第二种情况比较麻烦

### Solution 1

如果我们把所有当前存在的边按照边权排序，考虑边权最小的边$(u_1,v_1)$，找到边权最小的边$x$，使得$(u_x,v_x)$和$(u_1,v_1)$没有公共端点，那么对于其他的选边方案，比如选择$a,b$两条边（这里是其权值排名），显然$a,b\geq 1$，如果$b\geq x$，那么一定不优，那么$1< a,b< x$

由于在区间$(1,x)$中每一条边都跟第一条边有公共端点，那么只需要考虑$u_1,v_1$端点的之前维护的$s_{u_1},s_{v_1}$即可（需要将第一条边先删除），显然选择只有三种情况

- $s_{u_1}$的最小边和$s_{v_1}$的最小边
- $s_{u_1}$的次小边和$s_{v_1}$的最小边
- $s_{u_1}$的最小边和$s_{v_1}$的次小边

这样保证其中至少有一组组合是合法的

那么剩下的就是如何求出$x$

#### Part I

可以考虑，二分答案，假设当前二分的是$k$，那么$s_{u_1},s_{v_1}$在当前权值小于$k$分别有$x,y$个，如果$x+y-1=k$，那么说明$k$可以需要变的更大，否则会需要变小

这个可以通过对于每一个端点维护一颗平衡树实现，或者离线下来对于每一条边确定其在所有边的相对大小和出现的时间，然后相当于是求一个二维偏序，由于需要套一个二分，时间复杂度就是$O(n\log ^2n)$的

[Subconscious](https://codeforces.com/contest/1566/submission/128678255)

#### Part II

需要用一个重要结论：**可以发现如果只保留每一个端点的前三小的边，那么答案不会发生改变**

考虑某一个点$x$，如果选择的边有一条的端点是x，如果另一条边不会产生公共端点，那么显然一定是在前三条边中，如果会产生公共端点，那么可以调整成另外一个没有公共端点的，由于有三条是一定可以调整成功的

那么就不需要二分x了，因为如果存在x，那么中间最多只有$6$条边，可以直接暴力枚举

需要注意的是，保留的边是必须在两个端点上都是在前三之内的，只适用于求x，其他部分不变

[Kirill22](https://codeforces.com/contest/1566/submission/128702053)

### Solution 2

根据刚才Part II和Solution 1的结论，我们进一步发现，只有保留边中边权前6大的边是有用的，那么我们可以建立一个数组存储这些边，然后这个是可以动态支持插入的，但是不支持删除

每一次插入，之后先将数组按照边权排序，然后记录每一个端点的度数，从前往后扫描，如果加入当前边使得度数>3的话，那就跳过当前边，然后查看当前数组大小是否$>6$，如果$>6$去除末尾的元素

由于不支持删除，那么就需要线段树分治即可，避免删除

[maroonrk](https://codeforces.com/contest/1566/submission/128675942),[Argentina](https://codeforces.com/contest/1566/submission/128660285)

### Solution 3

考虑随机给每一个点进行二染色，如果一条边的两个端点都是同一种颜色的话，才将这条边考虑进来，那么由于是选出两条没有公共端点的边，那么如果考虑的两条边的端点颜色不同，那么说明一定是合法的

但是这样不一定能找到最优解，进行一次这样的算法得到最优解的概率为$\frac{1}{4}$，每一次进行这样一个操作，需要用set维护每一种颜色的边权集合（其实可以用对顶堆替代，常数比较小），时间复杂度$O((m+q)\log n)$

那么可以进行110次操作，一次询问的正确概率为$1-(\frac{3}{4})^{110}$，总的正确概率$(1-(\frac{3}{4})^{110})^q=0.9999999981903365$

但是由于使用的随机函数都是伪随机数，这里对随机数的要求比较高（因为只需要生成0/1），实际运行中要做110次才能保证每一次提交都能AC，否则就算是100次都有概率出错

[peti1234](https://codeforces.com/contest/1566/submission/128758655)

还有就是Radewoosh是对所有顶点五染色，其实冗余了，并不需要，导致单次计算的时间复杂度升高，会被Hack

### Solution 4

还有可以将所有查询和修改放到一起进行cdq分治，剩余的部分是根Solution 2类似的，同样需要用Part II的结论，只不过将线段树分治改成了cdq分治

[voidmax](https://codeforces.com/contest/1566/submission/128651436)

