# **Average and Median**

## 题目大意

现在有$n$张卡片，每一张有一个数字$A_i$，现在要在其中选出若干张卡片，要求不能存在两个相邻的卡片都不选择的情况，求最大可能平均数和中位数
$$
n\leq 10^5
$$

## 算法讨论

平均数：

首先考虑最大可能平均数，首先考虑二分答案
$$
\frac{\sum\limits_{i\in s}A_i}{|s|}\geq mid\\
\sum\limits_{i\in s} (A_i-mid)\geq 0
$$
那么将所有$A_i$减mid，然后求出最大可能选出的数之和，设$dp(i,0/1)$表示考虑到第$i$个位置，当前这个位置是否选择的最大权值，转移按照定义转移即可

中位数：

然后考虑最大可能中位数，还是考虑二分答案

那么将所有$A_i\geq mid$的数设为$1$， 所有$A_i<mid$的数设为$-1$，然后求出最大可能数之和，如果$>0$说明选出的数$\geq mid$的个数会多于$<mid$的个数，那么中位数还可以变得更大

1. 对于判定二分的答案可以贪心的选，就是如果当前为1，那么直接选，如果为-1，如果上一次数已经被选了，那么不选这个数，否则就必须要选这个数,https://atcoder.jp/contests/abc236/submissions/28733007

2. 也可以按照上面的一样的方法DP,设$dp(i,0/1)$表示考虑到第$i$个位置，当前这个位置是否选择的最大权值

时间复杂度$O(n\log n)$

# **Spices**

## 题目大意

现在有$2^n-1$个物品，每一个物品有一个代价，现在要求一个代价和最小的集合，满足通过选取这个集合中的某个子集，使得子集内物品编号的异或和可以为$[1,2^n-1]$中的任意数
$$
n\leq 16
$$

## 算法讨论

首先这个集合形成矩阵的秩一定要为$n$，也就是说将这个集合中的数插入线性基中需要成功插入$n$次，然后由于每一个数都有一个代价，那么可以在维护线性基的同时维护这一位最小可能代价

当前插入一个新的数的时候，如果当前位为1，并且在线性基中这一位存在，那么比较当前这一位的最小值和插入的最小值，如果插入的最小值小于当前这一位的最小，那么将代价和维护的数进行交换，然后用交换之后的数继续往后更新

相当于我们将代价进行排序，然后从小到大依次插入线性基，相当于带了一个可撤销的部分

时间复杂度$O(n2^n)$

# **Good Vertices**

## 题目大意

现在有n个点没有边的有向图，会在之后$T$时间内不断加入新的边，第$i$时刻加入的边为$u_i\rightarrow v_i$，现在对于每一个点求出最小的时间使得从1出发恰好走过$L$次
$$
n\leq 100,T\leq n^2,L\leq 10^9
$$

## 算法讨论

### Solution 1

首先考虑如果求出某一个时刻，从1号节点恰好经过L条边可以到达的点，那么可以用矩阵乘法，具体来说初始矩阵$A$，如果存在$u\rightarrow v$的边，那么$A_{u,v}=1$，定义矩阵乘法为or+and卷积，其中加法定义为$and$，乘法定义为$or$，由于$a\or (b\and c)=(a\or b)\and (a\or b)$，那么说明乘法对加法存在分配律，那么其矩阵乘法具有结合律

那么就可以矩阵快速幂了，注意到如果使用__int128压缩每一行和每一列的状态，一次矩阵乘法可以做到$O(n^2)$实际上是$O(\frac{n^3}{w})$

那么对于每一个节点可以二分出最小时间，那么总时间复杂度$O(\frac{n^4\log L\log T}{w})$或者$O(n^3\log L\log T)$，但是矩阵乘法使用了__int128常数会很大

### Solution 2

首先考虑上面这个做法中矩阵是01记录信息的效率并不高，那么不妨让时间记入到矩阵中，如果$u_i\rightarrow v_i$，那么令$A_{u_i,v_i}=i$

表示可以从$u_i$走到$v_i$的最小时间为$i$，定义矩阵乘法为max+min卷积，其中加法定义为$\max$，乘法定义为$\min $，由于$\min(a,\max(b,c))=\max(\min(a,b),\min(a,c))$，那么矩阵乘法满足结合律，那进行k次矩阵乘法的中$A^k_{u,v}$表示恰好经过$k$条边可以从$u$走到$v$的最小时间

那么我们只需要求出$A^L$次即可

时间复杂度$O(n^3\log L)$

# **Distinct Multiples**

## 题目大意

给定长度为$n$的序列$D$，求出有多少个可能的序列$A$，满足$A_i\in [1,M],A_i\neq A_j(i\neq j),D_i|A_i$
$$
n\leq 16
$$

## 算法讨论

首先需要考虑对$A_i\neq A_j$进行容斥，变成$A_i=A_j$，由于最终合法的答案不能存在$A_i=A_j$，那么如果强制钦定有$k$个二元关系满足$A_i=A_j$，那么容斥系数就是$(-1)^k$

那么考虑在钦定若干边必须满足$A_i=A_j$下如何计算答案，可以发现的是，对于一个联通块来说，其$A_i$都是相同的，并且$A_i$可能的取值，就是联通块中$A_i$的LCM的倍数

那么事实上对于很多的钦定的边方案都是本质相同的，只要形成的联通块本质相同即可，那么就可以考虑固定一个联通块统计其容斥系数之和

那么相当于求出$n$个点的图用奇数边联通的方案数和偶数边联通的方案数

一种非常暴力的做法就是设$dp(i,j)$表示$i$个点用$j$条边连通的方案数，可以在$O(n^6)$的时间内计算出答案，但事实上由于我们只关心偶数和奇数的方案数
$$
dp(n,m)=\binom{\binom{n}{2}}{m}-\sum\limits_{a=1}^{n-1}\sum\limits_b dp(a,b)\binom{n-1}{a-1}\binom{\binom{n-a}{2}}{m-b}
$$

缺陷

> **在比赛的时候没有强制1为联通块，这样计算的话会算重**
>
> **其中$\binom{n-1}{a-1}$需要强制$1$号点是在选在当前进行转移的联通块内部，然后剩下的点是在余下$n-1$个点中选，这里强制选择$1$因为对于不合法的情况，可能存在多个联通块，但是不能重复计算，因此需要选出一个代表的联通块来计数，注意到如果1所在的联通块不同的话，那么方案一定也是不同的，所以这样做就是可以将方案不重不漏的算出来**

那么可以设$dp(i,0/1)$表示答案，转移的时候考虑容斥，就是枚举图中的联通块数量不止1个，并且枚举1号节点所在连通的大小，以及使用的边数
$$
dp(i,j)=2^{\binom{i}{2}-1}-\sum\limits_{k<i} \sum\limits_{p\in\{0,1\}} dp(k,p)\binom{i-1}{k-1}2^{\binom{i-k}{2}-1}
$$
这样就可以做到$O(n^2)$转移

**那么n个点的容斥系数就是$dp(n,0)-dp(n,1)$，但事实这个值就是$(-1)^{n-1}(n-1)!$**

**证明的话，就是考虑我们这个容斥系数是在干什么，就是我们只有大小为1的联通块是合法的，容斥就是在干把不合法情况减去的工作，对于某一个不合法的状态来说，其的连通块在容斥统计中会被拆解成若干部分进行相乘统计，那么我们容斥系数就是需要将这些统计的方案数乘上容斥系数的和需要变成0，我们记容斥系数关于节点个数的EGF为$F$**

**那么通过将容斥中联通块进行不断组合得到的结果就是$e^F$，由于只有$1$的联通块是合法的，那么要求$e^F=x+1$，那么说明$F=\ln(1+x)$，那么其展开式就是**$(-1)^{n-1}(n-1)!$

然后就是通过拆分子集统计答案，设$dp(s)$表示当前集合为s的答案，假设$f(s)$表示$s$集合中的联通块可能的方案数
$$
dp(s)=\sum\limits_{t\subseteq s,t\neq \empty} dp(s\backslash t)\times f(t)\times (-1)^{|t|-1}(|t|-1)!
$$
时间复杂度$O(3^n)$，可以通过子集卷积+exp做到$O(2^nn^2)$

