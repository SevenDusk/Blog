# 红蓝

## 题目大意

![20211111T1](D:\Blog\image\20211111T1.PNG)

## 算法讨论

首先考虑将所有数都相同的二进制位删除，得到新的数

那么染色的方案就是需要满足$R=B=0$

考虑容斥，我们枚举二进位的一个子集，表示子集内的二进制位强制R,B中存在一个为1，不在集合中的二进制位任意的方案数

首先在当前位都是1的数可以随意放置，假设有k个，那么放置方案数就是$2^k$，然后对于集合中的位不全是1的数，由于数中0的位置都是绑定在一起的，由于这些钦定的位置R,B中有一个不能出现0，那么就需要将这个数的0位置合并到一起，假设最终联通块数量为A，那么方案数就是$2^A$

那么总方案数为$2^{k+A}-2$

考虑如何计算$A$

直接暴力并查集就是$2^{20}\times 20\times 50$，稍加卡常可以通过，考虑优化

### Solution 1

考虑折半搜索，我们目标是预处理出来每一个集合并查集的情况

将20分成两半，对于一半的位置来说进行暴力并查集，然后记录下使得并查集合并的边，然后合并两个块的时候就枚举两半的情况，然后利用记录使得并查集合并的边进行合并

由于最多只会记录$9$条边

时间复杂度就是$2^{10}\times 10\times 50+2^{20}\times 20$

### Solution 2

在枚举s集合的过程中，记录每一个集合的最终并查集情况

然后当前s将随后一位删除，在记录的情况中找到少一个元素x的并查集情况，那么现在只需要加入一个位置即可，那么枚举所有的n个数

对于一个数$a_i$，如果x位上为0，那么再随便找到一个不为x的为0的二进制位，将这两个位置合并即可

时间复杂度就是$2^{20}\times 50$

# 有根

## 题目大意

![20211111T2](D:\Blog\image\20211111T2.PNG)

## 算法讨论

首先需要将G强连通缩点，那么H中的后三个条件就是，对于树上直接连边的两个节点来说，其必须要在不同的联通分量中，对于兄弟节点来说必须也是要在不同的连通分量中

那么我们将G的所有强连通分量按照拓扑序编号，可以发现H树中的节点是形成堆的性质

我们将G中强连通分量内部的边删除，由于H的联通块数量等于$n-m$，m为边数，那么相当于保留G中尽可能多的边使得一个节点连向同一个强连通分量的边数$\leq 1$，一个节点最多被一条边指向

就可以相同二分图匹配，按照拓扑序从小到大枚举，枚举到的强连通分量作为二分图的一边节点，前面所有的强连通分量作为另外一边节点，对于中间的边就是保留强连通分量之间的边即可

将所有最大匹配加起来就是能最多保留的边数

时间复杂度$O(n^2m)$ 

# 路线

## 题目大意

![20211111Y3](D:\Blog\image\20211111Y3.PNG)

## 算法讨论

考虑所有国家形成数的Prufer序列，由于每一个点在序列中出现次数就是度数减1次

那么对于固定一个度数序列$d$

那么有
$$
\binom{n-2}{d_1-1,d_2-1,...,d_n-1}
$$
的方案数

然后考虑国家内部的分配情况，由于所有城市都是可以区分，那么对于国家i其方案数就是$a_i^{d_i}$，乘上贡献就是$a_i^{d_i}d_i$

那么对于一个度数序列总贡献就是
$$
\binom{n-2}{d_1-1,d_2-1,...,d_n-1}\prod a_i^{d_i}=(n-2)!\prod \frac{d_ia_i^{d_i}}{(d_i-1)!}
$$
我们需要对于所有度数序列求和，注意到$\sum d_i=2n-2$，那么这个相当于生成函数卷积中的$x^{2n-2}$前的系数

那么设
$$
\begin{align}
f_k(x)&=\sum\limits_i \frac{ia_k^i x^i}{(i-1)!}\\
&=\sum\limits_{i}\frac{(i-1)(a_kx)^i+(a_kx)^i}{(i-1)!}\\
&=\sum\limits_{i} \frac{(a_kx)^i}{(i-2)!}+\sum\limits_{i}\frac{(a_kx)^i}{(i-1)!}\\
&=(a_kx)^2e^{a_kx}+(a_kx)e^{a_kx}
\end{align}
$$
最终答案就是$(n-2)![x^{2n-2}]\prod f_k(x)$

其中
$$
\prod f_k(x)=\prod a_i x^n\prod (a_ix+1)e^{(\sum a_i )x}
$$
其中暴力计算$\prod(a_ix+1)$，然后与$e^{(\sum a_i)x}$卷积即可，其中$[x^n]e^{\sum a_ix}=\frac{(\sum a_i)^n}{n!}$

时间复杂度$O(n^2)$

# 修正

## 题目大意

![20211111T4](D:\Blog\image\20211111T4.PNG)

## 算法讨论

首先如何将a,b,c整体考虑的话，是很难处理的，当固定a的时候，对于b的函数并没有什么好的性质，然后如果按照从低位开始枚举的话，还是会发现进位很难处理

那么就需要从高位开始枚举三个数的情况，同时还需要记录当前位需要的进位数$carry=c-a-b$

那么我们记录每一个数当前使用的不含前导0的数字个数$(A,B,C)$，需要注意的是由于存在插入操作，那么所有合法的$(A,B,C)$可能有无限个，而且在转移的过程中还会形成环

但是注意到太多的插入操作是一定不优的，具体来说，如果三个数连续2个位置都是插入的数，那么显然可以删除其中一个位置上的数，然后调整另一个位置上的数即可

具体实现的时候就是可以定一个连续插入操作次数的上界即可

同时我们还需要记录A,B,C当前是否还是前导零，那么可以用一个三位的数字记录

我们可以每一次转移的时候不需要暴力枚举三个数的情况，那么我们依次枚举

那么设$dp(lim,z,A,B,C,s,carry)$表示当前还可以连续插入$lim$个数，当前处理的数编号为z（c的编号为0，a的编号为1，b的编号为2），当前处理的数个数为A,接下来的数为B,C，s表示三个数中哪些数不是前导零，carry表示当前需要的进位数量的最小代价

首先如果$z=0,s=7,carry=0$的话，那么说明三个数已经相同，那么将剩下的位置删除即可

对于z=3的情况，那么说明需要处理的一个新的位置，carry*10,z=0即可

然后如果$lim>0$的话，那么可以进行插入操作，如果当前还是前导零，那么代价就是0，否则代价就是I，并且处理的数需要变成下一个数，然后还需要更新s,carry，其中carry的更新就是如果当前z=0，那么加上插入的数，否则减去插入的数

然后删除操作不需要将当前处理的数变成下一个

然后变换操作，就是对于枚举当前位置的数最终变成什么，其中如果变成的数等于原来的数，那么代价就是0，否则就是R的代价，至于其他的更新都是与插入操作类似



