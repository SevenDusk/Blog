# F.Cleaning Robot

## 题目大意

现在有一个机器人在$(0,0)$，有四个方向的命令，现在有一个命令序列$S$，重复执行$k$，求出机器人走过的格子数量
$$
|S|\leq 2*10^5,k\leq 10^{12}
$$

## 算法讨论

考虑执行一次经过的格子坐标为$(x_0,y_0),(x_1,y_1),...,(x_k,y_k)$保证两两不同

考虑最后结束所在格子为$(t_x,t_y)$，那么每执行一次命令序列，相当于将$(x_0,y_0),(x_1,y_1),...,(x_n,y_n)$，平移$(t_x,t_y)$，图形之间可能会有重复

考虑一个被重复经过的位置，假设被经过了2次（更多次都是可以选出其中两次规约成2次的情况），假设是第$i,j$次经过的$i<j$，可以发现的是对于$0\leq k<i$来说，$i-k,j-k$次都是会相交重复的，其中可以发现，如果某一个走过的序列$(x_i,y_i),(x_i+t_x,y_i+t_y)......$经过了$(x_0,y_0),(x_1,y_1),...,(x_n,y_n)$其中一个，之后就不会走过新的格子了，那么我们就需要对于$(x_i,y_i)$找到最小的$f_i$，使得$(x_i+f_it_x,y_i+f_it_y)$为$(x_0,y_0),(x_1,y_1),...,(x_n,y_n)$其中一个

需要注意的是如果不存在$f_i$，那么强制令$f_i=\infin$

那么答案就是$\sum\min(f_i,k)$

首先如果$t_x=t_y=0$，那么答案就是$n$

可以通过交换x,y坐标，取反使得$t_x>0$

考虑定义一个函数$g:\mathbb{R}^2\rightarrow \mathbb{R}^2$，令$w=\frac{x-(x\ \bmod \ t_x)}{t_x}$，则$g((x,y))=((x\bmod\ t_x),y-w\times t_y)$

可以发现如果$g((x_i,y_i))=g((x_j,y_j))$，说明$(x_i,y_i)$是可以通过命令序列走到$(x_j,y_j)$的，由于要使得$f(i)$最小并且$t_x$，那么要找到$x_j>x_i$最小$x_j$的$j$，那么$f(i)=\frac{x_j-x_i}{t_x}$

只要按照$x$降序考虑即可

# G.Propagation 

## 题目大意

给定$n$个点$m$条边的无向图，一开始第$i$个顶点上存在数字$i$，现在有$q$操作，$x$，表示将x顶点上的数字覆盖与x相邻节点上，求最后得到结果
$$
n,m\leq 2*10^5
$$

## 算法讨论

直接暴力修改显然不行，那么考虑按照度数进行根号分治，假设$A$表示所有度数$\leq \sqrt n$的顶点，$B$表示所有度数$>\sqrt n$的顶点

显然$|B|\leq \sqrt n$，其中$A$中顶点进行暴力修改的复杂度是可以接受的，主要是如何修改$B$中的顶点

对于B中的顶点$x$只考虑$(x,y),y\in B$的连边，对于这些连边进行暴力修改，然后对于可能要修改A中的顶点，考虑在x上打上tag（记录数字和时间）

那么在修改A顶点之前需要考虑其相邻的B中顶点上的tag，比较当前A上数字修改时间是否早于tag上的时间，如果早于，那么就修改为tag上的数字

最后更新输出答案即可

时间复杂度$O(n\sqrt n)$

