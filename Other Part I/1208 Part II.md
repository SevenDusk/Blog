# 二进制分组

可以支持强制在线，并且复杂度优秀的技巧（常数略大）

考虑将所有修改操作按照二进制分组，就是将其分成$\log n$个块，对于每一个块内对询问的贡献用数据结构进行维护，每一次询问的时候在块内的数据结构上进行查询

在加入新的修改操作的时候，会合并某两个块，直接暴力合并即可，因为每一块内元素个数都是跟长度有关，复杂度为$O(f(n)\log n)$，$f(n)$为合并的复杂度

在实现的时候就是在线段树上实现，如果某一个节点的区间都加入过修改操作了， 那么将左右儿子的信息合并上来，作为一个新的块

如果询问所对应的修改操作是一个前缀的话，在合并左右儿子信息的时候，可以将左右儿子所用的空间回收

# Escape Through Leaf

## 题目大意

![20211208T4](D:\Blog\image\20211208T4.PNG)

## 算法讨论

首先我们可以列出DP设$dp(x)$表示从x节点出发到叶子节点的最小值
$$
dp(x)=\min dp(y)+a_x\times b_y
$$

### Solution 1

如果讲$b_y$看作斜率，$dp(y)$看作截距，那么我们就是求出$x=a_x$下的最小直线对应的值即可

那么这是可以用李超树进行维护的

然后合并子树的时候需要用到李超树合并

时间复杂度$O(n\log n)$

### Solution 2

可以考虑维护出$(b_y,dp(y))$形成点的凸包，然后每一次用斜率为$-a_x$的直线去截即可

一种暴力做法就是用set维护凸包，然后启发式合并，但是难以实现

可以考虑进行二进制分组，每一组都是一个凸包，然后在合并子树的时候，将小的合并到大的上面，如果存在两个相同大小的组，那么再次进行合并，而合并的过程是$O(m\log m)$(求出给定的点的凸包)，m表示组内元素大小

那么总时间复杂度$O(n\log ^2n)$

# String Set Queries

## 题目大意

![20211026T4](D:\Blog\image\20211026T4.PNG)

## 算法讨论

考虑进行二进制分组

我们可以对于这个字符串集合用线段树（一开始的大小就是$3*10^5$）进行维护，当加入一个字符串的时候，增加一个下标，然后在这位置上插入字符串

在线段树上的每一个节点上都维护当前区间有哪些字符串，一旦当前节点插入满之后，就将当前所有字符串建立AC自动机

那么查询就是相当于查询一个区间，当在一个AC自动机上查询出现的次数

需要注意的是如果一个节点插入满之后，需要将两个子节点的AC自动机清空，

时间复杂度$O(n\log n)$

### Solution 2

考虑进行根号分治，

对于集合中长度$\leq \sqrt n$的串，插入到Trie中，如果是加入，那么在最末尾的那个元素上+1,否则删除的话就是-1，当查询的时候枚举查询串的所有后缀，在Trie中匹配，每一次到一个新的节点的时候，就加上这个节点的权值即可，然后一旦访问到空节点，就退出循环，由于Trie的深度最大为$\sqrt n$，所以复杂度为$|S|\sqrt n$

然后对于$>\sqrt n$的串，预处理出来其kmp的前缀函数，然后当查询的时候暴力匹配即可，由于这样的串个数$\leq \sqrt n$，查询的复杂度也是$|S|\sqrt n$

那么总复杂度$O(n\sqrt n)$