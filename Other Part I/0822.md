# 序列

## 题目大意

![20210822](D:\Blog\image\20210822.PNG)

## 算法讨论

首先需要判断非法的情况，就是输入的n对位置有相邻的情况，就输出-1（题目意思应该就是这个，其他不用管。。）

然后将$n$对数和其他的$m-2n$个数分开考虑

首先考虑这$n$对数的情况，根据期望的线性性，可以先考虑一对相同的情况

数字相同的概率是$\frac{1}{k}$，贡献为$2$

那么n对的贡献就是$\frac{2n}{k}$

在考虑其他位置的数，首先也是同样的期望线性性，考虑一个位置的情况

设$F$表示从$n$个数内两次选出$n-k$个数，被选了两次的数的期望个数，那么就是$\frac{F(k-n-1)^{2(l-1)}}{(k-n)^2(k-n-1)^{2(l-1)}}=\frac{F}{(k-n)^2}$

考虑计算$F$，还是期望的线性性，得到$F=k(\frac{\binom{k-1}{k-n-1}}{\binom{k}{k-n}})^2=\frac{(k-n)^2}{k}$

那么总答案就是$\frac{m}{k}$与$n$无关

# 迷宫

## 题目大意

![20210822T2](D:\Blog\image\20210822T2.PNG)

## 算法讨论

首先可以证明，如果固定三个点，那么最优的会合位置一定是三个点到某一个点，并且最短路之和最小

证明的话就是反证，如果有两个人提前相遇，那么在那个提前相遇的点会合更优

首先需要判断所有可能的传送点都是在同一个联通块之内的，否则就是不合法

然后预处理出来所有传送点出发的最短路，然后枚举三个位置，枚举联通块里面的点，求出最小的距离和即可

注意像找树上重心的那样的方法可能不行，虽然这个图满足走向周围是递减的，**局部最优点**是比周围都小的节点，但是可能存在多个局部最优点

**另解**：可以先枚举F,R，将这两个点的最短路叠加起来，那么就可以看作这两个点先走到某一个点会合，然后走向L的位置上（需要注意的是这里虽然是两个人一起走，但是每走一步代价都是1，相当于是对L倒序考虑），这个由于可以互相更新，就用一个dij来计算就可以了

那么时间复杂度就是$O(20^2nm\log nm)$

# 考试

## 题目大意

![20210822T3](D:\Blog\image\20210822T3.PNG)

## 算法讨论

考虑建出图来，对于表达式$A=B+s$，建立$B\rightarrow_s A$的一条边

那么可以发现得到的有向图必须是一个DAG才是有可能合法的

但是这样计算答案仍然不好计算，如果我们可以将DAG缩成一个外向树的话，就可以很方便的计算答案

我们按照拓扑序的顺序来考虑

首先考虑一个节点所有的入边，这些入边需要满足一些条件，就是如果将这些入边上的字符串按照长度排序的话，长度小的一定是长度大的后缀，否则就不合法

那么显然这样记录信息是浪费的，那么考虑简化，我们可以在排好序的边节点依次建立边，边上就是长度小的字符串前面没有出现过的信息

<img src="D:\Blog\image\IMG_20210822_183457.jpg" alt="IMG_20210822_183457" style="zoom:50%;" />

然后有可能对于连过来的边还是存在两个入边，那么就递归处理一下就可以了

**需要注意的是，如果将这个图缩成了一个链的话，可能存在链前面的节点连向后面的节点，那么需要特殊判断否则会死循环**

**另解**：一开始建边的时候不止是要建一条有向边，对于反向的负权边也要建出来，代表着经过这条边，就要在当前字符串的后缀减去这个字符串

就是由于数据范围很小直接在原图上进行dfs，看最长的路径和最短的路径长度是否相等，如果不相等那么一定不合法，然后在判断字符串的问题，就是在dfs过程直接将这个字符串维护出来

# 毒瘤

## 题目大意

给定$n$个点的树，每一个节点都有一个权值$a_i$，表示第一次经过这个点可以获得的价值，走的过程中权值之和不能为负，并且如果一个节点的父亲没有经过，那么只能往儿子节点走，求出从点$to$到根上节点出发，是否能到达to
$$
n\leq 10^5
$$

## 算法讨论

一个经典的贪心

首先在$to$下面挂一个权值为$inf$的点，如果从某一个点出发可以到达$to$的话，途中最大权值一定是大于等于$inf$的，那么就需要求出路程中最大权值和

考虑将一个子树内所有的节点缩成如下的形式$(a,b)$表示先要付出$a$的代价，然后得到$b$的收益，并且需要完成前面一个二元组才能继续做下一个二元组，相当于就是形成了一条链

首先需要考虑几个性质

- 如果存在两个相邻的$(0,b)$的话，就可以将这两个合并起来，对于$(a,0)$的情况也是同理

- 如果存在$(a,b)$满足$b<a$的话，那么就合并成$(a-b,0)$，然后查看是否可以跟其他的合并，这是因为如果选了这个二元组，获得的收益是负的，那么不会之后什么操作也不进行，肯定会找解锁有正收益的二元组
- 可以保证$(a,b)$中$a$是递减的，如果存在一个递增的，那么就可以合并相邻的两个二元组，原因也是比较显然，肯定是一开始找门槛比较低的，然后不断提高门槛

那么对所有子树维护出来这些二元组，一个子树内的二元组最多是子树大小个，可以利用堆来维护这些二元组

至于合并的时候，就是启发式合并，按照上面的条件进行判断，最后再加入当前子树的根，就是在堆顶加入（因为经过子树内的点一定需要经过子树的根）

至于判断，由于出发的时候权值为$0$​，那么一定要保证堆首的元素$a=0$，然后检查$b$是否大于等于$inf$

时间复杂度$O(n\log ^2n)$，常数很小

**另解**：对于平衡树的启发式合并可以用finger search来做到$O(n\log n)$，就是将插入的平衡树的中序遍历拿出来，**然后插入的时候记录上一次插入到哪里**，然后从上一次的位置不断走，直到走到当前插入的位置，可以证明这样的时间复杂度就是$O(n\log n)$

还可以用线段树进行维护，但是常数比较大

