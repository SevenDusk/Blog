# 8.射线法

判断一个顶点是否在一个多边形内部的方法，就是随意从这个点引出一条射线，这条射线要求不经过多边形上的顶点

如果这条射线与多边形的边相交奇数次，那么可以说明就在多边形内部，如果为偶数次就说明在多边形外部

注意这里的多边形可以是任意多边形

在网格图上也是可以应用的，就是判断某一个点是否被一个封闭路径包含，只要从需要判断的点引出向右上**偏离微小角度**的射线，这样只有行变化的时候才会影响交点数量，就不需要考虑路径和射线重合的情况

# CF375C Circling Round Treasures

## 题目大意

给定$n\times m$的网格，网格上有障碍，炸弹，宝藏（保证炸弹和宝藏的数量之和$\leq 8$），每一个宝藏都一个权值，现在要走出若干条封闭的路径，使得宝藏被包含在路径之内，并且炸弹不能被包含在内

一个方案的获益为$\sum v_i-step$，$step$为走过的步数
$$
n,m\leq 20
$$

## 算法讨论

还是需要使用射线法，就是判定一个点在路径之内的依据

设$dp(i,j,mask)$表示当前从起点走到$(i,j)$，mask表示所有物体发出的射线经过了奇数次还是偶数次

我们假定所有物品引出的射线都是向右的，并且偏离了一个小的角度

那么如何更新一个答案

用bfs来进行转移即可，有两种情况会改变当前的交点数量，记当前点为$(x,y)$，走到的点为$(x+dx,y+dy)$，引出射线点的坐标为$(nx,ny)$

- 如果$nx=x,y\geq ny,dx=-1$，那么增加一个交点
- 如果$nx=x+dx,y+dy\geq ny,dx=1$，那么增加一个交点

由于dp更新出来就是默认可以重复走多次，$dp(s_x,s_y,mask)$就是走过包含mask的走过的最小步数

那么就不需要$O(3^n)$枚举子集了，直接统计答案就可以了

还有若干种处理办法

- 不加偏离角度
  - 对于引出的射线来说不加偏离角度，由于不可能经过一个物品，那么跟射线重合的线段只算起点和终点两个位置，事实上就是另外一个方向的线段终点和起点，那么就可以将另外一个方向的线段看出一段闭合一段开放的线段（事实上就是偏离角度的分析过程）[uwi][https://codeforces.com/contest/375/submission/5509414],[Egor][https://codeforces.com/contest/375/submission/5509326],
  - 或者记录上一次更新过来的方向，其他都是跟第一个处理办法类似[5509414](https://codeforces.com/contest/375/standings#)

- 直接求出射线和当前路径的交点
  - 用向量表示出两条线段然后看作直线，求出两个直线的交点，看交点是否在线段的范围之内[sday](https://codeforces.com/contest/375/submission/14094548),[Zlobober][https://codeforces.com/contest/375/submission/5509512],[kutengine](https://codeforces.com/contest/375/submission/6164336)

简单的提交[al13n][https://codeforces.com/contest/375/submission/5509032],[rng58][https://codeforces.com/contest/375/submission/5505557], [orbitingflea](https://codeforces.com/contest/375/submission/56429624),[Dimguo](https://codeforces.com/contest/375/submission/10619462)

# POJ 3182 The Grove

## 题目大意

给定$n\times m$的网格图，有若干区域是障碍，这些格子构成了一个联通块并且没有镂空部分，现在要求从起点开始绕着障碍走一圈回到原点（八联通），求最短路径长度
$$
n,m\leq 50
$$

## 算法讨论

这道题题目需要利用判断一个点是否在多边形的方法，射线法

可以发现只要有一个障碍在路径之内，那么就可以说明所有障碍都被路径包含，那么随意选出一个点即可

设$d(i,j,0/1)$表示从起点走到$(i,j)$位置时候，选出的点引出的射线与路径相交了偶数/奇数次

用bfs来进行转移即可，具体细节同上，有两种情况会改变当前的交点数量，记当前点为$(x,y)$，走到的点为$(x+dx,y+dy)$，引出射线点的坐标为$(nx,ny)$

- 如果$nx=x,y\geq ny,dx=-1$，那么增加一个交点
- 如果$nx=x+dx,y+dy\geq ny,dx=1$，那么增加一个交点

第一次提交:AC

# POJ 3179 Corral the Cows

## 题目大意

给定$n$个二维平面上的点，要求求出最小边长的正方形，使得正方形内部存在至少$c$个点
$$
n,c\leq 500,x,y\leq 10000
$$

## 算法讨论

首先二分答案，那么check的时候正方形的边长已经固定了

考虑将所有点按照$x$升序排序，利用线段树维护所有正方边右边界在当前位置内部的点数，具体线段树中第i个位置维护的是$y$坐标$[i,i+mid-1]$的正方形

考虑对于每一个$i$，求出最小的$j$满足$x_j\geq x_i-mid+1$，那么当前正方形覆盖了$[x_j,x_i]$中的点，可以用单指针进行维护

那么加入一个点就是在线段树$[\max(1,y_i-mid+1),y_i]$中$+1$即可，删除也是同理

那么需要区间加，求最值，线段树可以解决

时间复杂度$O(n\log^2 C)$

第一次提交:AC

# POJ 3038 Flying Right

## 题目大意

现在有n个城市，白天的时候飞机从$1$飞向$n$，黑夜的时候飞机从$n$飞向$1$，现在有k个旅行团分别要从$s_i$飞向$t_i$，有$m_i$个成员，飞机的容量只有$C$，求最多可以使多少个人完成其安排（注意飞机可以飞两次）
$$
n\leq 10^5,k\leq 5*10^4
$$

## 算法讨论

首先对$s_i<t_i$分类，确定是白天考虑还是黑夜考虑，接下来只考虑一种情况

那么问题可以转化为现在有n-1段，每一段最多只能被$C$个区间覆盖，求出最多可以选出多少个区间

由于区间不带权，就可以考虑将经典贪心扩展

考虑将所有区间按照右端点排序，扫描到当前区间的话，求出区间内段最多被覆盖了几次，然后尽可能选择当前区间，更新状态

证明就是跟区间覆盖问题的证明类似

可以用线段树进行维护

时间复杂度$O(n\log n)$

第一次提交：AC

# POJ 2433 Landscaping

## 题目大意

给定长度为$n$的序列，每一次可以将序列中一个数$-1$，要求操作最少的次数，使得序列的峰个数$\leq k$

峰的定义是，一个连续高度相同的段，左右两侧的要么是序列边界要么高度比其低
$$
n\leq 1000,k\leq 25
$$

## 算法讨论

考虑每一次贪心的选出铲平这个峰需要的代价最少的那个进行铲平，直到当前序列满足条件

考虑如何计算铲平一个峰的代价

首先将高度相同的段缩成一个数，同时记录这个段的长度，那么先找到峰的峰顶，然后不断向两端扩展（要递减）

那么削去这个峰就需要将所有高度大于$\max(h_l,h_r)$的铲平至这个高度

选择其中代价最小的即可，然后不断进行下去，显然由于高度和是递减的，那么算法一定会在有限步数之内结束

时间复杂度$O(n^2)$

第一次提交：AC

# POJ 2432 Around the world

## 题目大意

给定一个分成360度的环，环上有n个节点（节点可能重复），现在有$m$条边$(u,v)$，是验证$u$到$v$最短的路径走过（如果顺时针走比逆时针走要短，那么就顺时针走，保证u，v不会恰好相对）

求出从1号节点出发，至少环绕一圈回到$1$的最短路径
$$
n\leq 5000,m\leq 25000
$$

## 算法讨论

如果1号节点没有环绕一圈走回来，其顺时针走过的路程和逆时针走过的路程是相同的

那么就可以记录$d(i,j)$表示走到$i$号节点，顺时针走过路程与逆时针走过路程之差

由于$j$的大小可能比较大，但是合法的状态数量少最多只有$O(n^2)$（显然这上界很松）

那么只需要用map记录一下状态即可（由于不能用C++11）

时间复杂度$O(n^2\log n)$（跑不满）

第一次提交：AC

# Roping the Field

## 题目大意

给定$n$个点的凸多边形，并且内部有$G$个圆（保证圆心都在多边形内部），现在可以在两个不相邻的多边形上的点连边，这条边不能穿过任何一个圆，并且两条连出来的边不能相交，求出最多可以连多少条边
$$
n\leq 150,G\leq 100
$$

## 算法讨论

首先预处理出来$ok_{i,j}$表示$i,j$之间是否可以连边，这个只需要枚举所有圆，求出圆心到直线的最短距离即可（过这个点作线段的垂线，然后两线相交求出垂足，计算距离即可）

然后设$dp(i,j)$表示$i$到$j$中最多可以连多少条边，由于边不能相交那么，显然可以将一段区间分成若干独立的区间
$$
dp(i,j)=ok_{i,j}+\max\limits_{k=i+1}^{j-1} dp(i,k)+dp(k,j)
$$
最初枚举两端区间即可

时间复杂度$O(n^3+n^2G)$

第一次提交：WA