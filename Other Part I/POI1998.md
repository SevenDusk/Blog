# The lightest language

## 题目大意

给出一个字符集，每一个字符都有$w_i$的代价，现在要生成$n$个字符串，一个字符串的代价就是所有字符代价之和，并且这些字符串互相不是前缀关系，求最小代价
$$
n\leq 10000,k\leq 26
$$

## 算法讨论

首先，可以对所有串建出一个trie，那么所有串在trie上表示的节点都是叶子节点

一开始我想是的每一步扩展出一个叶子节点，结果成功WA了

首先给代价排一个序，会发现，如果从一个叶子扩展出去，代价是$v_x+a_1+a_2$，而后面一步的代价是$v_x+a_3$，那么如果$a_3<a_1+a_2$，那么这个贪心就不是每一步代价递增的，就是错的

后来发现，搞一个类似可撤销贪心的东西，可以解决这个问题

一开始先将第一层所有的节点，加入选择方案，然后选出最小的向下扩展一层，将不优的方案剔除掉，然后保证所选集合中元素个数始终$\leq n$，直到方案变劣

时间复杂度$O(kn\log n)$

第一次提交:Wrong Answer

# Chase

## 题目大意

给定一张无向联通图，现在A和B各执两个棋子在不同的节点，每一步他们可以将棋子移向相邻的节点或者不动，B的目标是将棋子移动到A所在的节点上，A则要避免这个事情的发现，并且如果不可避免，就让B尽量晚的达成目标，现在A先手，问游戏结果，并且如果B达成目标，输出多少步

保证图中不存在三元环
$$
n\leq 1000,m\leq 15000
$$


## 算法讨论

如果A和B都在环上，并且第一步B到不了A，那么B一定不能达成目标

那么A的目标就是在B达成目标之前，尽量走到环上

我们可以通过bfs，求出A,B分别为起点的最短路，然后对于一个环上的节点，如果$d_a(i)<d_b(i)$，那么B就达不成目标了

如果找不到，那么就找满足$d_a(i)<d_b(i)$，最大的$d_b(i)$

至于一个节点是否在环上，可以使用边双缩点来实现

复杂度$O(n+m)$

第一次提交:AC