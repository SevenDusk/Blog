# We Need More Bosses

## 题目大意

![20211204T1](D:\Blog\image\20211204T1.PNG)

## 算法讨论

首先从s到t所有必须经过的边一定是原图中的桥

那么我们可以将这个图进行边双缩点，对于以边双为节点的树来说，那么相当于就是求出树上两个点最大距离

那么就是树的直径，通过两遍dfs求出即可

# One Occurrence

## 题目大意

![20211204T2](D:\Blog\image\20211204T2.PNG)

## 算法讨论

考虑对于每一个位置上的数$a_i$处理出来最大的$p_i=j$，满足$a_i=a_j$，如果不存在这样的$j$，那么$p_i=0$，对于之后的后继也是同样处理，记作$s_i$

那么某一个数在区间只出现一次的条件就是$p_i<l\and s_i>r$

那么对于第二个条件，我们可以通过将所有询问离线，然后按照右端点进行排序即可，我们只需要关心区间内每一种数最后一个出现的位置即可

那么我们从小到大枚举所有询问的右端点，考虑在扫描过程中维护一个线段树，维护每一种数最后一个位置的最小$s_i$

那么在新增一个数的时候，将$s_i$位置上的贡献撤销，然后加入当前$i$的贡献，就是将线段树中$i$的值设为$s_i$，然后对于一个询问$[l,r]$，只需要查询$[l,r]$中的最小值即可，然后输出最小值对应的数字即可

时间复杂度$O(n\log n)$，空间复杂度$O(n)$

### Solution 2

可以使用莫队，在移动过程中维护每一个数出现次数的桶，然后对这个值域进行分块，每一个块中维护一个数出现1次的数个数

然后查询的时候从大往小枚举块，如果块中存在只出现1次的数，那么直接在块内部查找即可

这样时间复杂度就是$O(n\sqrt n)$

[Submission #87392453 - Codeforces](https://codeforces.com/contest/1000/submission/87392453)

# Two-Paths

## 题目大意

![20211204T3](D:\Blog\image\20211204T3.PNG)

## 算法讨论

考虑对于询问两个点$u,v$

可以发现，对于任意一个2-path中树上u到v的简单路径上的边都是只会被经过一次的，其他边都是经过两次，并且所有边都是联通的

那么对于u,v简单路径上的贡献是确定的，只需要求出LCA用树上前缀和差分就可以求出贡献

主要是对于经过两次的边，可以发现对于挂在u，v简单路径上的子树，相当于是求出一个包含根的最大子树和

这里每一个点的权值设为该点的点权减去两倍的该点到父亲边权的两倍，$a_i-2w_{i\rightarrow fa_i}$

那么可以设$f(x)$表示包含x的最大子树和
$$
f(x)=a_i-2w_{i\rightarrow fa_i}+\sum \limits_{u\in son(x)} \max(0,f(u))
$$
那么考虑在询问过程中如何快速求出，所有挂在u，v路径上的子树$f(x)$的和

考虑对于整个树进行树剖，然后对于每一个点维护其所有儿子子树（除去重儿子）的$f(x)$和，然后求出前缀和

在u，v查询LCA的时候，只需要在重链上查询一段区间和，然后特殊处理跳轻边的贡献即可

然后需要特别注意的是，对于LCA的情况，是存在一个向上的子树的，那么我们需要用换根DP处理所有节点这个向上子树的贡献

换根DP比较简单，都是加法撤销比较方便

那么时间复杂度$O(n\log n)$

## Solution 2

可以发现上面这个做法难以处理的部分就是求出挂在u，v简单路径上的子树和

这个是可以通过简单容斥，变成可以用树上前缀和处理的东西（事实上如果不容斥也是可以直接通过倍增维护）

考虑一个节点x以及其父亲$fa_x$的贡献，记$s_x=\sum\limits_{u\in son(x)}\max(0,f(u))$

那么这两个点的贡献贡献就是$s(x)-f(son(x))+s(fa(x))-f(x)=(s(x)-f(x))+...$，对于这个链上所有贡献可以通过移项变成只与一个节点有关的贡献

可以发现的是，我们可以预处理处理$s(x)-f(x)$的树上前缀和，只需要单独处理端点和LCA的情况即可

如果配合上tarjan求lca可以做到时间复杂度$O(n)$

tarjan求LCA做法[Submission #39730030 - Codeforces](https://codeforces.com/contest/1000/submission/39730030)

倍增做法 [Submission #39822773 - Codeforces](https://codeforces.com/contest/1000/submission/39822773)

# Intercity Travelling

## 题目大意

![20211204T4](D:\Blog\image\20211204T4.PNG)

## 算法讨论

设$f(i)$表示考虑到第i个位置的所有情况的代价和，然后考虑枚举上一个休息站离现在i有多远，记$s_i=\sum\limits_{j\leq i}a_j$
$$
f(i)=s_i+\sum\limits_{j=1}^{i-1}f(i-j)+2^{i-j-1}s_j=s_i+\sum\limits_{j=1}^{i-1}f(j)+2^{i-1}\sum\limits_{j=1}^{i-1} \frac{s_j}{2^{j}}
$$
记$g(i)=\sum\limits_{j=1}^{i-1} f(j),h(i)=\sum\limits_{j=1}^{i}\frac{s_j}{2^j}$
$$
g(i)=2g(i-1)+s_i+h(i)
$$
直接递推即可

答案为$g(n)-g(n- 1)$

# Dominant Indices

## 题目大意

![20211204T5](D:\Blog\image\20211204T5.PNG)

## 题目大意

考虑预处理处理$f(i,k)$表示i子树中深度为k的点个数

由于这个$f(i,k)$第二维只跟子树内的最大**深度**有关，那么考虑用长链剖分进行维护

我们先递归处理处理重儿子的信息，直接继承上来用vector存起来，然后再递归其他轻儿子的信息，然后进行暴力合并即可

再合并过程中同时需要维护vector中的最大值，以及对应的深度即可

时间复杂度$O(n)$

# Allowed Letters

## 题目大意

![20211204T6](D:\Blog\image\20211204T6.PNG)

## 题目大意

首先考虑贪心，从前往后从小往大枚举字符

然后剩下的就是需要快速判断之后字符串是否是合法的

考虑建立二分图，对于所有字符建立左部点，对于所有位置都建立一个右部点即可

然后位置上可以放置的字符进行连边，然后求出二分图最大匹配，如果存在完美匹配，那么说明合法

注意到字符的种类只有8个，我们可以暴力按照Hall定理的内容进行判定

那么我们需要求出对于任何一个字符集合s，至少存在一个字符可以填到这个位置上的位置数量

假设位置i可以填的集合为$s_i$，那么对于所有的$s_i\subseteq t$令$f(t)+1$，然后假设当前枚举的集合为s那么需要满足
$$
\sum\limits_{i\in s} cnt_i\leq n-f(\{a,b,c,d,e,f\}\bigoplus  s)
$$
然后在确定一位之后，需要将$cnt$和$f$进行更新即可

时间复杂度$O(2^6n)$

https://codeforces.com/contest/1009/submission/40539383
