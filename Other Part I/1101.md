# 跳跃

## 题目大意

![20211101T1](D:\Blog\image\20211101T1.PNG)

## 算法讨论

首先显然不会往回跳，那么我们可以进行DP，设$f(i)$表示当前跳到第i个胡萝卜的位置得到的最大愉悦度

那么有
$$
f(i)=\max \limits_{j<i} f(j)-\lceil \frac{T_i-T_j}{D}\rceil A+B_i
$$
考虑将T的值域分段每D个一段，我们要将后面这个上取整拆成只跟$T_i,T_j$的两项

- $T_i\bmod D\leq T_j\bmod D$，那么$\lceil \frac{T_i-T_j}{D}\rceil =\lfloor \frac{T_i}{D}\rfloor -\lfloor \frac{T_j}{D}\rfloor $
- $T_i\bmod D>T_j\bmod D$，那么$\lceil \frac{T_i-T_j}{D}\rceil =\lfloor \frac{T_i}{D}\rfloor -\lfloor \frac{T_j}{D}\rfloor +1$

那么我们用线段树维护$T_i\bmod D$的$f(i)$最小值，每一次就是询问前缀后缀的最小值，按照上面的DP转移式转移即可

# 匹配

## 题目大意

![20211101T2](D:\Blog\image\20211101T2.PNG)

## 算法讨论

首先我们定义一个集合族$f(s)$其中的元素是每一个字符对应位置的集合

首先一个字符串$s$，可以跟字符串$t$匹配，当且仅当$f(s)=f(t)$

那么我们考虑对$f(s)$进行Hash，由于是对集合进行Hash，那么需要一种无序的运算，要么是加要么乘或者异或，这里选择乘（虽然有概率冲突，但是整体上不大），我们定义$h(f(s))=\prod\limits_{S\in f(s)}\sum\limits_{i\in S}base^i$

可以先预处理出来$h(f(t))$

考虑从小到大枚举s中子串的最左边的位置，同时维护每一种数字的出现次数以及出现的数字种类个数，并且对于每一种数字维护$\sum\limits_{i}[s_i=c] base^{i}$

那么我们在移动的时候最多更新两种数字的hash值，那么在总的hash去除之前这种颜色的hash值即可，然后乘上新的

在判断是否匹配的时候，首先判断出现数字种类个数是否相同，然后需要将当前维护的s子串的hash除以若干次，与其比较

需要注意只能用单模数，否则会被卡常

时间复杂度$O(n\log n)$，主要有除法，需要快速幂

# 图

## 题目大意

![20211101T3](D:\Blog\image\20211101T3.PNG)

## 算法讨论

首先最大的k就是$s,t$之间的最短路$d$，如果$k>$最短路的话，那么考虑最短路路径，路径上边权种类最多只有d种，如果删去这$d$种之外的某一种边权，那么显然s,t通过最短路进行联通

然后求出s到每一个点的最短路，然后建出分层图，对于一条边，我们将其权值设为两个端点中最短路较大的那个，如果超过$d_t$，那么将这个边权设为0

显然删除其中某一个边权k，就是将$>k$的点和$\leq k$的点分割开

# 异或

## 题目大意

![20211101T4](D:\Blog\image\20211101T4.PNG)

## 算法讨论

首先找到$x$的最高位$k$（如果$x=0$，那么答案就是$2^{n}-1$）

那么显然对于k位之前的位数，任意选都是合法的，并且如果存在某一位不同的话，我们就不需要考虑之后的位了

那么我们将所有n个数按照k位之前的位上的数字进行分组，对于组之间来说异或和$\geq x$的条件是一定满足的，然后考虑同一组内的情况

可以发现对于同一组可以发现最多只能选出两个数，因为如果选出了三个数，至少存在两个数之间在第k位是相同的

首先选出0,1个数是简单，只需要考虑选出两个数，可以枚举其中一个数$a_i$，相当于是询问有多少个数异或$a_i\geq x$，那么可以用Trie解决
