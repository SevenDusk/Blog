# **Swap**

## 题目大意

给定一个只含KEY三个字符的字符串，求出经过k次交换之后可以得到多少不同的字符串
$$
|S|\leq 30
$$

## 算法讨论

首先考虑，给定两个字符串s,t，求出最小需要的交换步数，记字符$x$，在s中出现集合为$ps_x$

那么对于每一个字符x，以及出现次数i，将$p_{ps_x(i)}=pt_x(i)$

然后就是将p序列进行排序，这是一个排列需要最小交换次数为其逆序对数

那么如果$k>\frac{n(n-1)}{2}$的话，那么所有可能字符串都是可以达到，方案数就是$\binom{n}{a,b,c}$

那么考虑$k\leq \frac{n(n-1)}{2}$的情况，那么设$dp(i,j,k,p)$表示当前考虑到第i个位置，K用了j个，E用了k个，其中逆序对的数量为p

然后枚举下一个位置i+1是放哪一个字符，然后求出前面放置的字符串的p，

然后可以预处理处理$last_i$表示i位置之后三个字符出现的最近位置，以及标号

假设i+1放的的是K，那么逆序对数需要加上$k-last_{ps_x(j+1),1}+i-j-k-last_{ps_x(j+1),2}$的贡献，这个就是之前放置的位置在i+1之后的数量

时间复杂度$O(|s|^5)$

### Solution 2

考虑枚举最终得到字符串的前缀，每一次删除原字符串的一个字符，需要的代价就是将这个字符放到最前面的次数

然后进行记忆化搜索，复杂度等于原字符串本质不同子序列数量

# **Treasure Hunting**

## 题目大意

给定$n\times m$的网格，每一个格子上有一个数字，每一次从$(1,1)$出发，向右向下走到$(n,m)$，代价为走过格子前k大之和，求最小代价

## 算法讨论

### Solution 1

考虑枚举第k大的数为多少，显然这个只会出现在格子出现过的数中，那么需要$O(n^2)$枚举

假设记作$v$，可以发现对于$a_{i,j}<v$的都是没有贡献的，而对于$a_{i,j}\geq v$，如果我们一开始将贡献$v\times k$加上，那么只会有$a_{i,j}-v$

那么整合在一起就是$\max(0,a_{i,j}-v)$的贡献

这样就不需要考虑与v相同的有很多，但是产生贡献的只有一部分的情况

然后如果路径上$a_{i,j}\geq v$少于k个，那么说明当前的v枚举大了，计算中的贡献是大于实际贡献的，不会对答案产生影响

那么设$dp(i,j)$表示走到$(i,j)$的最小贡献和，$dp(i,j)=\max(dp(i-1,j),dp(i,j-1))+\max(0,a_{i,j}-v)$

时间复杂度$O(n^2m^2)$

### Solution 2

同样还是枚举第k大的数是多少，但是在路径计算过程中只将$\geq v$的数加入贡献

这样会有一个问题，如果$=v$的数出现次数较多，如果按照上面的计算就会多计算进去v

那么我们需要枚举的是所有可能第k大中最左上的那个位置，那么在比较的时候如果$>v$直接加入贡献，如果$<v$不加入贡献，否则如果$=v$，并且$(i,j)>(x,y)$才可以加入贡献

那么设$dp(i,j,c)$表示走到$(i,j)$加入贡献的有$c$个位置的最大贡献

最终答案为$dp(n,m,k)$

时间复杂度$O(n^3m^2)$

# **Divisors of Binomial Coefficient**

## 题目大意

求$\binom{n}{k}$的因数个数
$$
n\leq 10^{12},k\leq 10^6
$$

## 算法讨论

首先$\binom{n}{k}=\frac{n(n-1)...(n-k+1)}{k!}$

那么我们需要求出每一个质数在这个式子中的次数为多少才行

对于$\leq \sqrt n$的质数，我们是可以处理出来的

而对于$>\sqrt n$的质数会发现其中一个数最多只会出现一次

那么我们将$n,n-1,...,n-k+1$这些数的$\leq \sqrt n$的质因数去掉之后，对于不等于1的数，相当于就是出现的质因数，由于$k\leq \sqrt n$，那么说明这些$>\sqrt n$的质因数不会重复，贡献就是$2^k$，k为出现$>\sqrt n$的质因数个数

然后对于$\leq \sqrt  n$的因数，求出其在$n,n-1,...,n-k+1$的出现次数，具体来说就是不断将n除以这个质因数的若干次的结果求和即可

然后需要将这些位置的质因数都去掉，那么直接调和级数枚举过去即可

时间复杂度$O(\sqrt n\log \sqrt n)$

# Eat Them All

## 题目大意

给定$3\times 3$的网格，每一个格子上存在一个数，现在要从$(1,1)$出发不断重复以下过程

- 将当前所在格子数-1，然后移动到相邻的四个格子中之一

直到走到一个格子中的数为$0$的时候结束

要求结束的时候所有格子都为0，并且回到$(1,1)$

## 算法讨论

首先题目有解的一个必要条件就是，将格子黑白染色，然后染成白色格子的数之和等于黑色格子数之和

这是由于每一次移动到相邻格子的时候所在格子的颜色一定会发生变化

由于最终回到$(1,1)$，那么走过不同格子的数量是相同的，而每一次走到一个格子这个格子需要-1

然后由于最终需要回到$(1,1)$，那么在整一个线路中一定是可以找到一部分，形成了除中间一个格子以外的一个环

O<-O<-O

|           |

O   O    O

|		   |

O->O->O

那么可以先将环上的$a$减1，剩下的操作就是在某两个相邻节点之间来回走，相当于将这两个数都减1，需要注意的是对于环上中间的四个节点来说，是可以跟$(2,2)$这个位置进行来回走的

然后如果我们确定$(1,1),(2,1)$之间来回走的数量，那么我们就可以确定整个环上的方案，那么我们可以枚举$(1,1),(2,1)$之间来回走的数量

然后按照环的顺序进行判断，假设环上第i个数为$a_i$，那么当判断到第i个位置的时候默认前面$[1,i-1)$都是已经变成0了，那么当前$a_i$要变成0，就需要在$i+1$个位置之间来回走即可

如果还有剩余，判断是否在$(1,2),(2,1),(3,2),(2,3)$这四个位置上，如果是还可以与$(2,2)$来回走

如果过程中都是可以将整个环上的数变成0，那么说明是合法的

至于输出方案就是按照环的顺序输出，对于环上第i个节点，首先输出来回走的方案，最后再输出沿着环走的方向即可

**由于任何一个合法方案都是可以拆出这个环，那么这个判断过程就是合法的充分必要条件**

