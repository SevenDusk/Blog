# 9.5

## A.三角形

### 题目大意

![20210906T1](D:\Blog\image\20210906T1.PNG)

### 算法讨论

考虑将三元环函数化，变成一个构造函数的问题

假设有二元函数$f(i,j)$表示包含$i,j$的三元环另外一个点为$f(i,j)$

这个函数需要满足以下几条限制

- $f(i,j)=f(j,i)$
- $f(i,k)=j$
- $f(k,j)=i$

如果列出这几个条件，会发现$f(i,j)=-(i+j)\% n$就是满足条件的，枚举$i,j$如果边没有重复那么就选取，这样每一个点连出的边最多只有一个没有被三元环覆盖

像这种构造题转化为构造函数的方法值得借鉴

## B.区间

### 题目大意

![20210906T2](D:\Blog\image\20210906T2.PNG)

### 算法讨论

首先如果一个大区间覆盖了一个小区间，那么这个大区间要么跟这个小区间在一个组内（不会产生任何影响），要么单独在一个组内（因为加到其他组只会减少交的长度，肯定不优）

那么如果将所有有包含区间的大区间去掉，**那么剩下的区间之间的关系只有相交或者不交，那么如果按照左端点排序，那么其右端点一定是递增的**

那么说明同一组的区间在这个区间序列中一定是一段区间，那么设$dp(i,j)$表示当前考虑到第$i$个区间，分成了$j$个组的最大答案
$$
dp(i,j)=\max\limits_{k< i} dp(k,j-1)+r_{k+1}-l_i
$$
最后需要考虑那些去除的大区间，按照长度排序，选取前$k-j$大的

时间复杂度$O(n^3)$

## C.三染色

### 题目大意

![20210906T3](D:\Blog\image\20210906T3.PNG)

### 算法讨论

由于要联通，那么至少这些黑色边要形成一个树，不妨就让这个树为这张图的dfs树

首先将这些树上的点黑白染色，黑色点和白色点染成的颜色不能相同，假设黑色点有$a$个，白色点有$b$个，令$a\leq b$

#### $a\geq \frac{n}{3}$

由于黑白色的点数量比较接近，考虑构造方案使得满足第一种条件

首先将黑色点按照树上的度数进行降序排序，然后将前$\frac{n}{3}$个点染成一个颜色，这时候需要发现一个结论

> 对于剩下的黑点其在树上的度数$\leq 2$

考虑反证，如果剩下黑点中度数最大的$>2$，那么前$\frac{n}{3}$的度数$\geq 3$，其连出的边至少有$\frac{n}{3}*3=n$条，与树的结构矛盾

由于剩下的不超过$\frac{n}{2}-\frac{n}{3}=\frac{n}{6}$，那么最多有$\frac{n}{3}$个白点与其相邻，那么只要将所有剩下的黑点和一部分与之不相邻的白点染成一个颜色，再将剩下的白点染成一个颜色即可

#### $a\leq \frac{n}{3}$

考虑构造满足第二种条件

如果将所有白色叶子节点删除，那么剩下的树的叶子节点一定都是黑色，那么白色节点的数量$\leq $黑色节点的数量

那么说明在原来的dfs树中，白色非叶子节点数量$\leq \frac{n}{3}$，由于$b\geq \frac{2n}{3}$，那么说明白色叶子节点数量$\geq \frac{n}{3}$，由于dfs树的性质，只存在返祖边，那么所有叶子节点之间是没有边存在的，那么只需要给所有叶子节点然同一种颜色即可

剩下黑色节点和白色非叶子节点染另外一种颜色

## D.匹配

### 题目大意

![20210906T4](D:\Blog\image\20210906T4.PNG)

### 算法讨论

首先$n$为奇数的时候一定无解

考虑删去树上的边$(u,v),v=fa(u)$，如果$u$子树的大小为偶数，那么显然另外一部分也是偶数，那么这两个部分都必须要有完美匹配，贡献就是$sz(u)(n-sz(u))$

那么只剩下分出的部分都是奇数的情况，那么显然每一个部分都必须要恰好一个点没有被匹配，然后在这两个点之间连边即可

显然两个部分是独立的，分别算出有多少个点符合条件，然后相乘起来就是对答案的贡献

考虑设$dp(i,0/1,0/1)$表示$i$子树内，$i$这个节点是否匹配，子树内除了根节点是否存在一个没有匹配的节点的方案数，考虑合并两个有父亲儿子关系的子树，$x=fa(u)$
$$
dp'(x,0,0)=dp(x,0,0)dp(u,1,0)\\
dp'(x,1,0)=dp(x,0,0)dp(u,0,0)+dp(x,1,0)dp(u,1,0)\\
dp'(x,0,1)=dp(x,0,1)dp(u,1,0)+dp(x,0,0)(dp(u,1,1)+dp(u,0,0))\\
dp'(x,1,1)=dp(x,0,1)dp(u,0,0)+dp(x,0,0)dp(u,0,1)+dp(x,1,1)dp(u,1,0)+dp(x,1,0)(dp(u,1,1)+dp(u,0,0))
$$
然后由于要求出去除一个子树的联通块信息，那么需要换根DP，但是这里是合并子树的做法，存在乘法，如果直接撤销可能会出现除以0的情况，那么就需要在转移的时候，记录前缀合并的结果，后缀合并的结果，然后将两个合并起来（这里的合并不是合并子树的那种，而是合并答案）
$$
dp'(x,0,0)=dp(x,0,0)dp(u,0,0)\\
dp'(x,0,1)=dp(x,0,0)dp(u,0,1)+dp(x,0,1)dp(u,0,0)\\
dp'(x,1,0)=dp(x,1,0)dp(u,0,0)+dp(x,0,0)dp(u,1,0)\\
dp'(x,1,1)=dp(x,1,1)dp(u,0,0)+dp(x,1,0)dp(u,0,1)+dp(x,0,1)dp(u,1,0)+dp(x,0,0)dp(u,1,1)
$$

#### 另解 1

设$dp(i)$为一个二元组，第一个位置记录$i$子树当前$i$是否匹配，第二个位置记录在最大匹配的情况的方案数

同时dfs的时候需要记录一下子树的大小为偶数的数量，加上第一维才是真正的匹配大小（因为要计算方案数）

如果为偶数，那么用$dp(i).first-1,dp(i).second$更新

否则用$dp(i).first+1,dp(i).second$更新

至于换根部分也是同理，由于也是存在乘法，需要记录前缀和后缀和

#### 另解 2

可以将$dp(x,0/1,0/1)$的转移方程写成类似矩阵乘法的东西，并且满足交换律，然后将转移的相交即可

令$tran(dp(x))$输出一个2*2数组$A$，其中
$$
A(0,0)=dp(x,1,0),A(0,1)=dp(x,0,0)+dp(x,1,1),A(1,0)=dp(x,0,0),A(1,1)=dp(x,0,1)
$$
然后一次转移就是，对于$i,j\in\{0,1\},k\in[0,1-i],p\in[0,1-j]$
$$
A'(i+k,j+l)=A(i,j)\times B(k,l)
$$
只要将tran相加，就是得到合并后数组的tran