# Purple Crayon

## 题目大意

现在有两个人进行博弈，其中一个可以进行以下操作任意次，选择一个子树，然后将子树内所有节点染成红色，最终染成的颜色数量不超过k，另一个人可以进行任意次操作，选择一个子树，并且子树内不存在红色节点，然后将子树内所有节点染成蓝色

假设最终白色节点有w个，红色节点有r个，蓝色节点有b个，求$w(r-b)$的最大值

## 算法讨论

假设我们固定了第一个人的选择，那么我们求出哪些节点必须要染成白色，哪些节点可以被染成蓝色

假设有a个节点可以染成蓝色，b个节点必须要是白色，c个节点已经染成红色

其中$a+b+c=n$

假设第二个人将a个节点中x个染成蓝色，那么贡献为$(b+a-x)(c-x)=x^2-nx+c(b+a)=x^2-nx+c(n-c)$显然如果按照从叶子开始选的策略（就是选择一个可以染成蓝色的叶子节点就把这个节点删除，然后不断选叶子节点，任意时刻都是合法的染色方案），对于所有的x都可以取到

**那么第二个人需要最小化贡献，那么根据二次函数极值点的公式$x=\min(\frac{n}{2},a)$的时候取到最大值，二分也可以，就是二次函数是凸的求出一个位置的斜率大于0即可**

可以发现的是对于$f(x)=x^2-nx$，其关于a的最小值函数$g(a)$是减函数，那么第一个人要在固定c的情况下，最大化b

由于我们需要最大化b，那么尽可能将红色节点染在叶子节点上，而b相当于是所有红色节点到根路径的节点集合的并的大小（除去红色节点）

那么一个贪心的策略就是，选择在未选节点中可以增加集合大小最大的那个节点，事实上如果要证明就是我们相当于每一次都选择了一个当前最长链的底，肯定是选择所有长链中最长的那个（长链有叶子节点个），那么我们贪心的做法就是对的

有两种实现方式，分别是直接按照贪心的策略选和按照证明的过程选

- 如果直接按照贪心做法，我们可以用一个线段树维护每一个叶子节点上面未确定的节点数量，每一次选最大的那个，然后不断向上跳，直到访问到一个之前访问的节点，然后将这些新访问的节点用dfs序在线段树上消除掉贡献即可 **tourist** https://codeforces.com/contest/1615/submission/140464011

- 如果按照证明的做法，就是将所有点按照深度排序，求出长链的链长，然后再按链长从大到小选择即可**Radewoosh** https://codeforces.com/contest/1615/submission/140474425

那么就从小到大枚举c，如果$k>$叶子数量，那么需要特殊判断一下，然后按照上面的贡献求出最大值即可

时间复杂度$O(n\log n)$

miracal03和ksun48被Hack的原因是，在叶子数量$>k$的时候，蓝色的节点取0不一定是符合蓝色最优的策略（红色此时不会将所有节点染成红色，这样贡献不优），而是要取到$\min(a,\frac{n}{2})$才是最优的情况，a不一定为0
