# A.提前

## 题目大意

![20211008T7](D:\Blog\image\20211008T7.PNG)

## 算法讨论

可以直接用链表进行维护，需要支持链表插入和删除

每一次提前的话，那么先再链表中删除这个数，然后将这个数插入到链表头部

时间复杂度$O(n)$

# B.密码

## 题目大意

![20211008T8](D:\Blog\image\20211008T8.PNG)

## 算法讨论

先处理出来kmp数组，然后显然合法长度就是$nxt_n,nxt_{nxt_n},...,$

那么先枚举合法长度$len$，然后会发现如果在字符串中间出现过一次，那么一定存在一个$i\in (1,n)$，满足$nxt_i=len$

直接用一个桶记录即可

时间复杂度$O(n)$

# C.树的重构

## 题目大意

![20211008T9](D:\Blog\image\20211008T9.PNG)

## 算法讨论

首先考虑如何判断一个点i是否合法，那么先将i作为根，然后dfs一遍求出每一个点子树大小

如果i连接的所有儿子大小都$\leq \frac{n}{2}$，那么显然合法，否则一定只有一个儿子的子树大小$v>\frac{n}{2}$，那么我们就需要在这个子树找到一个点$x$，满足$v-sz_x\leq \frac{n}{2},sz_x\leq \frac{n}{2}$，然后将x子树接到i上，那么就合法

显然这个条件就是充分必要条件，我们可以将$sz_x$需要满足的不等式写出$v-\frac{n}{2}\leq  sz_x\leq \frac{n}{2}$

那么注意如果一个树存在两个重心，那么一定可以选择一个重心，使得$sz_x=\frac{n}{2}$这样所有点一定合法

否则我们就按照这个重心作为根，那么显然除了重心以外的所有点最大的子树一定是往父亲的那个子树

由于我们$sz_x$要取在$\frac{n}{2}$之内尽可能大的子树，那么显然就是根到节点路径上所有节点的儿子子树（去除路径上的点）子树大小的最大值

这个只需要记录儿子子树大小最大和最小值即可

时间复杂度$O(n)$

# D.阶梯

## 题目大意

![20211008T10](D:\Blog\image\20211008T10.PNG)

## 算法讨论

由于7是可以直接状压的，我们需要先考虑一个暴力的状压DP

这里的状压是对于一列内部线条是否加粗的状压，那么可以简单的进行预处理，来进行转移，那么可以显然的写成矩阵乘法的形式

然后直接矩阵快速幂即可

时间复杂度$O(7^4\log s)$

