# D.Cutting Woods

## 题目大意

给定长度为l的一段木头，现在要进行q个操作

- 1 x，将这个木头在x处砍断，保证x互不相同
- 2 x，求出木头在x处所处段的长度

$$
l\leq 10^9,q\leq 2*10^5
$$

## 算法讨论

一个最简单的做法，就是用set维护连续段（按照顺序作为关键字），删除的时候，就直接删除当前段，从set中删除，然后插入两个分开的长度（需要记录左端点的位置）

其中set有用压位trie来实现的[Submission #25605064 - AtCoder Beginner Contest 217](https://atcoder.jp/contests/abc217/submissions/25605064)常数极小，就是对于平衡树中的关键字，二进制分解，每64位存在一个unsigned long long 中，一个位就相当于一个trie节点，可以对于每一个位vector存即可（存6个就是所有int范围之内的都可以表示出来），$a_{i,x}$表示前64i位的情况为x的儿子节点（用unsigned long long压位存），然后这道题要求出前驱后继，那么只需要先二分出查询数在trie中的位置，然后从高位往低位选取最接近的那个，具体实现是直接左移若干位然后用__builtin_ctz求出末尾有多少个零，还原出原来这64位的情况就可以转移到下一个节点了

还可以倒过来考虑，将删除变为合并，那么只需要用并查集维护就可以了

# E.Sorting Queries

## 题目大意

初始给定空序列$A$，现在给出Q个操作

- 1 x，在A最后增加元素x
- 2输出A的第一个元素，然后删除这个元素
- 3将A升序排序

## 算法讨论

考虑用一个set维护有序部分的A（这一部分一定在queue部分前面），一个queue维护另外一部分，1操作只要在queue最后加入即可，2操作先考虑set中是否为空，否则考虑queue，3将queue中所有元素插入到set中

# F.Make Pair

## 题目大意

现在有$2n$个学生，$m$对之间是好的

现在有以下过程，在剩余学生中找到两个相邻的学生使得他们之间是好的，然后删除这两个学生，然后将序列拼接起来

求出不同的操作顺序
$$
n\leq 200
$$

## 算法讨论

如果$i,j,i<j$匹配的话，那么说明$(i,j)$区间里面的学生对应的匹配学生一定都是在区间里面的

如果将$[i,j]$看作区间的话，那么所有区间都应该不交，一开始以为只有((...))的情况没考虑到有(()()()...)的情况

那么就是形成了一个树形的结构（可能是森林），如果已经知道其结构，那么方案数就是这个森林做拓扑排序的数量，那么经典结论
$$
\frac{n}{\prod sz_i}
$$
其中这里一个区间的sz就是$\frac{j-i+1}{2}$

考虑设$dp(i,j)$表示当前考虑到区间$[i,j]$的贡献，设$ok_{i,j}$表示i和j之间是否能匹配
$$
dp(i,j)=[ok_{i,j}=1]dp(i+1,j-1)\frac{2}{j-i+1}+\sum\limits_{k=i+1}^{j-1}[ok_{i,k}=1\and (k-i+1)\%2=0] dp(i+1,k-1)dp(k+1,j)\frac{2}{k-i+1}
$$
其中需要强制前面的那个区间被一个大区间覆盖，否则会算重

时间复杂度$O(n^3)$

# G.Groups

## 题目大意

现在给定$n,m$，对于$k=1,...,n$，求出将$n$个数分成$k$个集合，并且同一个集合中没有模$m$相同的数的方案数
$$
m\leq n\leq 5000
$$

## 算法讨论

记$c=\lceil \frac{n}{m}\rceil$，$a$为n个数中模m等于c的组数，b为n个数中模m等于c-1的组数

枚举$k$考虑对于空盒子容斥，首先假设所有盒子不同，最后除以$k!$即可
$$
\sum (-1)^i \binom{k}{i} (A_{c}^{k-i})^a(A_{c-1}^{k-i})^b
$$
预处理一下复杂度就是$O(n^2)$

# H. nuketoon

## 题目大意

有一个人开始在0位置，然后每一秒可以选择向左走一步，不动，向右走一步，有n个时刻$(T,D,X)$

表示在T时刻，在X位置会发出一个水柱

如果D=0，并且当前的位置为p，那么就会产生$\max(0,X-p)$的代价

如果D=1，那么就会产生$\max(0,p-X)$的代价

求出最小代价
$$
T\leq 10^9,n\leq 2*10^5
$$

## 算法讨论

考虑一个暴力DP，设$dp(i,j)$表示当前时刻为$i$，在$j$的位置的最小代价，转移很好转移，复杂度是$O(nT)$

考虑优化，可以发现如果将$dp(i,j)$看作关于j的函数，由于每一次加入的新函数都是半个绝对值函数的类型

那么一定是一个凸包那么对于这种函数，是一个下凸包，并且存在$[-i-1,i+1]$斜率的函数

首先关注最简单的情形$i=1$时，$dp[1]=\max(0,j-x_i)$，就是半个绝对值函数的样子

将情况扩展，当前的函数由两部分组成，$dp[i-1]$在某一段区间的最小值，首先看$dp[i]$这一部分的贡献，这个区间取$\min$操作相当于是把这个函数从斜率为$0$的部分劈开，各自向左向右平移得到

形式化的，对于函数斜率为$0$的分界点$a_{i-1},b_{i-1},a_i=a_{i-1}-(len_i-1),b_i=b_{i-1}+(len_{i-1}-1)$

然后考虑$y=\max(0,x_i-j)$的话，对于原来函数在$x_i$左边的图像，所有线的斜率$-1$，$y=\max(0,j-x_i)$对于在$x_i$右边的图像，所有线的斜率$+1$

通过上面性质的分析，那么可以用两个堆来维护这些斜率的分界点，每一次扩展的时候，讨论$x_i$的位置，然后维护一下，斜率为$0$的取值，最终答案就是$dp[n]$斜率为$0$部分的取值

时间复杂度$O(n\log n)$