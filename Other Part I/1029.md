# Four Melodies

## 题目大意

定义一个 Melody 子序列为，子序列中任意两个相邻元素差为 1 或模 7 同余，这里的子序列不要求连续。

给定一个长度为 n 的序列，求出一种选出 4 个互不相交的 Melody 子序列的方案，使得它们的并的大小尽量大。输出这个大小。

## 算法讨论

首先edu之前有一道题目[Problem - D - Codeforces](https://codeforces.com/contest/813/problem/D)

是拆分成两个序列，这个是可以直接DP解决，但是这道题是分成了四个序列，那么就无法这样进行

考虑一个子序列中某一个位置的下一个位置，可以到达的位置要么是跟当前的元素同余的元素要么相差1，并且这个位置一定在当前这个位置之后

如果我们将所有位置拆点，限制这个位置最多只能出现在一个子序列中，然后这个价值设为为1，然后建图完跑最大费用最大流得到答案

首先考虑其中一个条件“与当前元素同余”，我们可以开7个桶，每一个桶中记录互相同余的元素，按照位置进行排序，相当于我们连边的是当前这个序列的一个后缀

我们可以用前后缀优化建图

<img src="D:\Blog\image\graph-1619099890299.png" alt="graph" style="zoom: 50%;" />

注意我们连边的是用拆点的一段连向拆点的另外一端

对于相差为1的情况也是同理

然后我们还要限制最多只能拆成4个子序列，那么我们将源点拆点，中间的连边容量设为4，然后另一端连向所有位置的上端节点

# Army Creation

## 题目大意

n个数a[i],q次询问,$n,a[i],q\leq 10^5$. 每次问$[l,r]$内最多可以选多少个数,满足同一个数的出现次数不超过k?

## 算法讨论

如果在区间内某一个种数出现了大于k次，那么我们只统计最后k个位置

我们可以预处理出来对于所有位置i，求出最小的位置$b_i$，使得$[i,b_i]$出现了恰好$k$个$a_i$

那么原问题答案为统计有多少个$i\in [l,r],b_i>r$，那么可以使用线段树进行统计

# Bipartite Checking

## 题目大意

给你一个由n个顶点组成的无向图，最初在图中没有边。同时给你q次查询，每次查询时会向图中添加一个无向边或者删除一个无向边。 在每次查询之后，您必须检查结果图是否为二分图（在保证没有连接相同颜色的两个顶点的边的条件下，您可以将图的所有顶点绘制为两种颜色）

## 算法讨论

直接将一条边存在的时间段插入到线段树中，然后用并查集判断一张图是否为二分图，然后需要实现栈序撤销

# Imbalanced Array

## 题目大意

对于一个序列的所有子段，求出其极差和

## 算法讨论

等价于，每一个子段的最大值和减去每一个子段的最小值和

那么可以用单调栈求出一个位置左边第一个$\leq a_i$的数，右边第一个$<a_i$的位置，然后这两个位置并且跨过i的区间的最小值都是$a_i$

那么统计就是$a_i(i-l)(r-i)$，求和即可

对于最大值计算也是同理

# Choosing The Commander

## 题目大意

有Q次操作，每次操作有三种类型，分别是

> 1 $p_i$ 把 $p_i$ 加入集合 S
>
> 2 $p_i$ 把 $p_i$ 从集合 S 中删除
>
> 3 $p_i,l_i$ 表示查询集合中有多少个元素异或上 $p_i$ 后 小于 $l_i$

集合为可重集。

## 算法讨论

对于第三个操作，我们可以枚举$p_i\bigoplus p_j$是在哪一位上小于$l_i$的，那么显然这一位$l_i$为1，那么我们需要的二进制前缀异或和这一位为0，至于之后位的数都是不需要考虑

那么我们需要统计存在某一个二进制前缀的数个数，可以直接用字典树进行维护即可

# MEX Queries

## 题目大意

![20211029T1](D:\Blog\image\20211029T1.PNG)

## 算法讨论

首先对于所有询问的区间进行离散化，我们需要离散化四个位置$l,r,l-1,r+1$，**（需要注意l-1可能等于0，不能将其离散化进去）**

那么所有询问的答案一定在这些离散化的位置中

那么对于所有位置建一个线段树，然后每一个节点维护当前区间内没有在s中出现的个数，那么第1，2个操作都是区间覆盖，然后第三个操作就是翻转，注意需要将1，2种的标记也翻转

然后回答询问就是线段树上二分即可

# Card Game Again

## 题目大意

![20211029T2](D:\Blog\image\20211029T2.PNG)

## 算法讨论

首先将k质因数分解，那么显然对于k的每一个质因数$p_i$，假设其次数为$r_i$，那么区间内$p_i$出现次数$\geq r_i$

那么我们对于每一个位置求出最小的位置为k个质数，那么显然我们对于每一个质因数都求出这个位置，然后进行取min即可

那么对于一个质因数来说就是求出出现次数的前缀和，然后进行二分即可

# Level Generation

## 题目大意

![20211029T3](D:\Blog\image\20211029T3.PNG)

## 算法讨论

首先假设一开始的图有n-1个桥，相当于就是一个树，那么我们现在要加入尽可能多的边，但同时需要满足条件，假设我们将原来x个桥变成不是桥，加入了k条边

那么我们需要有以下条件成立
$$
2(n-1-x)\geq m=n-1+k\\
k\leq \frac{x(x-1)}{2}
$$
解出$k\leq \min(\frac{x(x-1)}{2},n-1-2x)$

那么我们就需要求出$\min(\frac{x(x-1)}{2},n-1-2x)$的最值

由于这两个函数一增一减，那么显然是在两者最接近的时候取到最值，那么我们二分出这个位置即可

# Minimal Labels

## 题目大意

![20211029T4](D:\Blog\image\20211029T4.PNG)

## 算法讨论

反向拓扑序，然后用大根堆替代原来的队列即可

# String Compression

## 算法讨论

给定一个串s，其中重复出现的子串可以压缩成 “数字+重复的子串” 的形式，数字算长度。

只重复一次的串也要压。

求压缩后的最小长度。

## 算法讨论

设$g(n)$表示n十进制表示下数字的个数

设$f(i)$表示当前压缩到第i个位置的最小长度，那么我们需要将$[i+1,j]$压缩成一段的最小代价

那么我们先固定i，然后将$t=s_{i+1...n}$，对t求出kmp的nxt数组，那么对于其中第j个位置，记$d=j-nxt_j$，假设$d|j$，那么其最小循环节就是$d$，那么相当于我们需要求出一个最优的$k$，使得$kd+g(\frac{j}{kd})$最小

注意到$g(\frac{j}{kd})\leq 4,d\geq 4$，那么我们只需要求出最小的8个k，进行处理即可

预处理所有数的因数即可

时间复杂度$O(8n^2)$

# Tree Queries

## 题目大意

![20211029T5](D:\Blog\image\20211029T5.PNG)

## 算法讨论

首先将第一次修改的黑点抓出来，作为树根，然后我们 dfs 一遍这棵树，记 $a_i$ 代表第 i 个点到根节点路径上最小的编号

之后对于每一次修改，显然对于修改点的子树里的点的答案是不会有变化的，如果不在子树内，那么第 j 个点的答案就要与修改点到根路径的最小编号取min，所以在每次修改后记录一个所有黑点最小的到根路径上的最小编号，对于每次查询只需要将这个值与本身这个点到根路径上最小值取 min 即可

# Vasya's Function

## 题目大意

要求计算$f(a,b)$，定义为
$$
f(a,0)=0\\
f(a,b)=1+f(a,b-gcd(a,b))
$$

## 算法讨论

可以发现的是，随着这个过程进行，$gcd(a,b)$是不降的，并且增加的位置最多只有$\log n$个，那么我们需要求出每一个分界点

首先假设一开始$gcd(a,b)=1$，当前$a,b$进行$k\geq 0$次操作之后，$gcd(a,b-k)\neq 1$，那么我们可以 将问题转化为$a'=\frac{a}{gcd(a,b-k)},b'=\frac{b-k}{gcd(a,b-k)}$的问题

那么我们只剩下求出最小的$k$，那么我们可以枚举每一个$d|a$，然后求出$b\bmod d$的最小值，其中$d\neq 1$

求出的最小值就是k

时间复杂度$O(\sqrt n\log n)$

# Prefix Sums

## 题目大意

有一个函数p(x),其中x是一个包含m个整数的数组。p(x)会返回一个长度为m+1的数组y，yi是x数组前i项的和。（0<=i<=m）

例如：x={1,1,1} y=p(x)={0,1,2,3}

现有一列数组A0,A1,A2,……其中A0中的数据会给你，而Ai=p(A(i-1))。有一个整数k，你要求出一个i,在Ai中的某个数大于等于k。

输入第一行是n,k,第二行是A0中的n个数。

要求输出最小的i。

## 算法讨论

首先我们只需要关系$A_i(n)$
$$
A_i(n)=\sum\limits_{j=1}^n  \binom{i+n-j}{i} A_j
$$
那么我们先二分答案，然后按照这个式子计算即可

注意中间可能会超过long long的范围，化乘为除即可

**需要注意的是如果判断组合数的话，需要预处理前缀0的个数，然后直接break**

# Functions On The Segments

## 题目大意

![20211029T6](D:\Blog\image\20211029T6.PNG)

## 算法讨论

对于x的分界点建出主席树，节点记录$a,b$分别表示a之前的系数和常数和

然后需要标记永久化，然后询问就是两个主席树作差即可

