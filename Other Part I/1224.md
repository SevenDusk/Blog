# Yet Another LCP Problem

## 题目大意

![20211224T1](D:\Blog\image\20211224T1.PNG)

## 算法讨论

首先将整个串翻转，那么后缀就变成了前缀，相当于求两个前缀的LCS长度

那么可以对于这个串建出sam，那么两个串对应着的节点的LCA的length就是这两个前缀的LCS长度

那么现在给出集合，那么我们求出这些前缀代表的节点在后缀树上的虚树，那么对于任意两个集合中的节点的LCA都是在虚树上

那么dfs遍历整个虚树，然后在每一个节点维护子树内在a集合中出现次数，b集合出现次数，然后将LCA为当前节点的点对数量乘上当前节点的length贡献到答案即可

时间复杂度$O(n\log n)$，瓶颈在于求LCA

# Choosing Two Paths

## 题目大意

![20211224T2](D:\Blog\image\20211224T2.PNG)

## 算法讨论

首先最终最优解中两个链一定是有公共部分的

那么两条链的公共部分一定还是一条链，假设其端点为$a,b$，那么这个条链是合法的当且仅当a,b度数至少为3，由于在公共的部分的最长的前提下，需要总链长最长

那么需要在a,b的儿子子树中选取两个最深和次深的子树

首先考虑如何求出最长的公共部分，那么我们可以先保留树中度数$\geq 3$的节点，然后求出直径即可，需要注意这里直径的两个端点可能有多个，那么需要选取其中最深深度+次深深度最大的两个端点即可

至于求最深深度和次深深度可以在dfs过程中简单维护处理

时间复杂度$O(n)$

# Petya and Graph

## 题目大意

定义图权 == 图中边权总和 -− 图中点权总和（空图的图权 = 0=0），求 n 个点 m 条边的无向图最大权子图。

## 算法讨论

首先对于每一条边建一个节点，然后连向这条边两端的节点，那么就变成了求最大权闭合子图

建立源点和汇点，源点向所有正权边连点权大小容量的边，所有负权边向汇点连负点权大小容量的边

然后求出最小割即可，用最大流实现

# Array Game

## 题目大意

![20211224T4](D:\Blog\image\20211224T4.PNG)

## 算法讨论

首先如果物品离开了当前格子，那么就无法再回来，那么在当前位置不断进行操作目的就是转化先后手顺序，那么与$a_i$的具体大小没有关系，只与其奇偶性有关

注意到m很小，那么假设我们已经知道当前这个位置之后m个位置，从这些位置出发先手是否必胜结果

那么如果后面m个位置存在某一个位置满足从这个位置出现先手必败，那么这个位置的人一定会直接走到那个位置使得另一个人输掉

如果所有位置都是先手必胜，那么当前位置的先手只会在当前位置消耗步数，不会主动走到后面的位置，那么如果当前的数-1为奇数，也就是当前的数为偶数，那么先手可以耗到另一个为先手的时候不得不走到后面的位置，那么此时先手必胜，否则先手必败

那么相当于我们知道后面m个位置是否存在先手必败和当前位置的奇偶性，就可以确定当前位置先手是否必胜，那么这相当于一个映射

首先可以发现每m个位置中最多有一个先手必败的位置，那么总共可能状态数就是$m+1$，将这些可能状态的集合记作$S$

那么我们在线段树上每一个节点维护一个映射$f:S\rightarrow S$，假设当前的区间为$[l,r]$，那么f的意义就是我们已知$[r+1,r+m]$的状态的话，经过f的映射之后求出$[l,l+m-1]$的映射

那么pushup的时候，将左右儿子的映射进行复合即可，假设左儿子的映射为$f$，右儿子的映射为$g$，那么最终的映射就是$f(g(x))$

那么询问的话求出$[l,r]$形成的映射，求出全部位置都是先手必胜的映射结果即可

时间复杂度$O(nm\log n)$

# Speed Dial

## 题目大意

![20211224T5](D:\Blog\image\20211224T5.PNG)

## 算法讨论

首先将所有字符串加入到字典树中，那么相当于我们需要在这个字典树中选出k个特殊点，其中根节点需要选择，并且不算到这个k个特殊点中

那么一个字符串的代价就是其结尾节点到根路径上最近的那个节点与结尾节点的距离乘上m

那么考虑DP，设$dp(i,j,k)$表示考虑到字典树上的i号节点，其中离当前位置最近的特殊节点编号为j，并且当前子树选择了k个特殊点

转移考虑两个子树的合并
$$
dp'(x,y,k)=\min dp(x,y,i)+dp(u,y,j)
$$
一开始的时候$dp(x,y,k)=m_x(dep_x-dep_y)$

如果将第三维限制到i的子树大小的话，那么时间复杂度就是$O(n^2\min(k^2,n))$

# Summer Practice Report

## 题目大意

![20211224T3](D:\Blog\image\20211224T3.PNG)

## 算法讨论

设$a$表示考虑到第i个字符串，拼接起来得到的字符串最后一位为T，最后最短的连续字符后缀长度

$b$表示最后一位为F的结果

考虑加入一个新的字符串

那么首先可以在开头放$k-a$个T，然后间隔一个F，然后再放k个T即可

那么最终得到的结果就是$\max(0,x_i-(k-a)-k\times y_i)$

对于b的更新也是类似的，如果$a>k$或者$b>k$，那么说明不合法

时间复杂度$O(n)$

