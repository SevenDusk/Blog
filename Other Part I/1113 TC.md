# GogoXReimuHakurai

## 题目大意

给定n个点m条边的有向图，求出最多有多少条路径可以从0到n-1，使得任意两条路径不相同

## 算法讨论

首先我们只考虑那些1和n之间的那些边和点，称$i$号点为好点当且仅当$1$号点可以到达$i$号点，$i$号点可以到达$n$点，边的定义也是同理

如果给所有除了$1,n$号节点的好点钦定一条出边，那么剩下没有被钦定的边的数量就是答案

我们对于所有点都记录是否被一条路径经过，考虑在经过一个之前没有被经过的点的同时确定这个被经过点的出边是什么

**每一次我们访问一个没有经过的点时候必须要经过入边出边两条边，而形成的新路径只有一条**

首先1号节点是没有被钦定出边的，那么说明所有这些钦定为某一个点的出边的边是构不成一条从$1$到$n$的路径的，那么任何一条路径都是包含至少一条没有被钦定的边

考虑一条没有被钦定的边$u\rightarrow v$，那么首先$v$可以通过那些被钦定的边直接走到$n$，不会使用任何新的没有被钦定的边，那么只需要1可以通过钦定的边或者已经使用过的边到达$u$即可

那么可以使用像bfs过程构造这个顺序

还有一种方法就是考虑点减边这个势能函数

# HeroicScheduled2

## 题目大意

给定n个区间$[L_i,R_i]$求有多少个区间的子集，满足可以将区间内选择一个点，然后每一个区间选择的点不同
$$
n\leq 50,R_i\leq 15
$$


## 算法讨论

对于一个固定的区间集合来说，就是将区间按照右端点进行排序，然后按照顺序，选择区间内没有被选择过的最左边那个点即可

那么这道题由于值域很小，那么我们可以记录值域上选择的情况，**需要先将区间按照右端点排序**

那么设$dp(i,s)$表示考虑到第i个区间的，值域上的情况为s的方案书

$dp(i,s)\rightarrow dp(i+1,s)$表示当前区间不在子集中

然后找到区间中第一个没有被选择过的位置，然后$dp(i,s)\rightarrow dp(i+1,s\cup \{pos\})$

时间复杂度$O(n2^V)$

# IndicatorMotionDrawing

## 题目大意

现在给定一个$n\times m$的网格，网格上要么空格子，要么是四种颜料，对于画笔其初始位置在$(0,0)$，每一次移动一条直线，然后将直线中的网格染成画笔上的颜色，也可以将画笔换颜色

一开始是空白的，给出目标形态，求最小操作步数
$$
nm\leq 12
$$

## 算法讨论

如果我们直接记录当前网格上的情况的话，复杂度需要$5^{12}$

但是我们只要求最终是否可以跟给出的形态相同就可以了，那么我们就记录当前网格上是否跟目标形态相同，同时还需要记录当前画笔的位置和颜色

然后进行bfs搜索即可

时间复杂度$O(2^{nm}nm)$

# GCDLCMEasy

## 题目大意

现在需要构造一个长度为n的序列，有m条限制，其中$x_{A_i}$与$x_{B_i}$的GCD为$G_i$,LCM为$L_i$

求是否存在这样一个序列

## 算法讨论

首先$x_{A_i}\times x_{B_i}=G_i\times L_i$，那么对于$(A_i,B_i)$形成的联通块来说，如果确定了其中的一个数，那么就可以通过这个关系求出图中其他所有数

那么我们可以枚举图中一个数，然后推出其他的数，然后枚举联通块内的边，看是否满足条件

如果所有的联通块都是存在一个方案是满足所有边的条件，那么说明就是合法的

否则就是不合法情况

# FoxPlusMinus

## 题目大意

给定序列F，构造如下序列A

- $i\in [0,k-1],A_i=F_i$
- $A_i=\sum\limits_{j=1}^k (-1)^{k-j}A_{i-j}$

现在要求任意排列$F$，使得$A_n$最大，在最大的同时最小化F的字典序

## 算法讨论

首先对于$n<k$的情况，我们需要将最大的那个数放在$F_n$上，然后在其他位置顺序放置其他数

那么接下来需要考虑$n\geq k$的情况

如果我们将每一个数对$A_n$的贡献计算出来，比如记作$c_i$的话，那么$c_i$大的分配的$F_i$也要相应的大，那么就是按照c_i的大小顺序进行$F_i$的顺序分配即可

根据打表的结果可以发现，对于$k$为奇数的情况下

- $(n-k)\bmod (k+1)=0$，那么所有位置的贡献为1,-1,1,-1,....
- $(n-k)\bmod (k+1)=i$，那么$c_{i-1}=1$其他位置都为0

证明可以通过将$A_n,A_{n+1}$的展开式求得

然后对于$k$为偶数的情况比较复杂，但是可以发现其一定是正负交替出现（第一个位为正），并且前一个的绝对值是小于等于后一个的绝对值的，并且这个差就是越来越小的

**如果绝对值都是不同的话，那么显然我们可以将其离散化，但是如果是相同那么就需要将这些位置视为贡献相同的位置，那么我们需要找到这个分界点**

然后我们还是将$A_n,A_{n+1}$的展开式相加

得到$A_{n+1}=A_{n-k}-2A_{n}$

那么相当于我们每一步可以走k代价为1，走1代价为(-2)，一个方案就是每一步代价的乘积

那么我们可以得到通项公式，假设当前求的是第x个位置对n的贡献
$$
\sum\limits_{i=0}^{\frac{n-x}{k}} \binom{n-ki+i}{i}(-2)^{n-ki}
$$
可以发现如果$n-x<k$的话，这个式子是一个常数，那么分界点就是x=n-k

然后按照上面叙述过程进行分配即可

# FoxAndSorting

## 题目大意

给定$[0,10^{18})$的集合，然后进行排序

这里a<b的条件为，如果$d(a)\neq d(b)$，其中$d(a)$表示a十进制下所有数字的和

那么如果$d(a)<d(b)$，那么a小

否则比较a,b的字典序

求第n小

## 算法讨论

首先设$dp(i,j)$表示当前到第i位，所有数字的和为j的方案数

那么我们可以确定第n大的数字和k

然后依次枚举每一位的数字情况，从高位往低位枚举，假设已经确定L位数字，剩下数字的和位k'的时候，枚举当前位为i的方案数
$$
dp(L-1,k-i)
$$
比较与n的大小关系，确定是否选择

# FiveHundredEleven

## 题目大意

现在有n个卡片，每一个卡片上写着一个$<512$的数，现在有两个人在玩游戏，初始数字为0，每一次可以选出一张卡片，将数or这张卡片上的数字，最终得到512的人输，如果卡片选完没有决出胜负，那么无法进行操作的人输

## 算法讨论

如果我们知道某一个状态的数字是什么，那么我们就可以确定哪些卡片是一定不选的，假设当前数字为$s$，那么对于卡片$a_i\& s\neq a_i$来说，是一定不选的

由于可能还有一部分卡片，是$a_i\& s=a_i$，但是没有被选过，显然这些卡片是等价的，那么我们只需要记录一下进行进行的轮数，就可以知道还可以在这些卡片中选多少个

设$dp(s,i)$表示当前数字为$s$，进行$i$轮先手是否必胜

可以枚举$a_j\& s\neq a_j$的$a_j$，如果$dp(s|a_j,i+1)=0$，那么先手一定必胜

假设$a_j\& s=a_j$有k个，那么由于我们状态一定是合法转移过来的，那么一定有$k\geq i$，如果$k>i$，判断如果$dp(s,i+1)=0$，那么先手必胜

否则先手必败

# CuttingGrass

## 题目大意

现在给定n个数，每一个数初始为$a_i$，每一轮会增加$b_i$，每一轮增加过后可以选择一个数将其变成0，求最小时刻所有数的总和$\leq H$

## 算法讨论

首先可以发现答案不会超过$n$，这是因为不会选择同一个位置的数将其变成0两次

那么可以发现，当确定要进行k轮的时候，我们只需要在这n个数中选出最优的k个位置上的数，最大化变成0之前数字的和即可，显然按照$b$升序选择

那么先将b升序排序，设$f(i,j)$表示考虑到前i个数，已经选择$j$个数的最大和
$$
f(i,j)=\max(f(i-1,j),f(i-1,j-1)+a_i+jb_i)
$$
答案只需要找到最小的j，满足$\sum a_i+j\sum b_j-f(n,j)\leq H$即可

# HexagonPuzzle

## 题目大意

给定一个6边形蜂巢形图案

![img](https://vj.ppsucxtt.cn/c8b893472a243617c2b54fda54d5683e?v=1634691418)

每一个格子上都有一个物品，现在可以选择三个有公共端点的格子人，然后旋转其物品，求可以得到的状态数有多少个

## 算法讨论

首先对于一个联通的可以利用三个公共端点连接起来的一个联通块

我们可以先固定其中一个格子上物品的编号，不断固定下去，直到只剩下三个格子，那么这三个格子的编号已经是固定的，绝对顺序可以通过旋转3次得到3中不同的物品

假设一个联通块的大小为k，那么其贡献就是
$$
k(k-1)(k-2)...3
$$
只需要dfs处理出所有联通块，然后将所有联通块的贡献乘起来即可

# CubeColoring

## 题目大意

兔子太郎想给立方体的顶点着色。 他认为立方体会很漂亮，如果： 每个顶点都用适合它的颜色着色。 没有两个相邻的顶点具有相同的颜色。 

![img](https://vj.ppsucxtt.cn/f11840e3a2e32e5aee988599dfbe8718?v=1634693246)

有N种颜色。 您将获得一个 String[] 颜色。 如果第 i 个颜色元素的第 j 个字符是“Y”，则第 j 个颜色适用于第 i 个顶点。 返回给立方体上色的不同方式的数量。 

## 算法讨论

首先枚举$0,1,2,3$节点的颜色，然后对于一种染色方案，每5位记录一个节点上的颜色编号，那么总位数就是20位

然后枚举$4,5,6,7$节点的颜色，按照对应顺序记录

可以发现，如果0,1,2,3的一种染色方案可以对应一种4,5,6,7的染色方案，当且仅当两种染色方案压缩成的数字异或不存在某5位都为0

那么可以用fwt加速这个过程

时间复杂度$O(2^{20}+32^5)$


# RectangularIsland

## 题目大意

![20211018T3](D:\Blog\image\20211018T3.PNG)

## 算法讨论

首先可以将两维状态分开考虑，可以求出走过$k$步之后，在这一维没有走出范围的答案

其中一维状态的长度为$n$，假设初始位置为$x$，设$dp(i,j)$表示走了$i$步之后，当前位置在$j$并且没有走出范围的方案数
$$
dp(i,j)=\frac{1}{4}(dp(i-1,j-1)+dp(i-1,j+1))
$$
直接递推即可，进而可以算出走过$k$步没有走出范围的概率$f(k)=\sum dp(k,i)$

那么最终答案就是
$$
\sum\limits_{k=0}^s \binom{s}{k} f(k)g(s-k)
$$
需要注意精度，需要开long double

# Nisoku

## 题目大意

给定n个卡片，每一个卡片上写着范围为$[1.5,10]$数字，现在可以将两个卡片合并，假设两个卡片上的数字分别为$a,b$，那么可以合并为$a+b$或者$a\times b$

求最终得到数的最大值

## 算法讨论

首先考虑，两个数的乘积大于其之和的条件
$$
ab\geq a+b\\
a\geq \frac{b}{b-1}
$$
可以发现只要$a\geq 3$，就是对于所有$b$都是$ab$比较大

注意到$2\times 1.5=3$，那么说明进行连续加法的数不会超过2个，可以将这些数排序，然后从头和尾开始配对

**一开始想着所有$<2$的数，进行上面的操作，然后$\geq 2$直接乘起来即可，但是这样是不对的**

**需要枚举一个分界点才行，这样才是考虑到所有的情况**

# ProductTriplet

## 题目大意

给定三个范围 ，求三元组元素分别在这个范围，满足$x\times y=z$
$$
x,y,z\leq10^9
$$

## 算法讨论

显然$\min(x,y)\leq \sqrt {10^9}$

那么我们就可以枚举$\min(x,y)$，那么另一个的范围为$\max(i,\lceil \frac{l_z}{i}\rceil ),\lfloor \frac{r_z}{i}\rfloor$

然后与另外一个元素的范围取交即可

会发现这样对于$i\times i$形式会计算两遍，那么需要减去这种的方案数