# 1007模拟

# A.彼得潘

## 题目大意

![20211008T3](D:\Blog\image\20211008T3.PNG)

## 算法讨论

## Solution 1

考虑枚举洞的集合$s_j$，然后我们需要求出$i<j$有多少个集合$s_i$作为炮弹集合是合法的

注意到如果将洞集合中的元素按照从小到大排序，可以发现会分成$|s|$个区间，每一个区间代表着如果存在一个炮弹在这个区间内，那么这个炮弹一定会进入这个区间代表的洞内

具体来说，第$i$个区间为$(b_{i-1},b_i]$，那么我们可以对于每一个位置处理出现被哪些集合炮弹的集合，这个可以用bitset实现，那么得到一个区间的合法集合就只需要将区间内所有位置的集合或起来即可

然后将所有区间异或起来，剩下的1相当于就是说有奇数个洞口有炮弹进入，那么只需要数bitset中有多少个1

时间复杂度$O(\frac{kn^2}{w})$

## Solution 2

考虑枚举两个$i,j$，其中$i$表示球的集合，$j$表示洞的集合，如果直接check的话，每一次的复杂度都是$O(k)$，考虑优化这个过程

首先将$i,j$的集合用$s,t$表示出现，首先如果洞上方有球，那么直接$s\&t$就是得到球直接进洞的洞集合

然后考虑将$t$取反，那么球的位置显然在$\overline{t}$为1的位置上才会进入洞，并且这个洞就是右边第一个0的位置，这里就很想二进制下的加法，那么可以球进洞的洞集合就是$((s\&\overline{t})+t)\&t$

然后将两部分或起来，求出二进制下有多少个1即可，直接用自带库函数就可以了

时间复杂度$O(n^2)$

# B.雄狮

## 题目大意

![20211008T4](D:\Blog\image\20211008T4.PNG)

## 算法讨论

首先先不考虑树的限制，考虑直接进行序列上的操作如何获得最优解

对于排名序列上的两个相邻位置，$a_i,a_j$，一定有$a_i>a_j$，并且中间不会插入其他的数字，这是比较显然的，那么我们可以将$a_i<a_j$这样的两个相邻的数合并成一个

那么也就是说我们当前得到了若干个块，每一个块都有$(s,c,f)$表示块内的和，块中元素的数量，块内的贡献，然后再考虑exchange argument

如果第$i$个块再排名序列中在$j$之前，那么需要满足
$$
c_is_j<c_js_i
$$
考虑转移到树上，考虑可以将一个子树缩成一个链，这个链就是这个子树的最优排名序列，然后向上走一步的时候，先将所有儿子子树的排名序列按照上面的关系进行归并，这个可以通过用优先队列+启发式合并实现，最后需要加入当前这个节点，由于当前这个节点在排名序列中一定是前于其他子树的，那么需要插入到序列最前面，然后这样可能会破坏$c_is_j<c_js_i$这个关系，那么需要将所有破坏关系的块以及当前这个节点合并成一个新的块

然后考虑两个合并块的更新
$$
s'=s_i+s_j,c'=c_i+c_j,f'=f_i+f_j+c_is_j
$$
那么时间复杂度$O(n\log ^2n )$

**需要开多测！，需要开多测！，比赛的时候因为这个爆0了**

# C.天马

## 题目大意

![20211008T5](D:\Blog\image\20211008T5.PNG)

## 算法讨论

人傻了

首先考虑一个点到另外一个点不经过所有障碍的路径数量，可以考虑容斥，就是可以强制钦定经过某一些障碍，然后不考虑其他障碍，然后算出方案数

这个过程显然可以用DP实现，由于容斥的式子为$\sum\limits_{i}(-1)^ f(i)$$f(i)$表示钦定$i$个的方案数，考虑钦定下一个$j$，那么钦定的个数增加$1$，那么就需要将(-1)的系数乘上
$$
dp(i)(-1)way(i,j)\rightarrow dp(j)
$$
那么考虑到原题上，因为我们需要记录实际上走过了哪些障碍，那么在两个实际走过障碍之间是不能走过其他障碍的，那么就跟上面的问题类似了

考场上我想对于每一个区间都处理出来这个DP，但是复杂度是$O(k^3)$的，然后再用一个DP统计实际经过的次数，**但是我们可以将对于每一个区间进容斥DP，放到最终统计的DP中去**

具体来说，我们可以对于每一个障碍，都确定这个障碍是实际经过还是不应该被经过但是被容斥钦定经过

那么设$dp(i,j)$表示走到第$i$个障碍，实际经过了$j$障碍的方案数
$$
dp(i,j)way(i,k)\rightarrow dp(k,j+1)\\
dp(i,j)(-1)way(i,k)\rightarrow dp(k,j+1)
$$
显然第二维的大小为$\log s$，然后需要对所有障碍按照x第一关键字，y为第二关键字排序，那么一定从前转移到后

时间复杂度$O(n^2\log s)$

# D.炮击

## 题目大意

![20211008T6](D:\Blog\image\20211008T6.PNG)

## 算法讨论

这样题目肯定是需要考虑网络流的

注意到，如果存在两个轨迹是相交的，那么我们一定可以沿着这个轨迹，从一个大炮走到另一个大炮的，并且这两个大炮一定一个是垂直方向一个是水平方向

那么我们就不能让两个大炮联通，那么很自然想到最小割

但是这里是最大化，那么就可以设一个偏移量，然后将所有的权值取反即可

一个直接的想法是，对于一个竖直的大炮，沿着轨迹向外连边，对于一个水平的大炮，沿着轨迹向内连边，然后源点连向竖直的大炮，水平的大炮连向汇点，那么割掉一条边就是代表这个大炮打击的位置为这个位置，那么如果两个大炮联通是不合法的

但是这样会有点问题，就是可能一个大炮会通过多次竖直水平交替的边走到另一个大炮，导致不合法，那么就需要将每一个点拆成两个点，竖直方向点和水平方向点，然后竖直方向点连向水平方向点，这样就可以了

![20211008T1](D:\Blog\image\20211008T1-16336584801221.jpg)
