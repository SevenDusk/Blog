# Connected Components?

## 题目大意

给出一个n 个点，$\frac{n(n-1)}{2}-m$条边的无向图，问图中有多少连通分量以及每个连通分量有多少点

输入中给出m对点，表示这一对点之间没有边，否则就是有边

输出连通分量的个数以及每个连通分量有多少个点
$$
n,m\leq 200000
$$

## 算法讨论

经典补图联通块的问题

考虑维护一个待选点集合，然后进行bfs，当进行扩展一个点的时候，在集合中找到这两个点之间右边的点，然后将这个点加入bfs中的队列，然后在待选点集合中删除

这样的复杂度就是$O(n+m)$，因为每一次扩展要么删除一个点要么就是这两个点之间有一条边

# SUM and REPLACE

## 题目大意

![20211109T1](D:\Blog\image\20211109T1.PNG)

## 算法讨论

首先将一个数$x$变成$d(x)$，不断递归下去，变成1或者2的次数就是$O(\log n)$的次数

然后可以用并查集维护哪些还没有变成**1,2(需要注意不只是1，2的因数个数也是2)**的数，然后一次区间修改就是区间内还没有变1,2的数暴力进行修改，然后在树状数组上单点修改即可

区间查询树状数组可以简单维护

时间复杂度$O(n\log ^2 n)$

### Solution 2

可以考虑用分块进行维护还需要修改的元素以及前缀和

对于整块修改就是，就是取出还没有变成1,2的进行暴力修改即可，如果已经变成了1,2那么从这个列表中删除即可

然后对于散块就是在范围内不等于1,2的暴力修改，如果变成了1，2那么在当前块的列表中删除即可

事实上不需要显式的维护这个列表，每次打标记即可

然后查询区间和分块可以简单维护

# List Of Integers

## 题目大意

t组询问，求第k个大于x且与p互质的数

## 算法讨论

首先我们可以二分答案，那么剩下的要求计算的就是区间内和某一个数互质的个数
$$
\begin{align}
&\sum\limits_{i=l}^r [\gcd(i,p)=1]\\
&=\sum\limits_{i=l}^r \sum\limits_{d|i,d|p}\mu(d)\\
&=\sum\limits_{d|p}\mu(d) \sum\limits_{i=l}^r [d|i]
\end{align}
$$
这个式子可以$O(\sigma (p))$的时间算出

那么时间复杂度就是$O(n\max \sigma(p)\log n)$，其中最大因数个数不超过400

# Max History

## 题目大意

我们定义f(a)为：

1、开始时，f(a)=0,M=1。

2、对于每个2<=i<=n,如果a[M]<a[i],那么f(a)=f(a)+a[M],M=i。

现在对于一个给定的数组a，求其所有排列的f(a)之和，答案对1e9+7取模。

## 算法讨论

其中$f(a)$最终就是等于所有不同的前缀最大值之和，然后减掉整个的最大值

其中最后那个可以先不管，考虑单独一个数的贡献

首先将所有数排序，假设钦定当前数i一定出现在前缀最大值中，那么所有$\geq i$的数都是出现在第i个数之后，加色和与$a_i$相同的数有$cnt$个，那么放在最前面的数有cnt种方法，然后考虑插入$<i$的数，方案就是$n^{\underline{i-1}}$

那么总贡献就是
$$
a_i\times  cnt\times (n-i-1)!\times n^{\underline{i-1}}
$$
然后总方案数减去$\max a_i n!$即可

# Erasing Substrings

## 题目大意

![20211109T2](D:\Blog\image\20211109T2.PNG)

## 算法讨论

考虑一个暴力DP，设$dp(i,s)$表示考虑到第i个位置，其中已经使用的次数为s的最小字典序串

考虑下一个位置是进行删除还是加入到剩下的字符串中
$$
dp(i,s)+s_{i+1}\rightarrow dp(i+1,s)\\
dp(i,s)\rightarrow dp(i+2^j,s+2^j),j\notin s
$$
由于DP的值就是字符串还需要比较大小，那么时间复杂度$O(n^3)$

考虑优化，显然在转移中有很多不必要的转移，就是字符串前面已经小于最优解了，还需要不断转移，那么我们考虑求出每一位的最小字符，然后只有状态中字符串最后一位为这个最小字符才可以进行转移

那么DP值只需要记录最后一个字符即可，转移的时候需要枚举$k=i-s$，k从小到大进行枚举

时间复杂度$O(n^2)$

# Shortest Path Queries

## 题目大意

![20211109T3](D:\Blog\image\20211109T3.PNG)

## 算法讨论

首先我们可以通过对于加入删除的边进行线段树分治，使得修改操作只有加边

然后当固定一个图的时候求两个点之间最短路，就是一个经典问题，之前edu也有一样的题目，用线性基维护一个生成树上树边和一条非树边形成环异或和，然后求出u,v在树上的距离，然后用这个距离在线性基中求出最小值即可

那么我们在加边的时候需要动态维护图的一颗生成树，那么就需要并查集，同时我们还需要求出树上任意两点之间的异或和距离，那么就需要带权并查集

具体的，我们对于每一个点维护一个数字$d_x$，表示子树内所有点走到根的时候必须要异或上$d_x$，那么求出一个点到根的距离就是将到根路径上的所有$d$异或起来即可，记作$f(x)$

当我们要在u,v之间连一条边的时候

- 假设u,v在同一个联通块中，那么向线性基中加入$f(u)$异或$f(v)$异或边权的值
- 否则假设u,v的根分别为$x,y$，那么需要将x放到y的儿子中，那么需要将$d_x$异或（$f(u)$异或$f(v)$异或边权的值），然后合并

并查集需要实现栈序撤销，那么需要按秩合并，在线段树上的过程中同时维护一个线性基即可

时间复杂度$O(n\log ^2 n)$

# Largest Beautiful Number

## 题目大意

如果一个正整数在十进制表示法下，不含前导零，有偶数个数字，并且对于它的所有数字来说，有一种排列方式使得这些数字组成一个回文数，那么这个数就是“美丽数”。例如4242是一个美丽数，因为它含有4个数字，这4个数字可以组成一个回文数2442。

给定一个正整数s，求严格小于s的最大美丽数。

## 算法讨论

**首先将输入的数-1**

一个数字为美丽的条件就是每一种数字出现了偶数次

然后我们考虑从高位开始枚举当前位的数字，数字需要从大到小进行枚举

然后考虑如何快速判定是否合法，我们尽可能要让后面的数字小，那么将所有不为0并且前面出现次数为奇数的数放在最后面，中间全部放0

直接一位一位判断过去时间复杂度是n^2的，需要优化，我们可以预处理出来每一个位置之后第一个不等于0的位置nxt，假设当前前面已经填了m位，最后不为0的个数为s，

首先判断掉s=0和**已经不顶格的情况**

然后如果$nxt_{m+1}$在0上那么一定合法，否则暴力判断最后不为0的数是否小于等于原来的限制

那么总的时间复杂度就是$O(10^2n)$

# Fibonacci String Subsequences

## 题目大意

![20211109T4](D:\Blog\image\20211109T4.PNG)

## 算法讨论

首先考虑一个出现次数的贡献，那么我们在$F(x)$中找到一个与s相同的子序列，假设其最小的位置为$l$，最大的位置为$r$，那么贡献就是$2^{l-1+N-r}$

考虑设$dp(x,l,r)$在$F(x)$中匹配$s_{l...r}$的贡献之和

对于$l=1$的情况那么有贡献$dp(x-2,l,r)2^{f(x-1)}$，否则就是$dp(x-2,l,r)$

对于$r=n$的情况也是同理

对于其他的情况
$$
dp(x,l,r)=\sum\limits_{k=l}^{r-1} dp(x-1,l,k)\times dp(x-2,k+1,r)
$$
时间复杂度$O(n^4)$

# Almost Increasing Array

## 题目大意

定义一个序列A是Almost Increasing的，当A满足从A中去掉一个位置之后剩下的序列形成了一个严格递增序列。 给出一个长度为n*n*的序列，问最小需要改动多少个位置的值，使得这个序列变成Almost Increasing的。

## 算法讨论

首先不考虑可以删除一个元素的情况，就是将这个序列变成严格上升的序列需要的最小修改位置

我们考虑求出最大需要保留的位置，对于两个需要保留的位置$i,j$之间必须进行修改，并且填入的数在$[a_i,a_j]$区间内并且互补相同

那么要求$a_i-i\geq a_j-j$，令$b_i=a_i-i$，那么需要最小修改的位置就是b序列的最长不下降子序列

这个可以直接DP+树状数组算

然后考虑加入可以删除的一个位置，DP过程基本不变，**但需要注意的是如果删除的位置两个保留的位置之间的话，那么对于$b_j$下标是需要-1，那么对应着$b_j+1$，这里需要特殊判断一下**

然后删除的元素也可以放在保留序列的开头和结尾

时间复杂度$O(n\log n)$

# Castle Defense

## 题目大意

![20211109T5](D:\Blog\image\20211109T5.PNG)

## 算法讨论

首先二分答案mid，然后先求出在不增加弓箭手的情况下每一个墙被多少弓箭手覆盖$b_i$

从小到大扫描，如果$b_i<mid$，由于之间都墙都是$\geq mid$，那么直接在右边2r的墙都加上$mid-b_i$即可，可以用差分实现

时间复杂度$O(n\log n)$

#  Path Counting

## 题目大意

![20211109T6](D:\Blog\image\20211109T6.PNG)

## 算法讨论

我们考虑枚举所有路径的LCA进行统计

考虑动态维护一个数组$f(j)$表示子树内长度为j的路径数量

当枚举的深度减1的时候，$f(j)$的下标需要加2，并且数值乘$a_i^2$，然后还需要考虑新多出来的那一次的路径贡献，然后统计的答案的是还需要乘上这一层有多少个节点

然后还需要统计单个节点就是当前层节点延伸下去的路径

都是可以在$O(n)$的时间内统计

总时间复杂度$O(n^2)$

# Yet Another String Matching Problem

## 题目大意

![20211109T7](D:\Blog\image\20211109T7.PNG)

## 算法讨论

首先考虑如何求出两个字符串之间的距离，我们可以在$s_i$与$t_i$之间连一条边，对于其中一个联通块来说，我们可以找到这个一个生成树，然后全部定为根的方向，起点代表变换的字符终点代表目标字符，那么这样就可以将这个联通块内的所有字符变成相同的

那么答案就是6-联通块个数

然后我们考虑枚举所有联通的情况，也就是枚举划分数，将6个字符划分成若干集合，然后对于这样的一组方案，在S，T中替换成字符所在的集合编号，然后对于子串可以匹配的位置的答案取当前需要操作次数的min即可

划分的方案数是贝尔数$B_6=203$

时间复杂度$O(|S|B_6)$

# k-substrings

## 题目大意

![20211109T8](D:\Blog\image\20211109T8.PNG)

## 算法讨论

一开始想了一个在后缀树上有根树点分治，然后求出任意两个后缀的lcs，依次判定border的最大奇数，这样时间复杂度是$O(n\log ^2n )$而且很难写，写完发现要写有根树点分治。。。

假设k子串的答案为$f(k)$，可以发现的是，当k+1的时候，对于$f(k)-2$的border是一定存在的，画一下图就可以发现，这个相当于就是$f(k)$的border去掉第一个字符和最后一个字符的情况，这样前缀和后缀是一定相等的

那么我们就有$f(k+1)\geq f(k)-2$，那么如果直接暴力枚举的话就需要找到最后一个位置，然后不在枚举下去复杂度才是对的，但这样无法判断当前是否要停止复杂度就是错的

如果$f(k)\leq f(k+1)+2$，那么相当于找到第一个合法和border即可

那么从k大往小枚举，首先将$f(k)=f(k+1)+2$，然后不断减小$f(k)$,直到找到一个合法的border可以用hash实现（不能用自然溢出，需要双模hash）

这样势能还是随着位置的减小最多增加2，时间复杂度就是$O(n)$

### Solution 2

首先我们将原来串翻转隔位插入到原来串里面

比如原来的串为ABCAB，翻转后为BACBA然后隔位插入ABBACCABBA

可以发现的是对于原来串的一个border相当于得到新的串的一个回文串

那么我们可以先用manacher或者z函数求出每一个位置的回文半径，需要注意的是这里只取长度为偶数并且中心在偶数位置的回文串

然后利用单调栈去除被完全包含的回文串，那么得到的序列左端点一定递增，右端点也随之递增

按照左端点枚举这些回文串来更新答案，在回文串范围内的border都是可以被更新到的，就是$[l_i,\min(r_i,l_i)]$区间内的位置都是更新为$r_i-j$即可

# Partitions

## 题目大意

![20211109T9](D:\Blog\image\20211109T9.PNG)

## 算法讨论

首先考虑一个物品的贡献，枚举包含这个物品集合的大小
$$
\sum\limits_{j=1}^n w_i\times  j\binom{n-1}{j-1}\left\{\begin{matrix}n-j\\k-1\end{matrix}\right\}
$$

然后提出$w_i$，剩下的部分与i无关，将第二类斯特林数展开
$$
\begin{align}
&\sum\limits_{j=1}^n j\binom{n-1}{j-1}\left\{\begin{matrix}n-j\\k-1\end{matrix}\right\}\\
&=\sum\limits_{j=1}^n j\binom{n-1}{j-1}\frac{1}{(k-1)!}\sum\limits_{i=0}^{k-1} (-1)^i\binom{k-1}{i}(k-1-i)^{n-j}\\
&=\frac{1}{(k-1)!}\sum\limits_{i=0}^{k-1}(-1)^i\binom{k-1}{i}\sum\limits_{j=1}^n j\binom{n-1}{j-1}(k-1-i)^{n-j}
\end{align}
$$
其中可以使用吸收使得凑出二项式定理的形式
$$
j\binom{n-1}{j-1}=(n-1)\binom{n-2}{j-2}+\binom{n-1}{j-1}
$$
那么最终式子为
$$
\frac{1}{(k-1)!}\sum\limits_{i=0}^{k-1}(-1)^i\binom{k-1}{i}((n-1)(k-i)^{n-2}+(k-i)^{n-1})
$$
直接计算即可，最终乘上$\sum w_i$

