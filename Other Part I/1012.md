# SRM 419 1000pts CactusAutomorphisms

## 题目大意

给定一个点仙人掌（一个点最多只在一个简单环中），求出与其同构的仙人掌数量，这里的同构就是一个排列$p$，要求原图中$i,j$存在边那么$p_i,p_j$也一定要存在
$$
n\leq 200
$$

## 算法讨论

首先可以对点仙人掌进行边双缩点，可以发现的是这个每一个边双节点都是一个环，并且不存在其他边

答案的贡献是由两部分得来的

第一部分是对于一个环来说，可以进行翻转，旋转操作

第二部分是对于两个子仙人掌的位置可以互换，也就是在缩成的树上，某一个节点的同构儿子子树可以互换，**或者一条边的两个子树同构**

显然每一个部分内的贡献都是独立的，那么答案只需要将所有的贡献乘起来即可

首先考虑如何计算第一部分的贡献

先考虑旋转，假设一开始的环编号为$1,2,...,k$，那么旋转相当于将这个编号序列进行循环移位，那么合法的排列有$k$个，再考虑翻转，那么得到的编号序列为$k,k-1,...,1$，然后还可以进行循环移位，那么也有$k$个排列合法，总共合法排列为$2k$

这个只是考虑单单一个环的情况，我们还需要考虑这个环上挂着的子仙人掌，假设$i$通过排列变换到$j$，那么$i$的子仙人掌要与$j$的子仙人掌同构，否则该排列不合法

那么我们可以对这$2k$个排列都进行检查，将合法排列数量乘到贡献中

剩下的问题就是如何解决判仙人掌同构的问题，首先如果退化成树是简单的，我们可以定义一个节点的Hash函数$h_x$，记$pr_k$表示第$k$个子树
$$
h_x=1+\sum\limits_{u\in son(x)}h_u\times pr_{sz_u}
$$
考虑扩展到仙人掌上，考虑一个环$p_0,p_1,...,p_{k-1}$，**首先我们知道枚举到这个环时候是从哪个节点进入的**，显然不能再返回去，然后我们按照一个确定的顺序枚举这个环上的节点，得到以枚举节点为根时候子仙人掌的Hash值，由于环可以旋转同构，那么Hash函数必须只与相对顺序有关，并且还可以翻转同构，那么说明要与遍历环的顺序无关

考虑将环上Hash值相同并且连续的缩成一段，hash值记作$f_i$，个数为$cnt_i$，总共有$k'$段
$$
\prod\limits_{i=0}^{k'-1} (z^{cnt_{i+1}}f_{i+1}-z^{cnt_i}f_i)
$$
**这个hash函数是满足旋转同构的，翻转同构，正着枚举和反着枚举是可能为相反数的，那么处理比较节点求上式的平方即可，需要注意的是，由于环是从某个节点进入的，计算Hash值是没有考虑这个的，那么需要给$f_x$乘一个度数**

那么解决同构的问题了

然后考虑第二部分的贡献，就直接枚举点/边，看子树的同构等价类，假设一个等价类大小为$k$，其贡献为$k!$，**注意在枚举点的时候，不能将环上其他点考虑进去**

为了方便实现，时间复杂度写了$O(n^2)$，但事实上实现精细可以简单优化到$O(n)$

# DancingParty

## 题目大意

现在有$n$个男孩$n$个女孩参加派对，派对上要跳m轮舞，每一轮舞一个需要一个男孩与一个女孩一起跳，并且在每一轮，男孩配对的女孩是不同的，女孩同理，现在给出男孩女孩之间的喜欢关系，一个人最多只能忍受与$k$个不喜欢的人跳舞，求最大轮数$m$

## 算法讨论

首先如果将男孩女孩的喜欢关系建出图来，那么这个图一定是二分图，一轮舞，相当于要找出一个完美匹配，然后在图中将匹配中的边删去

如果能跳$m$轮舞，相当于这个过程可以进行$m$次，那么有一个结论就是这样的二分图一定是$m-$正则图，也就是如果这$m$个完美匹配涉及到的边，每一个节点的度数恰好为$m$，证明就是归纳，首先存在一个完美匹配的一定是1-正则图，由于删去一个完美匹配相当于将度数-1

那么我们可以先二分答案

现在由于还可以向图中加入若干边，但是这些一个节点加入新边的度数$\leq k$，相当于要在原图中选出一些边，然后再加入一些边使得每一个点的度数都为$m$

这种匹配问题可以考虑网络流，首先将每一个点拆成三个点$x_i,y_i,z_i$，对于男生为例，$s$连向$x_i$容量为$m$，$x_i$连向$y_i$容量为$\infin$，$x_i$连向$z_i$容量$k$，这里$x_i$用来限制点的度数，$y_i$表示在原图上选的边，$z_i$限制新加边的度数$\leq k$，对于原图上的边，是在$y$之间连容量为1的边，新加边是在$z$之间连容量为1的边

![graph (1)](D:\Blog\image\graph (1)-16340921969781.png)

# PredictionCardGame

## 题目大意

![20210826T2](D:\Blog\image\20210826T2.PNG)

## 算法讨论

显然对于一个问题来说，只有三个变量会影响答案，那么就只需要将这个三个变量记录到DP状态里面，然后考虑转移即可

设$f(n,m,k)$表示这个问题的答案

转移的时候枚举当前的下注$x$​，由于我们是求最优决策在最坏情况下的答案，那么外层一定是一个max，内层就是min
$$
f(n,m,k)=\max\limits_{i=0}^k \max(\min(f(n-1,m,k+i),f(n,m-1,k-i)),\min(f(n-1,m,k-i),f(n,m-1,k+i)))
$$
直接转移的复杂度是$O(nmans^2)$​会超时

首先$f(n,m,k)=f(m,n,k)$，那么下面默认$n<m$

### 处理 1

注意到$f(n,m,k)$是关于n递减的，那么最大的答案只有5000多，那么说明我们的k一定是$\leq 5000$

由于不同的n的上限也是不同的，那么只需要打表求出这个上界就可以了

然后在记忆化搜索的过程中，判断k是否在这个上界中就行了

### 处理 2

是一个剪枝搜索，注意到如果$f(n,m-1,k-i)$​小于当前的$f(n,m,k)$​，那么就没有必要搜索$f(n-1,m,k+i)$了，另外一边也是同理

需要注意的是必须先搜索$f(n,m-1,k-i)$​因为k会变小

### 处理 3

考虑将整个过程倒过来，我们可以二分枚举最终得到的答案$mid$，按照最优策略，检查进行n+m轮操作过后最多得到的钱是否$\geq k$

那么考虑递推转移记$a_{n,m}$表示状态，首先$n=0$或者$m=0$的情况很好处理，就是上次赌所有的钱，$a_{n,0}=\lceil\frac{a_{n-1,0}}{2}\rceil$

然后考虑$n,m\neq 0$的情况

由于有两种情况，$(n,m)\rightarrow (n-1,m),(n,m-1)$​​，那么根据**处理 3**可以知道，肯定是让这两种情况跟$(n,m)$的差的最大值尽可能小，那么取他们的中位数就可以了，那么有
$$
a_{n,m}=\lceil\frac{a_{n-1,m}+a_{n,m-1}}{2}\rceil
$$
时间复杂度$O(nm\log ans)$

# UnfixedArrangements

## 题目大意

现在有$k$个位置，有n个数，范围$[1,n]$，要将这些数放到位置上，每一个位置只能放一个数，要求这个数与位置的编号不同，求方案数

## 算法讨论

考虑容斥，可以强制若干位置放的数与位置编号相同，其他位置任意放
$$
\sum\limits_{i=1}^k (-1)^i \binom{k}{i} (n-i)^{\underline{k-i}} 
$$
直接计算即可

# Polygon

## 题目大意

给定$n$个点的多边形，其边都是与坐标轴平行，$n$个点给出顺序为逆时针，现在将多边形内部的整点，按照x坐标为第一关键字，y坐标为第二关键字排序，给出若干询问求第$k$个坐标为什么
$$
n\leq 200
$$

## 算法讨论

考虑扫描线，首先将所有点的$x$坐标离散化，从$x$最小的位置开始扫描，那么需要先求出对于扫描线所在的x坐标上有多少个整点是在多边形内部的

这需要用到判断一个点在多边形内部的方法，射线法，考虑引出一条竖直射线，沿着y从小到大进行枚举，如果当前穿过一条水平方向的多边形的边，那么将是否在多边形内的bool变量取反，具体实现的时候可以将穿过的边y坐标记录下来，然后进行排序，对于(1,2),(3,4)这样的计算其$y$坐标差即可

需要注意的是，引出的射线可能会经过顶点，那么需要特殊判断一下，只有四种情况是要将当前$y$坐标记录下来的

得到记录的y坐标数组之后，查询当前x坐标第k个位置是很方便的，可以先计算出来整体有多少个整点，然后将询问在当前扫描范围内的$x$坐标算出，然后相应得到是当前x坐标的第几个位置，直接查询即可

时间复杂度$O(n^2)$，主要复杂度瓶颈在于，如何找到穿过的边还有查询当前x坐标第k个位置，如果使用线段树和二分，就可以优化到$O(n\log n)$

