# AGC10E Rearranging

## 题目大意

现在有$n$个数，每一个数为$A_i$，第一个人可以任意重新排列这些数，第二个人可以任意交换两个相邻的互质的数，第一个人先操作，第一个人要得到的序列字典序最小，第二个人要得到的序列字典序最大

求出最终的序列
$$
n\leq 2000
$$

## 算法讨论

首先给互相gcd不等于1的点之间连边，第一个人相当于就是给这个无向图定向，然后第二个人就会进行拓扑排序，并且贪心的选择当前可以选择的最小的数

考虑从前往后枚举当前这一位是哪一个数，如果这个数代表的节点为$x$

那么$x$连向的节点都是没有问题的，但对于$x$没有连边的点，并且这个点的数值比$a_x$大，那么就说明这个点在当前时刻时至少应该有一个入边，那么我们用$tag(x)$来记录某一个点是否需要强制选一个入边

显然我们当前位置选择的$x$，$tag(x)\neq 1$，选定之后可以给其连向的节点$tag=0$，并且如果某一个联通块内所有节点的tag都为1，那么显然是会出现环的情况，那么就不合法

那么每一次选择节点的时候需要保证，选择过后不会出现某一个联通块全是$tag=1$的情况，考虑求出每一个联通块中数值最小$tag=0$的节点，那么我们选择的一定是求出节点中数值最大的那个

至于维护联通块就是先预处理每一个数的质因数，然后利用并查集维护即可

时间复杂度$O(n^2\log n)$

另解：在建出边的图中，对于一个联通块来说，需要将最小的放到左边，那么在联通块中dfs的时候，优先遍历权值小的，按照dfs的顺序给边定向

然后利用堆来维护拓扑排序

还有可以用bitset维护已经选好的点，与还没有选择的点的边，每一次扩展一个点，这样的时间复杂度就是$O(\frac{n^3}{w})$

# POJ 3658 Artificial Lake

## 题目大意

现在有$n$个石柱，第$i$个石柱的宽度为$w_i$，高度为$h_i$，并且所有石柱的左右两侧石柱高度都为$\infin$，现在向最低的石柱上灌水，水可以流动，要求求出每一个石柱被覆盖了高度为1的水的时间

保证每一个石柱高度两两不同
$$
n\leq 10^5
$$

## 算法讨论

首先灌水的过程就是不断填平凹陷的过程，向其灌水的区域不断向两端扩展的过程，具体的

如果当前灌水区域的两端石柱的高度都高于当前的高度，那么找到其中较低的石柱，扩展到这个石柱的高度，然后将当前区域包含上这个石柱

如果存在一个石柱的高度低于当前的高度，那么说明水会溢出，那么我们就可以将灌水的区域变成那个石柱上，将那个石柱视为起点重新开始这个过程

具体实现的话就是，可以用链表维护一个区域，区域中可能包含多个石柱，区域的宽度为所有石柱宽度之和，高度为其中最大的高度，用链表记录前一个区域的编号和下一个区域的编号

考虑一次扩展，如果是第一种情况，那么更新当前的区域的信息、链表、时间，将当前区域的最高石柱的答案求出

如果是第二种情况，将当前区域设为低于当前高度的区域，重新开始这个过程

时间复杂度$O(n)$

第一次提交:AC

# POJ 3612 Telephone Wire

## 题目大意

现在有$n$个柱子，每一个柱子的高度为$h_i$，相邻两个柱子的代价为$C|h_i-h_{i+1}|$，现在可以升高一个柱子，如果将一个柱子升高$x$，其代价就是$x^2$，求最小代价
$$
n\leq 10^5,h_i\leq 100
$$

## 算法讨论

设$dp(i,j)$表示考虑到第$i$个柱子，当前这个柱子的高度为$j$的最小代价

显然所有柱子的高度不会超过$lim=\max\limits_{i=1}^n h_i$

有转移
$$
dp(i,k)=(k-a_i)^2+\min\limits_{j=a_{i-1}}^{lim} dp(i-1,j)+C|k-j|
$$
直接转移的复杂度$O(lim^2n)$，需要优化

分情况讨论

- $j\leq k$，那么$dp(i,k)=(k-a_i)^2+Ck+\min\limits_{j=a_{i-1}}^{k} dp(i-1,j)-Cj$记录$dp(i-1,j)-Cj$的前缀min即可
- $j\geq k$，那么$dp(i,k)=(k-a_i)^2-Ck+\min\limits_{j=k}^{lim} dp(i-1,j)+Cj$记录$dp(i-1,j)+Cj$的后缀min即可

时间复杂度$O(lim\times n)$

第一次提交:AC

# POJ 3622 Gourmet Grazers

## 题目大意

现在$n$个一类点$(A_i,B_i)$，$m$个二类点$(C_i,D_i)$，要求每一个一类点匹配一个二类点，假设$i$匹配了$p_i$

要求$C_{p_i}\geq A_i,D_{p_i}\geq B_i$，然后最小化$\sum\limits_{i=1}^n C_{p_i}$
$$
n,m\leq 10^5
$$

## 算法讨论

首先将所有点按照第二维从大往小进行排序，那么每一个一类点，其可以匹配的点就是排在其前面的二类点，并且其第一维需要大于等于当前点的第一维

那么首先给第一维离散化，并且翻转使得大于等于的关系变成小于等于的关系（为了方便树状数组的使用）

由于我们要最小化第一维之和，那么我们贪心选取所有合法二类点中第一维最接近当前点的

这样做可以尽量减少对于小于第一维其他一类点的影响，对于大于当前第一维的一类点没有影响，证明也是类似区间覆盖的经典贪心证明

那么我们可以用树状数组来维护所有二类点第一维的情况，每一个查询在树状数组上二分即可，如果不存在符合条件的二类点，那么输出-1，否则进行更新即可

时间复杂度$O(n\log n)$

第一次提交:WA

# POJ 3265 Problem Solving

## 题目大意

现在有$p$个问题，每一个月的收入为$m$，解决每一个问题都需要一个月的时间，同一个月内可以解决多个问题，在解决第$i$个问题月份开始需要支付$a_i$，解决这个问题之后的那个月的开始又需要支付$b_i$

前一个月没有用完的钱不能存起来，所有问题只能依次解决，求最小需要多少个月来解决所有问题
$$
p\leq 300
$$

## 算法讨论

设$dp(i,j)$表示至少需要用多少个月，使得当前这个月解决到第$i$个问题，并且这个月正在解决$j$个问题
$$
dp(i,j)+1\rightarrow dp(k,k-i)\\
if \sum\limits_{p=i-j+1}^i b_p+\sum\limits_{p=i+1}^k a_p\leq m
$$
直接转移就是$O(p^3)$

第一次提交:AC

# POJ 3657 Haybale Guessing

##  题目大意

现在有长度为$n$的序列$a$，序列中的数两两不同，有$q$个猜测$(l,r,x)$，表示$\min\limits_{i=l}^r a_i=x$

求出最早到第几个猜测会与之前的猜测出现矛盾
$$
n\leq 10^6,q\leq 25000
$$

## 算法讨论

首先肯定是二分答案

考虑一次猜测给出了什么信息，相当于是说给出了$[l,r]$中数的下限，并且有一个$x$

首先对于所有x相同的来说，取其交集，如果最终交集里面所有位置的下限都是大于x的，那么一定存在矛盾，否则选择一个位置放x即可，如果在没有矛盾的情况，这样做一定合法（因为不可能有相交的情况出现）

那么二分完答案后利用线段树维护每一个位置的下限即可，需要用时间戳清空

比较卡常。。

时间复杂度$O(q\log q\log n)$

第一次提交：TLE

# POJ 3271 Lilypad Pond

## 题目大意

现在给出$n\times m$的网格图，现在从其中一个格子出现，要到达另外一个格子，只能走国际象棋中马的走法，途中所经过的格子一定都要有睡莲

图中有一些格子上已经存在了睡莲，还有一些位置上有石头，其他的位置为水面，可以在水面上放置一个睡莲，石头上无法放置睡莲，求出最少需要放置多少个睡莲，以及在最少的情况下放置睡莲的方案数
$$
n,m\leq 30
$$

## 算法讨论

一开始考虑直接bfs求出最短路，同时维护方案数，但是这样做会发现求出的是走的路径的方案数，而不是放置睡莲的方案数，事实上直接bfs的过程中会走过边权为0的边，有0权边统计的最短路数在这道题下是错误的，需要将这张图的所有边权改为1才行

那么考虑处理出所有点在放置一个睡莲可以走到的位置，这个可以通过首先处理已经有睡莲的位置，将其缩成若干联通块（看作一个点），然后处理其可以到达水面的位置，然后考虑没有睡莲的位置，如果可以达到没有睡莲的位置，直接在这两个位置上连一条边，如果可以到达已经有睡莲的位置，就将之前处理好的位置加入当前位置可以达到的位置集合

需要注意的是，图中是不能有重边的，那么需要处理一下

然后建出图跑最短路bfs，同时维护方案数即可

时间复杂度$O(nm)$

第一次提交：WA
