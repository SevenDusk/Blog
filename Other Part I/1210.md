# CF1450G Communism

## 题目大意

![20211210T1](D:\Blog\image\20211210T1.PNG)

## 算法讨论

首先工作种类最多只有20个，那么可以考虑进行状压DP

由于每一个都是合并两个种类，那么如果x合并成y，那么在x,y之间连一条边，那么形成的的图一定是一棵树

对于一个种类集合s，我们可以预处理出来是否还可以继续合并到其他位置，记作$ok(s)$，对于上面构造出的那个树来说，**除根节点以外的所有节点子树的集合都是可以继续合并的**

那么设$dp(s)$表示当前子树（**可以是多个兄弟子树的集合并集**）的集合是s，是否可以得到并且继续向上合并，那么如果最终可以将所有工作变成种类$x$，那么一定有$dp(U\backslash \{x\})$

- 首先可以向上进行一次合并，对于一个集合$s$，选取其中$x\in s$作为一个子树的根，那么如果$ok(s)=1$，那么将$dp(s)|=dp(s\backslash\{x\})$
- 然后我们可以将两个相邻兄弟的子树合并，枚举子集$t\subset s$，令$dp(s)|=dp(t)\&dp(s\backslash t)$

直接做的复杂度为$O(3^k)$

需要注意的是DP的状态是一个bool变量，相当于我们只要找到一组合法的解就可以停止转移了，那么我们就考虑如果减少不必要的转移

然后题目给出一个集合合法的条件事实上就是在反应这个集合在分布上的密集程度，越密集越好

那么我们在第2种转移的时候如果$t,s\&t$互相在位置范围上交错的密集程度是一定大于两个集合不交错的密集程度，那么我们可以猜想只需要考虑$t,s\& t$不交错的情况就可以了，那么这样所需的转移只有$O(k)$个，实现的时候可以将集合中每一个种类按照出现位置最靠左的位置进行排序即可，然后取每一个前缀的集合就可以了

形式化证明，参考了官方题解

假设$range(s)$表示s集合中所有种类位置集合的范围，$cnt(s)$表示初始所有是s中工作种类的位置个数

对于$range(A)\cap range(B)\neq \empty$的情况来说，那么此时A,B是作为兄弟子树的，那么不妨将A放到B的祖先位置上（将转移复杂度大的规约到转移复杂度小的情况），如果这样操作下来仍然合法，就是$A\cup B$进行合并，那么说明这种A,B作为兄弟子树的情况不合法
$$
cnt(A\cup B)=cnt(A)+cnt(B)\geq k(|range(A)|+|range(B)|)\geq k|range(A\cup B)|
$$
那么最终时间复杂度$O(k2^k)$

# CF1007E Mini Metro

## 题目大意

![20211210T2](D:\Blog\image\20211210T2.PNG)

## 算法讨论

**首先如果每一辆火车没有装满k个人的话，我们还需要关系当前时刻每一个位置具体的人数，在DP转移的时候根本无法记录状态**

**那么就需要将问题变成每一个火车都是最终装满k个人的情况**

那么我们可以在最后加入一个新的站点，$a_i=\infin,b_i=0,c_i=\infin$

然后设$f(i,j,k)$表示只考虑前i个站点的时候需要坚持j个小时的最小使用火车数，k表示当前初始人数是0还是$a_i$，但是单单这一个状态是无法进行转移的，**就是如果在j小时中我们需要减少i号站点的人数，我们仍然需要知道之前站台上所有人数信息，那么我们需要另一个状态进行辅助，设$g(i,j,k)$表示只考虑前i个站点的时候，需要坚持j个小时，并且最终将$[1,i-1]$所有站点上的人清空的最小使用火车数**

考虑进行转移

首先如果在这$j$个小时中都不减少$i$站点的人数，显然需要$k\times a_i+j\times b_i\leq c_i$，然后对于$f(i-1,j,k)$是合法的，那么我们令$f(i-1,j,k)\rightarrow f(i,j,k)$，**然后在满足这个条件的情况下**，考虑更新$g(i,j,k)$，首先在最终的时候需要清空$[1,i-1]$那么此时前i-1个站台的总人数为$L=\sum \limits_{v\leq i-1} k\times a_v+j\times b_v$，那么我们需要$\lceil \frac{L}{K}\rceil$列火车，由于每一列火车必须要装k个人，那么需要满足$\lceil \frac{L}{K}\rceil\times K\leq \sum \limits_{v\leq i} k\times a_v+j\times b_v $，然后$\lceil \frac{L}{K}\rceil\rightarrow g(i,j,k)$

然后考虑如果在j时刻中存在某一个最近的时刻r，需要减少i站台上的人，那么显然需要将$[1,i-1]$的所有人清空，那么此时需要的火车数为$g(i,r,k)$（此时$g(i,r,k)$也需要合法），然后此时i站台上剩下的人数有
$$
re=(\sum\limits_{v\leq i} k\times a_v+r\times b_v)-g(i,r,k)\times K
$$
显然如果$g(i,r,k)$合法，那么$re\geq 0$

这里可能会有问题，就是在前r时刻中，如果$[1,i-1]$中存在站点的人数超出了怎么办，需要注意的是此处$g(i,r,k)$的火车并不是要求在某一个时候同时开出，我们可以不断累积开，前$[1,i-1]$一旦人数$\geq k$了，那么就开出若干火车，减小人数，如果这样做仍然存在不合法情况，那么$g(i,r,k)$一定也是不合法的

由于$(r,j]$的时刻都不会减少i站台的人数，那么我们需要让剩下加入的人总数$\leq c_i$

那么需要
$$
tmp=\lceil \frac{\max(0,re+(r-j)\times b_i-c_i)}{k}\rceil
$$
并且这tmp个火车一定是在当前r时刻出发的，那么需要满足$tmp\times K\leq re$，还有一个条件就是$f(i-1,j-r,0)$一定要合法

那么$f(i-1,r,0)\rightarrow f(i,j,k)$

还需要考虑更新$g(i,j,k)$，此时前$[1,i-1]$的站台累积人数为$L=\sum \limits_{v\leq i-1} k\times a_v+(j-r)\times b_v$

同样如果$\lceil \frac{L}{K}\rceil \times K\leq (\sum \limits_{v\leq i} k\times a_v+(j-r)\times b_v)-tmp\times K$，那么有$\lceil \frac{L}{K}\rceil+tmp+g(i,r,k)\rightarrow g(i,j,k)$

最终答案就是$g(n,t,1)$

时间复杂度$O(nt^2)$

# Hellish Constraints

## 题目大意

给定一个字符串，和k条限制，形式为$c_i$出现次数在$[l_i,r_i]$之间

求这个字符串所有子串中满足$[L,R]$条限制的个数
$$
n\leq 10^5,k\leq 500
$$

## 算法讨论

考虑从左往右枚举这个子串的右端点$i$，同时维护左端点$j\leq i$满足的限制总数

那么我们可以对于所有限制维护两个指针，表示当前满足限制的左端点范围

在右端点向后移动的时候，可以更新维护这两个指针，在指针移动的过程中更新指针移动过的位置满足限制的数量，同时更新维护答案

具体来说，我们记$a_i$表示左端点为i的满足条件限制

相当于$a_i$=[所有限制$r_i$对应指针$\leq i$的个数]-[所有限制$l_i$对应指针$\leq i$的个数]，当某一个指针移动过i的时候，更新$a_i$即可

时间复杂度$O(nk)$

