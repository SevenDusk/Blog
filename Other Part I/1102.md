# [CSP-S 2021] 交通规划

## 题目大意

给定一个平面上 n 条水平直线和 m 条垂直直线，它们相交形成 n 行 m 列的网格，从上到下第 r 条水平直线和从左到右第 c 条垂直直线之间的交点称为格点 (r, c)。网格中任意两个水平或垂直相邻的格点之间的线段称为一条边，每条边有一个非负整数边权。

进行 T 次询问，每次询问形式如下：

给出 k（T 次询问的 k 可能不同）个附加点，每个附加点位于一条从网格边缘向外出发的射线上。所有从网格边缘向外出发的射线按左上-右上-右下-左下-左上的顺序依次编号为 1 到 2 n + 2 m，如下图：

对于每次询问，不同附加点所在的射线互不相同。每个附加点和最近的格点之间的线段也称为一条边，也有非负整数边权（注意，在角上的格点有可能和两个附加点同时相连）。

给定每个附加点的颜色（黑色或者白色），请你将网格内每个格点的颜色染成黑白二者之一，并使得所有两端颜色不同的边的边权和最小。请输出这个最小的边权和。

## 算法讨论

首先一个暴力的做法就是，对于每一个点进行最小割，就是对于网格上每一个点要么是染黑色要么是染白色，单独染色并没有代价，所以这个点不需要向源点或者汇点进行连边

由于异色的格子之间是存在代价的，那么我们将两个点用对应代价的容量的双向边连起来，表示一旦两个相邻的格子选择了不同的颜色，那么就必须要割掉这条边，使得s,t不连通

对于附加点来说，我们找到其直接相邻的那个格子，会发现这个格子选择的颜色会有代价，那么将s,t与其的边连上对应边权既可

这样暴力实现是60分，对于实现比较精细，就是不是每一次都建图，将一些无用边去掉，就是一开始将图先建好，每一次退流实现，这样就不需要每一次都跑一遍

以下是比较好的实现

```C++
void solve()
{
  S=pos(n,m)+1;T=S+1;tl[T]=1;tS=0;
  for (int i=1;i<=T;i++)tl[i]=0;
  for (int i=1;i<n;i++)
    for (int j=1;j<=m;j++)
      adl(pos(i,j),pos(i+1,j),a[i][j]);
  for (int i=1;i<=n;i++)
    for (int j=1;j<m;j++)
      adl(pos(i,j),pos(i,j+1),b[i][j]);
  int k;scanf("%d",&k);
  for (int i=1,x,p,t;i<=k;i++){
    scanf("%d%d%d",&x,&p,&t);
    if (p<=m)p=pos(1,p);
    else if (p<=m+n)p=pos(p-m,m);
    else if (p<=m+n+m)p=pos(n,m+m+n-p+1);
    else p=pos(n+n+m+m-p+1,1);
    adl(t ? S : T,p,x);
  }
  int ans=0;
  while(bfs())
    for (int i=0;i<tS;i++)if (Sl[i].c){
      int d=dfs(Sl[i].t,Sl[i].c);
      Sl[i].c-=d;ans+=d;
    }
  printf("%d\n",ans);
}
```

然后考虑k=2的情况，显然如果附加点是同色的话，那么答案就是0，只需要考虑异色的情况，那么考虑将平面图上的最小割转化为对偶数上的最短路

放到这道题里面来说，就是与附加点临近的格子颜色都应该是附加点的颜色，也就是说同一个颜色构成的联通块只有2个，其分界线经过的最小边权和就是答案

![pic0_0](https://cdn.luogu.com.cn/upload/image_hosting/l04h3s8c.png)

类似上面这个图，会发现这个分界线一定是跨过两个附加边分成的两个平面，我们将所有面都建一个点，然后如果两个面有公共边，那么之间就连一条公共边权的边，那么最短路的起点就是外面的一个平面，终点就是另外一个外面的平面，直接最短路求出，就是答案，时间复杂度$O(nmk\log (nm))$

然后我们需要扩展到k更大的情况，根据上面的做法，我们还是要将每一个平面看作一个点，但是此时同色连通块直接的分界线并不是只有一条分界线，可能有多条

还是跟刚才一样，我们将外面的平面分成若干个，一个平面是**一个黑色附加边和一个白色附加边中间的区域**，对于两个同色附加边之间区域我们不需要考虑（因为可以将极长连续同色附加边看作一个附加边，这样并不会影响答案）

那么同色连通块的分界线就是这样的平面两两配对形成的结果，**并且这些分界线一定不交**，证明考虑反证，如果在最优解里面两个分界线相交了，那么我们一定可以通过交换两个配对的平面，使得新的分界线经过的边是原来分界线经过边的子集，那么一定是比之前的方案优的

由于$\sum k_i\leq 50$，那么所有外面的平面最多只有50个，那么我们直接暴力求出两两平面之间的最短路（不是k^2都求，只要固定k个端点求即可，因为一个起点的最短路可以求出所有终点的最短路）

那么接下来就是匹配的问题了，这个可以用区间DP来统计，设$f(i,j)$表示区间$[i,j]$内都匹配的最小代价
$$
f(i,j)=\min\limits_{k} f(i+1,k-1)+f(k+1,j)+dis(i,k)
$$
然后我们在DP的时候需要将环断成链，由于匹配本质上就是取括号序列，那么我们就可以找到其中左括号和右括号数量相同的地方将环断成链，这样就是合法的

DP的复杂度为$O(k^3)$

总时间复杂度$O(nmk\log (nm)+k^3)$

