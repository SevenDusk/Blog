# Pencils and Boxes

## 题目大意

![20211117F1](D:\Blog\image\20211117F1.PNG)

## 算法讨论

首先将这个序列进行排序，那么显然一组内的数都是在一个区间内的

那么可以处理处理从一个位置最多往前多少个为同一组是合法的$pre_i$

那么设$dp(i)$表示考虑到第i个数的时候是否存在分组方法
$$
dp(i)=\bigcup\limits_{j=pre_i}^{i-k+1} dp(j)
$$
用前缀和优化即可

# Isomorphic Strings

## 题目大意

![20211117F2](D:\Blog\image\20211117F2.PNG)

## 算法讨论

首先枚举26个字母，将$s'_i=[s_i=c]$，然后将$s_i$进行hash

查询的时候将两个区间的所有26种字符串的hash值求出

由于可以将字母任意进行替换，那么我们只需要关系位置相同的等价类集合是否相同即可

那么将所有这26种字符串的hash排序，如果组成的集合相同，那么说明可以匹配

时间复杂度$O(26n)$

# Team Players

## 题目大意

![20211117F3](D:\Blog\image\20211117F3.PNG)

## 算法讨论

考虑容斥，对三元组内部存在的边进行容斥

首先对于没有强制存在边的情况，就是考虑每一个位置的贡献即可

然后对于存在一条边的情况，对于输出的所有边，除这条边的两个端点之外的那个点的是在端点之间还是端点两侧，进行分类讨论，计算贡献

对于存在两条边的情况，那么就是枚举其中度数等于2的那个点的位置，然后相当于将连出的边分成了两个区间，剩下两个点落在这两个区间，还是分类讨论计算贡献即可

然后对于存在三条边的情况，那么相当于在原图上求出三元环，那么度数大的点向度数小的点连边，然后暴力枚举即可

时间复杂度$O(n\sqrt m)$

# Flow Control

## 题目大意

![20211117F4](D:\Blog\image\20211117F4.PNG)

## 算法讨论

首先$\sum s_i=0$，如果这个条件不满足，那么显然不合法

然后对于树来说，如果满足$\sum s_i=0$的条件的话，是一定有解的，那么就是从下往上的进行构造，将子树内的所有点的条件都满足，计算出当前点新的$s_i$
$$
s_x=s_x+\sum \limits_{u} s_u
$$
那么我们在原图中求出一棵生成树即可，然后按照树的方式进行构造，然后对于其他边都设为0即可

# GCD Counting

## 题目大意

![20211117F5](D:\Blog\image\20211117F5.PNG)

## 算法讨论

记$g(x)$表示$(x,y)$代表的gcd恰好为x的方案数

记$f(x)=\sum\limits_{d\geq 1}g(xd)$

那么显然$f(x)$就是$x,y$只经过可以被x整除的点的路径数量

如果可以计算$f(x)$

那么$g(x)=f(x)-\sum\limits_{d\geq 2} g(xd)$

那么枚举$x$，求出所有可以被x整除的点，然后求出所有联通块的贡献和即可

由于每一个点最多会被枚举到$\sigma(a_i)$次

那么复杂度为$O(n\max \sigma(V))$

