# C.Binary Strings

## 题目大意

给定$n$，写下1到$2^n-1$的二进制表示，然后按照字典序排序，求第x小的二进制表示
$$
n\leq 10^6
$$

## 算法讨论

从1开始不断扩展，1之后可以插入10,11，然后10之后可以插入100,101，11之后可以插入110,111……可以发现这样插入是形成了一个完全二叉树，每一条边有0/1，每一个非叶子节点有两条边，并且两条边上的数就是0和1，一个节点代表的二进制表示就是从根节点到该节点边上数字的拼接，然后字典序排序，就是树上dfs序的结果

那么从根节点出发，走第i步的时候，向左走$x$需要减$1$，向右走x需要减$2^{n-i}$，直接在x的二进制表示上减，总的操作数是$O(1)$的

时间复杂度$O(n)$

# D.Sum of Min of Xor

## 题目大意

给定两个长度为$n$的序列$a,b$，求
$$
\sum\limits_{i<j}\min(a_i\oplus a_j,b_i\oplus b_j)
$$

$$
n\leq 250000,a_i,b_i<2^{18}
$$

## 算法讨论

从高位到低位进行考虑，假设当前考虑到第$k$位，那么每一个数都可以用一个二元组$p_i=(A_i,B_j),A_i=a_i\&2^k,B_i=b_i\&2^k$，考虑在当前这一位分出大小的$i,j$，可以发现如果将这四种二元组进行分类的话，假设$S=\{(0,0),(1,1)\},T=\{(0,1),(1,0)\}$的话，如果$p_i,p_j$属于的集合不同，那么说明就是在当前这位上分出大小

那么分成两组，一组$\in S$，另外一组$\in T$，那么考虑组间的贡献（也就是在当前这一位分出大小的），高于k位的贡献已经在之前计算过了，只考虑等于低于k位的贡献，可以发现确定二元组，就可以知道产生贡献的是a还是b，那么将其中一组的a或者b每一位0/1出现的情况记录下来，然后再到另外一组计算贡献

对于组内的贡献，只有当$(0,0),(1,1)$或者$(1,0),(0,1)$才会有$2^k$的贡献

然后将分成的两组递归进行考虑

时间复杂度$O(n\log^2 n)$

# E.Priority Queue

## 题目大意

给定长度$A+B$的序列$X$，其中有$A$个1，$B$个2

现在有一个集合s，要进行$A+B$次操作

- $X_i=1$，挑选一个数字$1\leq v\leq A$，并且$v$没有在之前的操作中出现过，向$s$中加入$v$
- $X_i=2$，删除$s$中最大的元素

求可以得到不同的s有多少个
$$
A\leq 5000
$$

## 算法讨论

正在考虑比较困难，考虑倒过来进行考虑，那么第一种操作就变成删除s中的一个数，第二种操作就变成的加入一个之间没用的数，使得加入后是s中最大的数

那么问题就变成有多少个大小为$A-B$的集合s，使得通过这些操作变成空集的方案数，显然对于固定的s存在一种贪心策略，就是第一种操作删除当前s种最大的元素，第二种操作加入可以加入的元素中最小的那个

那么可以在过程中维护还可以加入元素的个数x，第二种操作会对x减1，假设一开始的s中存在$a_1<a_2<...<a_k,k=A-B$，如果删除了其中某一个最初元素$a_i$，那么要将x加入$a_i-a_{i-1}-1$，我们可以处理出k个元素是在什么时候被删除的$t_i$，其中有$t_1>t_2>...>t_k$，同时计算$t_i,t_{i-1}$之间第二种操作的个数$d_i$

那么可以设$dp(i,j)$表示考虑到第i个原来s中的元素，当前$x=j$的方案数
$$
f(j)=dp(i+1,j-d_i)\\
dp(i,j)=\sum\limits_{k=0}^j f(k)
$$
时间复杂度$O(A^2)$

# F.±AB

## 题目大意

给定$A,B,V,M$，一开始$x=V$，现在有以下四种操作$x+A,x-A,x+B,x-B$，并且在操作过程中$0\leq x\leq M$，找到有多少x可以被达到
$$
A,B,V,M\leq 10^9,(A,B)=1
$$


## 算法讨论

首先有一个结论，如果$M\geq A+B-1$的话，那么答案就是$M+1$，假设我们能证明$M=A+B-1$的时候结论成立，那么显然当$M$更大的时候，对于$i\geq A+B$，我们可以先走到$i-A$的地方，然后跳到$i$即可

考虑构造一组方案，可以先假设$A>B$，（事实上根据下面的推导，可以发现对于$A<B$的时候也是成立的）

- 若$x\geq B$，那么$x'=x-B$
- 若$x<B$，那么$x'=x+A$

不妨将$x$看作模$A$意义，第二个操作的意义就是，如果当前不够减了，那么可以走到下一个模$A$意义下相同的位置，然后再减$B$，由于$A,B$互质，当一个位置被重复经过的时候那么一定是走了$A+B$次（$Bk\equiv 0(\mod A)$的解为$k=pA$）

可以发现经过的路径事实上形成了一个包含所有位置的环，那么当$M<A+B-1$的时候，环上会有若干位置不能走，那么如果我们能求出从一个方向走，最少要走$x$步到达不能走到位置，和另一个方向的步数$y$，那么答案就是$x+y-1$

考虑以构造的方案方向走，也就是由$-B,+A$组成，相当于我们要从$x=v$，经过一系列操作使得$x\in [m+1,A+B-1]$，那么不妨让最初$x=0$，经过一系列操作使得$x\in [l,r],l=m+1-v,r=A+B-1-v$，事实上如果不对x进行操作，而对区间进行操作和原问题等价

考虑先走$t=\lceil \frac{l}{B}\rceil$步，那么$l'=l-tB,r'=r-tB$，如果$0\in [l',r']$话，问题就解决了，接下来考虑$r'<0$的情况

接下来是使用$+A$，然后在使用$\lfloor \frac{A}{B}\rfloor $次$-B$操作，那么就相当于变成了一个$+ A\bmod B$操作（操作一次的代价为$1+\frac{A}{B}$），那么问题就变成了$(A\bmod B,B)$形式的问题，我们可以通过将$l=-l,r=-r$，变成$(B,A\bmod B)$的问题，那么这就是一个欧几里得算法的形式

具体的，定义函数$solve(A,B,cnt_A,cnt_B,l,r)$表示在操作$+A,-B$下的最小操作步数，其中$cnt_A,cnt_B$表示进行一次$+A$或者$-B$操作所需要的代价，经过上面的转化相当于要变成$solve(B,A\bmod B,cnt_B,cnt_A+\lfloor \frac{A}{B}\rfloor cnt_B,-r',-l')$的问题

时间复杂度$O(T\log n)$

