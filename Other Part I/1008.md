# SRM515 NewItemShop

## 题目大意

现在有24个小时，有swords个剑，现在有若干个客人要来买剑

每一个客人可能会在多个时间过来（保证任意一个小时都至多只有一个客人可能过来），一个客人只会在一个时刻过来，$T_j,C_j,P_j$表示这个客人有$P_j$的概率在$T_j$小时过来，用$C_j$的价格，现在可以拒绝或者接受这个价格，要求卖出的价格期望最大

## 算法讨论

首先我们肯定需要记录，哪些客人在之前的时间已经过来过了，直接状压的复杂度$2^{24}$，需要优化

注意到如果某一个客人只可能在一个时刻中过来，那么我们就不需要这个客人之前是否过来过的信息，那么这样需要记录之前是否过来过的信息的客人最多只有$12$个，那么可以直接状压

那么我们需要在每一个小时$i$上记录这个小时中可能会过来的客人编号，给出的价格$c_i$，**在满足这个小时之后过来的条件概率$p_i$**

**设$dp(i,j,mask)$表示从这个状态一直到结束的最大期望**，转移的时候考虑如果这个客人过来了，是接受还是拒绝，相当于是在这两个决策中取期望最大的

- 如果当前时间的客人只可能在这个时刻过来，那么$dp(i,j,mask)=p_i\max(dp(i+1,j+1,mask)+c_i,dp(i+1,j,mask))+(1-p_i)dp(i+1,j,mask)$

- 如果当前时间的客人$x$不只在这个时刻可能过来

  - 如果$x\in mask$，那么$dp(i,j,mask)=dp(i+1,j,mask)$

  - 否则，这个客人就有可能在当前这个时刻过来，那么按照上面第一种情况的转移，可以得到

  - $$
    dp(i,j,mask)=p_i\max(dp(i+1,j+1,s)+c_i,dp(i+1,j,s))+(1-p_i)dp(i+1,j,mask)\\
    s=mask\or \{i\}
    $$

### 一些问题

1.一开始的时候，我是想着从前往后进行转移，由于期望计算是总和乘概率，如果是$f(i)=p_i(f(i-1)+c_i)$这样的转移式的话，**当前的贡献是没有乘上之前的概率的**，转移是错误的，需要同时记录一下达到这个状态的概率，会比较烦

而从后往前进行转移的话，相当于就是求出$c_i\prod\limits_{j\leq i}p_j$，**之后的所有情况的概率和是1，就不需要乘后面概率了**

**期望DP往往从后往前进行DP，其实就是比较像，单源多汇的DP将转移边翻转变成多源单汇的情况，这样就可以保证在一个状态之后的所有状态概率和为1**

2.还有一个问题就是$p_i$为什么要取得是条件概率，**笼统来说就是因为一个客人的时刻上的概率是不独立的，也就是不能直接相乘，但是我们是需要相乘的形式的**

考虑一个时刻序列的概率$p_1,p_2,p_3,...$

根据上面的计算式，我们相当于需要使得$(1-p_1)(1-p_2)...(1-p_{k-1})p_k$等于这个客人在$t_k$时刻来的概率

那么显然$p_i$就是表示客人来的时间大于等于当前时间的条件下，在当前时间过来的概率

**其实如果没有$\max$，是可以使用期望线性性拆开的**

# SRM522 CorrectMultiplication

## 题目大意

给定$a,b,c$，要求三个变量$A,B,C$，满足$A\times B=C$

并且最小化$|A-a|+|B-b|+|C-c|$
$$
a,b,c\leq 10^9
$$

## 算法讨论

首先答案应该不会超过$1e9$左右的范围，那么说明$C$应该也在$10^9$的范围之内，令$N=O(10^9)$

那么$C\leq N$，由于$A\times B=C$

那么一定有$\min(A,B)\leq \sqrt N$

那么我们就可以枚举其中最小的那个数（需要注意的是，A,B都需要枚举一次），假设当且枚举的是$A$

那么问题就变成了找到一个合适的B，最小化$|B-b|+|A\times B-c|$的值，显然绝对值函数的极值一定是在端点处取到的，那么可以取$B=b,\lfloor \frac{c}{A}\rfloor,\lfloor \frac{c}{A}\rfloor+1$值带入计算

时间复杂度$O(\sqrt N)$

# SRM603 PairsOfStrings

## 题目大意

定义一个二元组$(A,B)$是合法的当且仅当

- $A,B$都是由前$k$个字符组成的长度为$n$的字符串
- 并且存在一个字符串$C$，使得$A+C=C+B$成立

给定$n,k$，求合法二元组的数量
$$
n\leq 10^9,k\leq 26
$$

## 算法讨论

可以发现，如果$A$可以通过循环移位得到$B$的话，$(A,B)$一定是合法的，证明比较简单

如果一个最小循环节为$k$的字符串，其可以得到的不同的循环位移字符串数量就是$k$，那么我们只需要处理出现最小循环节为$k$的字符串数量$f_k$，对答案的贡献就是$kf_k$

那么先设$g_i$表示循环节为$i$的字符串个数，那么有$g_i=k^i$，并且要求$i| n$

那么$g_i=\sum\limits_{j|i} f_j$，事实上是一个前缀和，差分一下就可以得到$f$，当然也可以用莫比乌斯反演得到
$$
f_i=\sum\limits_{j|i}\mu(\frac{i}{j}) g_j
$$
需要注意的是所有合法的$i$都应该是$n$的因数，那么运算都是在这些因数中进行，1e9范围内最大的因数个数大概在$10^3$级别

# StringEquations

## 题目大意

给定若干字符串等式$A=B+s$的形式，s是给定的字符串，$A,B$都是变量，要求判断这些等式是否自洽，并且求出所有变量最小长度和

## 算法讨论

考虑建出图来，对于表达式$A=B+s$，建立$B\rightarrow_s A$的一条边

那么可以发现得到的有向图必须是一个DAG才是有可能合法的

但是这样计算答案仍然不好计算，如果我们可以将DAG缩成一个外向树的话，就可以很方便的计算答案

我们按照拓扑序的顺序来考虑

首先考虑一个节点所有的入边，这些入边需要满足一些条件，就是如果将这些入边上的字符串按照长度排序的话，长度小的一定是长度大的后缀，否则就不合法

那么显然这样记录信息是浪费的，那么考虑简化，我们可以在排好序的边节点依次建立边，边上就是长度小的字符串前面没有出现过的信息

<img src="D:\Blog\image\IMG_20210822_183457.jpg" alt="IMG_20210822_183457" style="zoom:50%;" />

然后有可能对于连过来的边还是存在两个入边，那么就递归处理一下就可以了

**需要注意的是，如果将这个图缩成了一个链的话，可能存在链前面的节点连向后面的节点，那么需要特殊判断否则会死循环**

**另解**：一开始建边的时候不止是要建一条有向边，对于反向的负权边也要建出来，代表着经过这条边，就要在当前字符串的后缀减去这个字符串

就是由于数据范围很小直接在原图上进行dfs，看最长的路径和最短的路径长度是否相等，如果不相等那么一定不合法，然后在判断字符串的问题，就是在dfs过程直接将这个字符串维护出来

# RowAndCoins

## 题目大意

给定长度为$n$的包含AB的字符串，Alice和Bob轮流操作，每一次将连续的一段空格子放上一枚硬币，但是不能使所有格子都不为空，如果最后剩下的那个格子为A，Alice获胜，剩下的那个格子为B，Bob获胜

求最终获胜者
$$
n\leq 14
$$


## 算法讨论

考虑DP，设$dp(s,0/1)$表示当前格子放硬币的状态为s，当前是Alice还是Bob进行操作最终的情况

边界条件为$s$中1的个数等于n-1，那么返回剩下那个格子的情况

以1为例

然后枚举一段区间$[l,r]$，如果s中这一段区间不存在1，那么这一段区间内的格子放上硬币，得到$s$，如果$dp(s,0)$是1，那么直接返回1，如果所有的$[l,r]$枚举之后都不为1，那么就返回0

时间复杂度$O(n^32^n)$

# RotatedClock

## 题目大意

现在给出只有时针和分针的时钟，但这个时钟可能被旋转过了，但是有一个刻度恰好指到竖直位置上，现在给出时针和分针与竖直方向的角度，求出最小可能时间

## 算法讨论

首先时针每分钟转过0.5度，每小时转过30度，分针每分钟转过6度，看到时针的0.5度就很烦，那么不妨将所有的角度乘2，然后一周为720个单位

那么所有可能的时间都是在整数上了

首先处理出来所有720分钟，时针和分针与竖直方向的夹角，记入到一个map中

然后再来调整给出时针和分针的角度，**需要注意的是这里只能不断旋转60个单位，因为需要有一个刻度与竖直方向对齐**，那么枚举旋转过多少个刻度，然后在map中查找即可

**需要注意的是，如果一开始分针和时针重合，需要特殊判断**

# RabbitStepping

## 题目大意

现在有n个格子，每一个格子都有白黑红三种颜色，要在这n个格子中放r个兔子，根据如下的规则进行模拟，求所有情况剩下的兔子个数和

- Each rabbit steps onto a neighboring cell. Since each cell potentially has up to two neighboring cells, the following rules are used to determine which cell the rabbit will choose:
  - If a rabbit is on cell 0, she must step onto cell 1.
  - If a rabbit is on cell *size* - 1 or *size* - 2, she must step onto the left neighboring cell.
  - All other rabbits choose which neighboring cell to step onto according to the color of the cell they are currently on:
    - White: She must step onto the left neighboring cell.
    - Black: She must step onto the right neighboring cell.
    - Red: If this is her first move, she must step onto the left neighboring cell. Otherwise, she must return to the cell she was on immediately before she was on the current cell.
- After all rabbits finished their steps, for each cell that contains more than one rabbit, all rabbits on that cell will be removed from the field.
- The rightmost cell will disappear (causing the *size* of the field to decrease by 1). By the rules above, this cell will always be empty.

$$
n\leq 18
$$

## 算法讨论

首先枚举是哪r个格子初始放了兔子

那么我们考虑记录两个数组，两个辅助数组，

首先用$vi$记录当前哪些格子上面有兔子，$last_i$表示第$i$个格子上面的兔子是从哪个格子跳过来的（用于处理红色格子的情况）$tmp$用于记录经过一轮操作过后，兔子的分布情况，$to$用于记录上一轮的last

首先按照上面的规则进行模拟，用tmp记录结果，如果某一位的兔子数量>1，那么将这一位的兔子清空，也就是将tmp赋为0

然后考虑更新last，再进行一遍模拟，这一次如果从i出发的兔子的目标位置tmp=0，那么说明这个兔子会被清空，那么直接跳过，否则将目标位置的$last$改为$i$

注意这里需要用to进行模拟，应该再过程中last会被改变

# ColorfulRabbits

## 题目大意

给定n条信息，第$i$条信息表示在所有兔子中，与询问的兔子相同颜色的有$a_i$个，求最少需要有多少个兔子
$$
n\leq 50
$$

## 算法讨论

首先将所有$a_i$相同的兔子一起考虑，假设有$k$个，那么显然一种颜色要有$a_i+1$个兔子，那么这$k$个兔子中需要存在$\lceil \frac{k}{a_i+1}\rceil$种颜色，那么就需要有$\lceil \frac{k}{a_i+1}\rceil(a_i+1)$个兔子

那么对于所有不同的$a_i$对上面那个式子求和就是答案

时间复杂度$O(n)$

# BunnyComputer

## 题目大意

给定长度为$n$的序列，每一个元素都有一个价值$a_i$，现在要求在这个序列上放若干长度为$k+1$区间，使得区间在顶点处不交，要求最大化所有区间顶点处价值的和
$$
n\leq 50
$$

## 算法讨论

首先令$k'=k+1$，以下叙述都用$k$代替$k'$

需要将所有的位置按照模k，分成若干组，显然组之间是互不干扰的，只需要将每一组的最大价值和相加就是答案

在组内，相当于是可以将两个相邻的元素匹配起来，那么就可以进行DP

设$dp(i,0/1/2)$表示考虑到第$i$个位置，0表示当前元素不在匹配内，1表示当前元素在匹配内并且是左边的元素，2表示当前元素在匹配内并且是右边的元素
$$
dp(i,0)=\max(dp(i-1,0),dp(i-1,2))\\
dp(i,1)=\max(dp(i-1,0),dp(i-1,2))+a_i\\
dp(i,2)=dp(i-1,1)+a_i
$$
答案就是$\max(dp(len,0),dp(len,2))$

这样复杂度就是$O(n)$

# ColorfulStrings

## 题目大意

定义函数$f$作用在只包含数字的字符串上，$f(s)$为所有元素的乘积

现在定义一个只包含数字的字符串s为多彩的，当且仅当，对于所有s中的子串$t$，其$f(t)$的数值两两不同

给定$n,k$求出所有长度为$n$的多彩字符串，字典序第k小的字符串
$$
n\leq 50,k\leq 10^9
$$

## 算法讨论

首先，一个字符串为多彩的充分必要条件是，s中每一单个数字，不能被s中其他数字乘积表示出来，并且不存在重复数字

由于后面这个条件的存在，那么说明$n\leq 9$

由于不能存在0,1（如果存在0,1，那么相邻的数一定就是不合法的），那么合法数字只有8个，那么$n\leq 8$

所有情况不会超过$8!$个，那么就可以暴力枚举

从第一位到第n位依次从小到大枚举这一位上的数字，枚举到最后的时候，需要建出得到的字符串是否合法，当求到第k个合法的字符串的时候，直接输出答案

需要特殊判断一下$n=1$的情况

# RabbitsAndCakes

## 题目大意

现在给定$L_r,R_r,L_c,R_c$表示兔子的数量区间为$[L_r,R_r]$蛋糕的数量区间为$[L_c,R_c]$

如果有$R$个兔子，$C$个蛋糕，可以将每一个蛋糕分成最多两块（可以任意大小），然后分配这些块，使得每一个兔子分到的蛋糕为$\frac{C}{R}$个
$$
L_r,R_r,L_c,R_c\leq 10^6
$$

## 算法讨论

直接推出不是很会做，然后打个表，找了合法$(R,C)$的规律

一开始我是固定C，然后找R的规律，但是找不到什么规律，然后要将固定的交换一下，当固定$R$的时刻，会发现一个C合法，当且仅当$R=C$或者$C=R+x,x|R$

考虑证明必要性，首先$R=C$的情况，十分显然，不需要切任何一个蛋糕

只需要考虑证明$C=R+x,x|R$的情况

那么一个兔子需要的蛋糕数量为$1+\frac{1}{y},y=\frac{R}{x}$

那么第一个兔子分到的蛋糕为$1,\frac{1}{y}$

第二个兔子分到的蛋糕为$\frac{y-1}{y},\frac{2}{y}$

第三个兔子分到的蛋糕为$\frac{y-2}{y},\frac{3}{y}$

...

第$y-1$个兔子 分到的蛋糕为$\frac{2}{y},\frac{y-1}{y}$

第$y$个兔子分到的蛋糕为$\frac{1}{y},1$

那么相当于每y个兔子为一个周期，显然$xy=R,y|R$，那么所有周期都是完整的

还需要证明一下充分性，首先我们需要证明，所有切蛋糕的策略都是可以规约到上面这种切蛋糕的策略上来，首先一个蛋糕，最多只会被分到两个兔子上面来，我们可以随便找一个兔子，将其分到的一个蛋糕变成一个完整的蛋糕（当$C<R$的时候显然不正确，因为1分成两个蛋糕肯定其中一块的份额是大于等于$\frac{1}{2}$），然后调整影响到的兔子

然后如果$y$不整除$R$的话，那么说明会存在一个周期不完整，也就是说存在一个蛋糕有一块没有分完，那么显然不符合条件

那么结论证明完毕

具体实现由于$<10^6$，可以先调和级数枚举$R=C$的情况

然后对于所有$R$分解质因数，加上其因数得到的在范围内的所有情况