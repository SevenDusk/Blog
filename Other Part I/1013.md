# ToastXToast

## 题目大意

现在有n个机器，每一个机器都有一个数，可以询问一个机器一个数，如果这个数大，返回1，否则返回0

给出询问的数和返回值，求最小有多少机器

## 算法讨论

首先最大值一定在返回1中，最小值在返回0中，然后答案最多为2

首先如果返回0的最大值<返回1的最小值，那么答案为1，否则为2

# TheLotteryBothDivs

## 题目大意

现在有9位号码，在里面随机选出一个号码，给定n个字符串，如果号码存在一个后缀与这些字符串中一个相等，那么这个号码中奖，求中奖概率

## 算法讨论

将两个存在后缀关系的字符串，去除较长的那个，只保留长度小的那个，然后保留字符串的贡献为$10^{len}$

# FoxPlayingGame

## 题目大意

现在可以进行n次1操作，m次2操作，初始分数为0，进行一次1操作，分数+A，进行一次2操作，分数*B

求最大分数

## 算法讨论

考虑设$f(n,m)$表示进行了$n,m$可以得到的**最小负数和最大正数分数，这样设是因为可能存在乘负数的情况，一开始没考虑到**

那么转移就是比较显然了

当然也可以对A,B的正负性进行分类讨论

# FoxSequence

## 题目大意

给定序列s，如果存在$0<a<b\leq c<d<n-1$满足

- seq[0], seq[1], ... , seq[a] forms an arithmetic progression with a positive common difference. An arithmetic progression is a sequence where the difference between successive elements is equal. The difference between successive elements is called the common difference. Note that 0 is neither positive nor negative.
- seq[a], seq[a+1], ... , seq[b] forms an arithmetic progression with a negative common difference.
- seq[b], seq[b+1], ... , seq[c] are all equal.
- seq[c], seq[c+1], ... , seq[d] forms an arithmetic progression with a positive common difference.
- seq[d], seq[d+1], ... , seq[N-1] forms an arithmetic progression with a negative common difference.

称这个序列合法

## 算法讨论

首先将$s$差分得到$a$，然后将相同正负性的极长段缩成一段（这里有三种正负性，0要单独算）

那么可能的合法的情况为

- $+\  -\ 0\ +\ -$
- $+\ -\ +\ -$

直接模拟这个过程即可

# ColorfulRabbits

## 题目大意

给定n条信息，第$i$条信息表示在所有兔子中，与询问的兔子相同颜色的有$a_i$个，求最少需要有多少个兔子
$$
n\leq 50
$$

## 算法讨论

首先将所有$a_i$相同的兔子一起考虑，假设有$k$个，那么显然一种颜色要有$a_i+1$个兔子，那么这$k$个兔子中需要存在$\lceil \frac{k}{a_i+1}\rceil$种颜色，那么就需要有$\lceil \frac{k}{a_i+1}\rceil(a_i+1)$个兔子

那么对于所有不同的$a_i$对上面那个式子求和就是答案

时间复杂度$O(n)$

# PermutationSignature

## 题目大意

给定长度为n的排列相邻两个元素的大小关系，要求构造这样字典序最小的排列

## 算法讨论

可以将相邻两个元素中较小的位置向较大的位置连一条有向边，那么进行拓扑排序，并且要求字典序最小

那么用优先队列大根堆替代队列，然后将数值从大到小进行分配

可以发现这样一定得到的是字典序最小的

# ColoredStrokes

##  算法讨论

现在在$n\times m$的网格上画线段，线段只能是竖直或者水平的，竖直的线段为蓝色，水平的线段为红色，保证不存在两个同方向的线段重合，如果两个不同方向的线段相交，那么那个格子的颜色变为绿色

给出网格的染色情况，求最小线段数量

## 算法讨论

考虑一行一行进行考虑，这时候可以将绿色格子看作红色，然后将有颜色的线段缩成一段，染色这一行至少需要段数次画画

对于列的情况也是类似，也是一列一列进行考虑，这时候可以将绿色格子看作蓝色即可，贡献也是形成的段数

# ColorfulCards

## 算法讨论

现在有n张卡片，有1到n的数字，如果一张卡片上的数字为质数，那么这张卡片为红色，如果为合数，那么这张卡片为蓝色，现在在里面挑出若干张卡片，然后按照卡片上的数字进行排序，给出排序后卡片的颜色，求出每一位的数字，如果不能唯一确定用-1替代

## 算法讨论

首先将所有卡片的颜色求出，考虑进行匹配

设$pre(i,j)$表示考虑到前$i$张卡片，已经匹配到挑出来卡片的第$j$张是否合法，设$suc(i,j)$表示从后往前考虑到第$i$张卡片，已经匹配到挑出来卡片的第$j$张是否合法

然后考虑挑出来的第x张卡片，枚举其上面的数字$i$，如果颜色相同，并且$pre(i-1,x-1),suc(i+1,x+1)$合法，那么说明这张卡片上的数字可以为i，如果存在多个数字合法，那么输出-1，否则输出合法数字

# Painting

## 题目大意

$n\times m$的网格上格子要么是黑的要么白色的，现在要用$k\times k$覆盖所有黑色格子，黑色格子可以被覆盖多次，白色格子不能被覆盖，求最大的$k$

## 算法讨论

首先二分答案，然后将所有可以放到网格（也就是这里面的格子都是黑色格子）上的$k\times k$的正方形求出，然后将正方形内的格子打上标记

如果存在黑色格子没有标记，那么当前的边长不合法

# StonesGame

## 题目大意

现在有n个石头，除了第m个石头都是黑色的，第m个石头是白色的，现在可以选择连续的k个格子，然后翻转他们的顺序，有两个人轮流进行，知道第l个石头变成白色，最后一步的玩家胜利

求出先手必胜还是后手必胜或者平局

## 算法讨论

首先一定在两步中决出游戏的结果，因为如果两步不能使游戏结束，那么肯定有一方会意识到自己必输，那么一定会复制上一个玩家的决策，那么游戏无法结束

首先考虑一步到达的情况，这是简单的

如果一步可以使游戏结束，那么先手必胜，否则枚举这一步的情况，判断是否存在一种操作使得后手不能一步结束游戏，如果存在就是平局，否则就是后手胜利

**一开始看错题，以为是颜色翻转，不过是差不多的，像这种操作可以撤销的都是需要在两步中决出胜负还是平局**

# TimeTravellingGardener

## 算法讨论

现在有n棵树，第i棵树和第i+1棵树的距离为$d_i$，第i棵树的高度为$h_i$，现在可以减少一些树的高度，使得两颗树的高度差与其距离差成线性关系

求出最小需要减少多少颗树的高度

## 算法讨论

首先可以枚举两个，那么这两棵树的高度决定的直线的斜率，那么直接枚举这两个树求出斜率进行判断，注意这里可以将其中某一个的树高度变为0，那么有四种情况考虑

# FoxMakingDiceEasy

## 算法讨论

给定$n,k$，要求在1到n中选出6个数，填到骰子上，使得对面的两个数和都要相同，并且这个和$\geq k$，求方案数

## 算法讨论

直接枚举6个面上填哪些数

# Starport

## 算法讨论

现在每隔m分钟会来一辆车，每隔n分钟会来接车，当一辆车没有被接车是需要一直等待，求所有车的平均等待时间

## 算法讨论

首先将n,m除以$gcd(n,m)$，最后在答案乘上$gcd(n,m)$即可，以下默认$n,m$互质

那么只需要考虑一个周期即可

答案为
$$
\frac{(\sum\limits_{i=0}^{n-1}n-(i m\bmod n))-n}{n}=\frac{n-1}{2}
$$