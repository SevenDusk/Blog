# CF960H Santa's Gift

## 题目大意

![202109141](D:\Blog\image\202109141.PNG)

## 算法讨论

先简化一下式子
$$
\begin{align}
&\sum\limits_{i=1}^n (s_ib_x-C)^2\\
&=nC^2-2b_kC(\sum\limits_{i=1}^n s_i)+b_k^2\sum\limits_{i=1}^n s_i^2
\end{align}
$$
其中$\sum\limits_{i=1}^n s_i=\sum\limits_{i=1}^n[f_i=k]de_i,de_1=1$，这个可以很方便的支持加减操作，然后接下来要考虑的是$\sum\limits_{i=1}^n s_i^2$

考虑其意义，相当于是从子树内选出两个颜色为$k$的方案数之和，等价于$\sum\limits_{i=1}^n\sum\limits_{j=1}^n[f_i=k\and f_j=k]de_{lca(i,j)}$

### Solution 1

由于要改变一个点的颜色，相当于要支持删去一个点和加入的一个点的操作，一个经典套路就是对于每一个颜色为$k$的点，将其到根节点上所有节点权值都+1，然后查询某一个点和其他点lca的深度和等价于查该点到根路径上所有点的权值和

然后对于每一个颜色开一个动态开点线段树支持区间加区间查询，可以标记永久化减少内存消耗（这里由于需要区间查询，还是需要维护一个节点以下的和sum，更新的时候要加上当前节点的tag），然后用树链剖分处理到根路径上的加减

虽然理论上空间复杂度为$O(n\log^2 n)$，但是可以带上内存回收，并且使用了标记永久化，就不要下传标记了，基本上就是$\log n$的内存

时间复杂度$O(n\log ^2n )$

注意一下需要开long long（错误点）

### Solution 2

事实上求$de_{lca(i,j)}=\frac{de_i+de_j-dis(i,j)}{2}$，那么需要求的就是$dis(i,j)$，那么不难想到利用点分树进行维护

在点分树上维护点分中心$x$到子树内所有颜色为$k$的距离和$a_k(x)$，还有这个点分中心父亲$fa(x)$到$x$子树内所有颜色为$k$的距离和$b_k(x)$，还有对应的$k$颜色的个数$h_k$，这个对于子树内存在颜色的才存储$a_k(x),b_k(x)$，这个可以用map实现

查询的话直接暴力跳，然后在节点$x$贡献就是
$$
dis(x,y)\times h_k(x)+a_k(x)-b_k(x)
$$
时间空间复杂度均为$O(n\log n)$

[maroonrk](https://codeforces.com/contest/960/submission/69889250)

第一次提交:WA

# CF1120F Secret Letters

## 题目大意

![202109142](D:\Blog\image\202109142.PNG)

## 题目大意

首先如果选择将信寄存的序列为$PWPW...$如果假设第一封信的时间为$t_i$，那么只需要支付$t_{n+1}-t_i$即可，之后都是免费的，只要枚举开头那个位置在哪里，那么我们就要尽可能的这样选择，证明就是反证一下就可以了

这时候会发现一个问题，如果是$PPPW$，那么其中多出来的两个$P$还是需要支付费用的，如果W的位置为$j$，其中夹着P的位置为$i$，那么需要支付的费用是$\min(d,c(t_j-t_i))$

可以对于每一个位置都预处理出来下一个不是当前收信人的位置$nxt_i$，那么显然需要寄存序列的下一个就是$nxt_i$

至于夹在其中的信件，那么就用$\min(d,c(t_j-t_i))$，进行计算即可，显然$j=nxt_i$

时间复杂度$O(n)$

第一次提交：AC

# CF720D Slalom

## 题目大意

![202109143](D:\Blog\image\202109143.PNG)

## 算法讨论

需要注意的是如果直接DP的话会算重，那么就需要确定一种唯一的走的方式

由于往上走之后是不能回头的，那么对于同一种路线我们尽量不往上走，一直往右走，直到遇到障碍物或者边界的时候才往上走，可以发现这样对于不同方案来说是唯一的

这样的话可以在从左往右扫描线的时候暴力DP，设$f(i,j)$表示走到当前$(i,j)$的不同方案数，如果$(i,j),(i+1,j)$都没有障碍，那么$f(i+1,j)=f(i,j)$，其中如果$(i,j)$为障碍，$(i+1,j)$没有障碍的话是不需要处理的，重点就是如果$(i,j)$不为障碍，$(i+1,j)$为障碍的情况，相当于需要开始向上走了，考虑当前障碍的区间为$[l,r]$，那么找到最大的$pos\leq r+1$，使得$(i,pos)$为障碍

那么$f(i+1,r+1)=\sum\limits_{j=pos+1}^{r+1}f(i,j)$

考虑用线段树维护第二维，在维护$f(i,j)$的同时还需要维护节点区间内是否存在障碍，其中$pos$可以通过线段树上二分求得，

然后只要求一下区间和即可

**需要注意的是，如果$(i+1,r+1)$如果是障碍的话是不能进行更新的，并且需要计算出来$f(i+1,r+1)$之后再进行修改**（错误点）

### Solution 2

可以用set维护被覆盖的区间障碍，然后用树状数组维护$f(i)$，其他部分还是跟上面一样的，主要是如果加入了一个新的障碍导致之前原本$f(i,j)\neq 0$的$j$需要变成0，事实上每一个$f(i,j)\neq 0$，都是某一个障碍的$r+1$所转移出来的，那么就可以采用演示删除的方法，维护一个待删除集合，转移的时候在待删除集合中加入这个位置，当加入新的障碍的时候，找到所有在区间内的障碍，然后将这个位置上的$f$设为0

这样写起来很简单

[Y_UME](https://codeforces.com/contest/720/submission/22375954)

第一次提交：WA