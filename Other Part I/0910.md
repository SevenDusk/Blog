# CF1290F Making Shapes

## 题目大意

![2021-09-10 15-34-51屏幕截图](D:\Blog\image\2021-09-10 15-34-51屏幕截图.png)

## 算法讨论

首先一个选择向量的合法方式唯一对应着一个凸多边形，如果对于第$i$个向量选择了$p_i$个

那么有如下条件成立

- $\sum\limits_{x_i>0} p_ix_i=-\sum\limits_{x_i<0}p_ix_i=X\leq m$
- $\sum\limits_{y_i>0} p_iy_i=-\sum\limits_{y_i<0}p_iy_i=Y\leq m$

那么要求的是有多少个$(p_1,p_2,...,p_n)$满足这个条件

一开始的想法：觉得这是个不定方程，要求解的组数并且和的还有限制，想着用两个变量表示出其他变量，但是无法做的，后来有想了一些在代数上变形的做法，都没有跳出这个常规的圈子

这个是常规方法处理不了的问题，其原因常规方法绕不过枚举的问题，如果直接枚举会有很多选择空间，**说白了就是一次考虑的太多了，可能就需要将若干次的枚举组合起来**

考虑二进制从低位到高位一位一位的进行考虑，假设用$a,b,c,d$替代$\sum\limits_{x_i>0} p_ix_i,-\sum\limits_{x_i<0}p_ix_i,\sum\limits_{y_i>0} p_iy_i,-\sum\limits_{y_i<0}p_iy_i$，如果我们记录之前进位的内容，前面我们只需要知道已经枚举过的位是否比$m$大两个信息

那么就可以用DP了，设$dp(i,a,b,c,d,tx,ty)$表示考虑到第$i$位，进位情况为$a,b,c,d$，其中$x$维的和前$i$位是否大于$m$，$y$维的和前$i$位是否大于$m$的方案数

那么转移的时候，枚举$n$个$p$当前这一位是否为$1$，处理进位情况，然后$a,b$的当前位要相同，$c,d$的当前位要相同，然后根据当前位和m当前位的情况更新$tx,ty$

其中进位的范围为$4n$

那么时间复杂度$O(2^n n^4 \log m)$，常数有1024之大，需要在转移的时候判断无用转移，就是dp=0的情况，因为很多情况都是不合法的

# CF542B Duck Hunt

## 题目大意

![20210911](D:\Blog\image\20210911.PNG)

## 算法讨论

首先将最多能射到多少个鸭子转化为最小不能射到多少个鸭子，鸭子向右走边长猎人向右走，相当于现在要在数轴上设置若干关键点，使得两个不同关键点之间的距离至少为$r$

然后由于值域很大，想办法将其转化为比较小值域上的问题，就是将所有端点离散化，然后考虑两个相邻端点之间都是等价的，需要特殊判断一下端点的开闭，如果这个靠左端点只有区间左端点，那么左边为闭区间，如果靠右端点只有区间右端点，那么右边为闭区间，如果这个端点既有区间左端点还有区间右端点，那么这个端点需要单独为一个区间

那么我们将值域缩成了若干区间，每一个区间内的点被覆盖的情况都是相同的，那么考虑一个DP，设$dp(i,j)$表示考虑到第$i$个区间，上一个关键点的位置在$j$的答案，那么显然我们不能将DP整个求出，要将其看作一个关于$j$的函数，如果将相邻数值相同的$j$缩成一段，可以证明段数是$O(n)$的，我们先假设这个结论成立

考虑转移假设当前缩成的区间为$l,r$，那么对于$j<l$的函数直接继承过来即可，在计算完之后，找出原来n个区间右端点在r的区间，记其左端点为$p$，那么对于位置$<p$的段都要+1

接下来考虑$l\leq j\leq r$的位置，有转移$dp(i,j)=\min\limits_{k=0}^{j-r}dp(i-1,k)$，相当于是求一个前缀$min$，那么将$l-m,r-m$所在段求出，然后进行找到第一个比当前前缀min更小的位置，然后将这一段位置设成新的段

考虑一个新段产生的条件，那么就是$dp(i-1,j-r)<\min\limits_{k=0}^{j-r-1}dp(i-1,k)$，而前缀+1最多只有$O(n)$次，分成的段也最多只有$O(n)$，那么不同的位置也只有$O(n)$，那么新出的段总体就是$O(n)$的

这些所有操作都可以用线段树解决

### 另解

- 也可以不离散化，就是多用一个堆来维护一个新的段，堆中按照时间顺序排序，依次取出堆顶的区间进行处理，处理完之后，在加入$[l+m,r+m]$的区间，这样维护新段就比较方便https://codeforces.com/contest/542/submission/18515768
- 还有就是用笛卡尔树维护，就是我们需要的是求出一个位置比其小的下一个位置是什么，那么就可以用单调栈进行维护，那么相当于动态单调栈，由于是前缀+1，可能会影响当前的前缀min，只需要判断一下，找到新的前缀min即可

