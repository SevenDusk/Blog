# 兔子

## 题目大意

![20211116T1](D:\Blog\image\20211116T1.PNG)

## 算法讨论

首先如果我们将$a_i$连向$b_i$，那么第一类条件一定是满足的

如果不满足第二类条件，那么说明不可能存在解（因为无论是什么图，总是要满足第一类条件的，都可以转化为当前这个图）

那么问题就变成了给定一张有向图，求任意两点是否可以到达

这个是一个经典的用bitset解决的问题，首先将有向图进行缩点，然后在DAG上按照反向拓扑序求出这个点的后继节点，用bitset存下来即可
$$
f(x)=\bigcup \limits_{x,u} f(u)
$$
直接做时间空间复杂度都是$O(\frac{n^2}{w})$，但是空间可能存不下

那么就考虑将整个bitset分成若干段，每一段进行一次计算即可，假设分成段的长度为$B$，那么空间复杂度是$\frac{nB}{w}$，时间复杂度不变

# 钻石

## 题目大意

![20211116T2](D:\Blog\image\20211116T2.PNG)

## 算法讨论

首先需要将曼哈顿距离转化成切比雪夫距离，这样只要知道已选点的四个边界就可以知道任意一个点到已选点的最大值

那么$(x,y)\rightarrow (x+y-2,x-y+7)$，那么每一维的范围在$[0,14]$之间

然后设$dp(a,b,c,d)$表示已选点x最小值为a，x最大值为b，y最小值为c，y最大值为d的最小代价

然后枚举一个不在边界内的点，然后更新边界，将那些不在原来边界内但是在更新之后边界的点，按照更新之后的点计算贡献即可，这是因为这些点选择之后并不会影响边界，而此时边界是之后时间内最小的，那么肯定在当前加入已选点即可

枚举量大概为$8^8$左右，暴力实现就可以了

# 猩猩

## 题目大意

![20211117T6](D:\Blog\image\20211117T6.PNG)

## 算法讨论

首先将进行操作的过程建出一颗树，对于每一个节点x，代表着子树的序列，同时记录一个$v_x$，表示这个序列重复了多少次

对于第一个操作，我们新建一个点，并且记录$a_i$

第二个操作，同样新建一个节点x，然后将第二个弹出的节点作为x的左儿子，第一个弹出的节点作为x的右儿子

第三个操作，对于栈顶的节点次数$v_x\times (-a_i)$

然后就需要求出这棵树代表序列的逆序对

考虑一个节点x，记代表序列的逆序对为$f(x) $，假设将左儿子的序列记作$a$，右儿子的序列记作$b$，ab之间的逆序对记作c，ba之间的逆序对记作d，aa之间的逆序对记作A，bb之间的逆序对记作B

那么当前序列的逆序对数量为
$$
v_x(f(ls)+f(rs))+\frac{x(x+1)}{2} c+\frac{x(x-1)}{2}(d+A+B)
$$
那么我们需要求出$c,d,A,B$

考虑对于每一个节点都维护一个权值线段树，记录每一种数的出现次数，区间内所有数的出现次数，以及出现次数前缀和的和，然后进行线段树合并，在过程维护A,B子树的前缀和

然后计算出c,d，A,B就是左右子树的线段树根节点维护的前缀和的和

# 坦克

## 题目大意

![20211116T4](D:\Blog\image\20211116T4.PNG)

## 算法讨论

首先可以列出一个$O(n^3)$的区间DP

设$dp(l,r)$表示区间$[l,r]$的答案
$$
dp(l,r)=\min\limits_{m=l}^r b_m+\max\{dp(l,m-1),dp(m+1,r)\} 
$$
然后直接对这个式子优化，只能用优先队列优化到$O(n^2)$

注意到最后的答案都比较小，理论上分析，最优的转移最多分成$\log n$层，每一层的代价最多是$9$，那么答案不会超过$9\log n$

那么考虑设$f_L(i,L)$表示花费$i$的代价，从$L$出发，右端点最多能够到达$f_L(i,L)$，相当于是固定左端点，对dp做前缀取$\max$，$f_R(i,R)$的定义也是同理

需要考虑两种转移

考虑更新$f_L(i,L)$的情况，枚举$j$作为分界点，讨论两边的花费大小关系

如果$[L,j-1]$的花费$<i-b_j$，那么$f_L(i,L)\leftarrow f_L(i-b_j,j+1)$

如果$[L,j-1]$的花费$= i-b_j$，那么$f_L(i,L)\leftarrow \max\limits_{k\leq i-b_j} f_L(k,j+1)$

由于$f_L(i,L)$关于$i$一定单调，那么$\max\limits_{k\leq i-b_j} f_L(k,j+1)=f_L(i-b_j,j+1)$

那么在枚举i的过程中，预处理出j的花费以及贡献，单调队列维护即可，做到$O(9n\log n)$

### Solution 2

考虑不进行填表操作，进行刷表操作，就是考虑$f_L(i,L)$可以转移到哪些位置

还是跟上面一样的转移，不过现在枚举的是$f_L(i-b_j,j+1)$（需要注意的时候这里需要求前缀max得到最大的可能右端点）

假设我们当前枚举的代价为i，记$pre_k=\min \limits_{j\leq  k} f_L(i,j)$

那么对于区间$(pre_{i-1},pre_i]$来说其最小可能左端点为$i$，那么就可以不用记录$f_R$的值，常数减小一半