# Cutting Tree [C. Cutting Tree — Grand Prix of Poland — competition #747 (yandex.ru)](https://official.contest.yandex.ru/opencupXVIII/contest/7896/problems/C/)

## 题目大意

给定一个n个点的树，对于每一个$k\in [1,n]$来说求出最多在这个树上，可以选出多少个联通的大小为k的子树，使得这些联通块两两不交
$$
n\leq 2\times 10^5
$$

## 算法讨论

首先对于一个固定的$k$来说，有一个比较显然的贪心，就是在dfs的过程中，维护两个值

$f(x),ans(x)$表示在x子树内包含x的联通块的大小，还有子树内的所有联通块个数

然后在递归到儿子的时候，将$f(u)$加到$f(x)$

最终如果$f(x)\geq k$，那么$f(x)=0,ans(x)+1$，这个过程就是将可以合并的子树贪心的合并到父亲上，一旦联通块大小超过k，那么相当于形成了一个完整的联通块

虽然过程中可能确定的联通块大小$\geq k$，可以通过删除叶子节点得到$=k$的联通块

### Solution 1

对于$k$的答案记作$F(k)$，那么显然有$F(k)\leq \frac{n}{k}$

而对于一个固定的k来说，我们可以$O(n)$的时间内得到答案，可以注意到当k比较大的时候存在若干段较长的段$F(k)$是相同的，如果段比较长，那么我们可以进行二分

那么设一个阈值$B$，对于$k\leq B$的暴力求出$F(k)$

然后对于$k>B$的，类似整除分块一样二分出段的边界

那么复杂度就是$O(nB+\frac{n^2\log n}{B})$

那么当$B=\sqrt {n\log n}$的时候，复杂度为$O(n\sqrt {n\log n})$

**其中二分边界的时候可以使用整体二分以减小长度，就是当二分的边界相等的时候，直接退出将k的区间内的$F(x)$设为这个数值**

**然后每一次取中间的位置暴力计算，求出两边的数值范围即可**

然后对于暴力计算的时候，需要预处理树的拓扑序，实现非递归计算

但是仍然难以在5s的时间内通过，实际结果大概在8-9s左右，不加整体二分的优化大概在20s左右

### Solution 2

上面都是对于求函数的过程上进行加速，已经没有什么优化空间了，那么需要从计算函数的过程中进行优化

根据上面的过程可以知道，如果$ans(x)$发生了变化，那么说明$x$的子树大小$sz(x)\geq k$，而对于$sz(x)<k$的节点一定有$f(x)=sz(x)$，那么事实上我们并不需要关这些$sz(x)<k$的节点

并且如果一个节点存在**两个儿子**的子树大小都是$\geq k$，那么这样的节点最多只有$\frac{n}{k}$个（**需要注意的是，不是所有子树大小$\geq k$的个数最多有$\frac{n}{k}$）**

由于$\sum \frac{n}{k}=n\log n$，那么在计算过程中如果可以保证复杂度之和$\frac{n}{k}$有关，那么最终复杂度就是polylog的

注意到不满足存在两个儿子……这个条件的节点是形成一条链的，在$f(x)$未更新的时候，在链上联通块是形成一个区间的，那么可以通过二分找到这个联通块的边界，而联通块数量最多为$\frac{n}{k}$

那么我们可以通过将所有节点的儿子按照子树大小排序，然后预处理后缀和，还有倍增数组，我们就可以在链上二分出联通块

那么一旦遇到一个节点$x$存在两个儿子满足条件，那么就需要停下，将当前节点形成的联通块大小加入到$f(x)$中，当前x的所有儿子都更新过x之后，以x为起点继续二分即可

那么可以将k从大到小枚举，同时维护$sz(x)\geq k$的节点形成树的叶子节点，这些叶子节点就是初始二分的起点

对于找到一个联通块的复杂度是$O(\log n)$

那么总复杂度$O(n\log ^2n)$

### Solution 3

考虑对原树进行轻重链剖分，**可以发现的是，我们二分的那条链就是一条树上的重链**（因为这条链上的所有节点只有一个儿子子树大小$\geq k$，显然这个子树就是最大的那个）

那么我们可以在每一条重链上处理答案，假设一条重链的链顶为x，那么如果这条重链存储了$O(sz(x))$的信息，最终总时间复杂度就是$O(n\log n)$，就是dsu on tree一样的复杂度

那么对于每一条重链上预处理对于每一个$\leq sz(x)$的节点数量所需的最低节点

那么我们可以直接利用重链上的信息即可

时间复杂度$O(n\log n)$

# Kucharz (kuc) [Kucharz (kuc) - Problemset - SZKOpuł (szkopul.edu.pl)](https://szkopul.edu.pl/problemset/problem/9NFtPM59qGWa7wdn570ifuP0/site/?key=statement)

## 题目大意

现在有n个物品，现在有E的能量，假设当前还剩下k个

- 拿走一个物品，代价为$jedno(x)$，能量+1
- 拿走两个物品，代价为$dwa(k)$，能量不变
- 拿走$\lfloor \frac{k}{2}\rfloor $个物品，代价为$polowa(k)$，能量-1

在过程中能量不能为负数

求最小代价
$$
n\leq 10^6
$$
**空间限制 8M**

## 算法讨论

显然第三个操作最多只会进行$\log n=20$次，那么如果$E\geq 20$那么一定是合法的，那么不妨让$E$与20取min

那么可以设$dp(i,j)$表示还剩下$i$个物品的时候，最终最小代价

转移很显然

其中第1，2操作，是可以将DP第一维状态滚动掉的

但是对于第3个操作无法这样操作

但是我们可以想象将所有n个位置分成最多$\log n$组，对于每一组来说其经过第3个操作变成的数都不是在当前组内的

那么我们在更新其中某一组DP状态的时候，只需要得到上一组的DP信息即可

而得到上一组的DP信息还是无法用数组记录下来的，那么当更新到当前组的DP时候，上一组的DP信息已经丢失了，那么需要重新计算

那么不断这样递归下去，直到某一个物品数量不能用第3种操作达成，显然递归的层数不会超过组数

事实上，我们并不需要将这个组包含哪些数求出，我们可以维护若干指针，每一个指针从n出发，我们一开始不断将第1个指针移动到1，然后我们需要的DP信息用第2个指针移动求出，不断递归下去即可

最终所有指针移动次数$O(n\log n)$

如果反过来做，时间复杂度就是$O(n\log n)$