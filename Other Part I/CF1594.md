# Rubik's Cube Coloring (hard version)

## 题目大意

给定一个深度为$k$的完全二叉树，i号节点的两个儿子编号为$2i,2i+1$，现在要求给所有节点染色，要求有边相邻的节点不能同色或者相对色，其中$(0,1),(2,3),(4,5)$相对

现在给出$n$个点强制被染色，求染色方案数
$$
n\leq 2000,k\leq 60
$$


## 算法讨论

首先当没有节点被强制染色的时候，设$dp(i,j)$表示深度为$i$的完全二叉树，其根节点的颜色为$j$的方案数，转移只要枚举$i-1$深度的两个儿子染的是什么颜色，是否不合法，然后进行转移即可

考虑现在树上存在强制染成某种颜色的节点，如果我们可以将这些节点的虚树建出来，那么就可以在虚树上做上面的DP

具体来说，不用真的建出虚树来，因为深度最多只有60，那么我们可以不用将两个点之间的点缩成一条边，我们直接dfs过程中将DP求出

首先如果当前节点的子树内不存在被强制染色的节点，假设当前深度为$k$，那么这个节点的DP值应该是$dp(k)$，否则向两个儿子进行dfs，然后将两个儿子的DP值合并，得到当前的DP值

这样的时间复杂度就是$O(6^2nk)$

具体实现上，会有一些差异

- 当判断当前节点$x$子树内是否存在强制染色的节点时，相当于是询问x在二进制表示下，是否存在一个强制染色节点的编号二进制，使得x的二进制是编号二进制的前缀（这里只从最高位1开始考虑），这个可以用字典树进行维护，**需要注意的是插入字典树的时候，是要从最高位1开始插入，而不是第k位开始插入**
- 由于位数只有60位，那么可以直接将每一个编号的所有可能前缀记录下来，然后查询的时候是很方便的，可以直接用unordered_map记录下来
- 可以把DP中的第二维变成0,1,2，将其中两个颜色变成了一个状态，比如原来颜色0,1是等价的，就是选了这个两个颜色中的一个，那么儿子节点就不能选这两个颜色了，**也就是说这两个颜色可以变成一个颜色，相邻的节点不能同色，并一个颜色中有两种方案**，那么就可以变成三个状态，这样写转移会方便很多，代码量少一点

第三种做法：[Bohun]([Submission #131245979 - Codeforces](https://codeforces.com/contest/1594/submission/131245979))

第二种做法：[SSRS_](https://codeforces.com/contest/1594/submission/131184174)，[Rubikun](https://codeforces.com/contest/1594/submission/131193265)

首先如果没有强制选颜色的节点的话，深度为k的树染色方案应该是$6 \times 4^{2^k-2}$，就是先选择根节点的颜色，那么儿子可以选择的颜色只有4种，这个是Rubikun的做法，而SSRS的做法是DP预处理的

至于记录所有的二进制前缀，SSRS是用map存所有前缀，然后Rubikun是存在数组里面然后二分查找，Rubikun的效率会高一点

在DP转移的时候，SSRS的DP是将所有6个颜色放到vector里面一起转移，当要更新当前节点的DP时候，先将左右儿子的DP数组计算得出，然后进行合并，并且合并的时候直接枚举左右儿子的颜色，而Rubikun是每一种颜色单独处理，将左右儿子的贡献单独算出，然后再乘起来，少了一个6的常数

第一种做法：[kefaa2](https://codeforces.com/contest/1594/submission/131189262)

# Ideal Farm

## 题目大意

现在有n个格子，s个球，将这些球任意放到这n个格子里面，要求所有格子非空，询问是否所有的方案中在n个格子中都存在一个子段使得球个数和等于k
$$
n,k,s\leq 10^{18}
$$

## 算法讨论

首先$k=s$，显然Yes

$k>s$或者$s<n$，显然No

### Solution 1

考虑$k\leq n$的情况，事实上我们可以构造这样的方案使得不存在一个子段=k

$1,1,1,1,1... k+1$，每$k$个为1段，前$k-1$个为1，最后一个位置为$k+1$，会发现这样一定不存在子段和为$k$

可能最后一段不完整，只需要填1就可以了，如果s比较大的话，显然可以在$k+1$的格子上继续放球

那么这样对$s$的限制为
$$
s\geq 2n-(n \bmod k)
$$
如果满足这个限制输出No，否则输出Yes

然后考虑$k> n$的情况，考虑一个子段的和等于$k$，由于$k>n$，那么显然这个子段中的至少存在一个元素$>1$，那么我们就可以将这个多出来的一个元素，放到除这个子段之外的位置上，显然这个子段不会是这个序列，所以一定可以成功

[tfg](https://codeforces.com/contest/1594/submission/131182184)

### Solution 2

考虑计算格子球数的前缀和$p_i$，显然这些前缀和都是在$[0,s]$的范围之内，并不存在两个前缀和的差为$k$，考虑以2k个元素进行分组，那么由于相邻两组内相对位置相同的不能同时存在，那么2k个位置里面最多只能选k个，然后考虑最后一组，由于考虑了0，那么需要将最后一组的数量+1（就是s这一定要选）与k取min，加到可以选的位置里面

根据**鸽笼原理**，如果所有可以选的位置$\leq n$（注意是等号，不是小于号，因为需要强制s要选上），一定会有选到不能选择的位置，那么存在一对前缀和之间的的差为k，那么输出Yes，否则是存在一组方案选择n个合法位置，使得两两之间的差都不为$k$，显然会选到No

[tourist](https://codeforces.com/contest/1594/submission/131173452)