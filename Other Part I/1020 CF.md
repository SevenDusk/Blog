# Yet Another Card Deck

## 题目大意

有 n张卡片从高到低叠放在桌子上，最上面的编号为 11，最下面的编号为 n。第 i张卡片的颜色为 a_i。

现在你需要执行 q 次操作，第 i 次操作对应的操作码为 t_i。需要执行三步操作：

- 找到最高的颜色为 t_i 的卡片（即编号最小的）
- 输出这张卡片当前编号
- 将其抽出来放到所有卡片的最上面（这一步后有些卡片的编号可能会发生改变）

$$
n\leq 2*10^5,a_i\leq 50
$$



## 算法讨论

首先会移动位置的卡片都是在对应颜色中第一个位置，那么说明在整个过程中会移动的位置只有50个

并且如果这50个都被移动过只会在前50张卡片中

那么直接从前往后暴力找出来位置，然后放到最前面即可，删除可直接删除，也可链表删除

时间复杂度$O(n\max a_i)$

 # Nearest vectors

## 题目大意

有n个点,每个点表示原点到该点的向量,让你求出两个向量最小的夹角,输出向量的序号

## 算法讨论

对所有向量极角排序，用象限+叉积进行判断

计算两个向量所成角可以用点乘除以两个向量的模长求出cos值

**这里需要注意不能直接浮点数比较，需要记录当且最小角的两个向量，然后将相除的形式改写为交叉相乘的形式，然后进行整数比较**

需要用__int128

# Igor In the Museum

## 题目大意

给定一个$n\times m$的地图，有k次查询。每次查询，询问位置（x,y）的'.'连通块周围有多少个'*'

## 算法讨论

首先记录每一个.是属于哪个联通块

直接对于每一个联通的.枚举周围可以得到的位置，如果为$*$，并且在这个联通块中没有被枚举到，然后将计数器+1

查询只需要查询.对应联通块周围的情况即可

# Chocolate Bar

## 题目大意

你有一块长方形的巧克力，这块巧克力共有n*m小块。你想吃k小块巧克力，因此你也许需要掰开这块巧克力。

在每一次操作中你可以把任意一块矩形形状的巧克力掰成两块矩形形状的巧克力。你只能沿着巧克力小块之间的分割线掰开巧克力——可以沿着水平方向或是竖直方向掰开。掰开巧克力的花费等于分割线长度的平方。

例如，如果你有一块$2*3$的巧克力，那么你可以沿着水平方向掰从而得到两块$1*3$的巧克力，这次操作的花费即为3^2=9。或者你也可以沿着竖直方向掰从而得到一块$2*1$的巧克力和一块$2*2$的巧克力，这次操作的花费即为2^2=4。

对于每一个给出的n，m和k，计算出最小花费。你可以用多块巧克力凑出k小块巧克力。剩余的巧克力可以不是完整的一块。

## 算法讨论

设$f(n,m,k)$表示一块$n\times m$的巧克力分成面积为$k$的巧克力最小代价
$$
f(n,m,k)=\min\{\min \limits_{i,j} f(i,m,j)+f(n-i,m,k-j),\min\limits_{i,j} f(n,i,j)+f(n,m-i,k-j)\}
$$
直接记忆化搜索即可

# Make Palindrome

## 题目大意

给出一个由小写字母组成的字符串 $s$。首先你可以改变 $s$ 中任意多个字母。然后你可以改变 $s$ 中各个字母的排列顺序。问如果要将 $s$ 变成回文串至少要改变多少个字母？（改变排列顺序不算改变字母）

## 算法讨论

首先考虑偶数的情况，可以发现字符串中出现次数为奇数的字母是有偶数个，那么需要将一些字母变化成其他字母，**那么操作数最小的情况不是只转化成一个字母，而是两两配对将其中一个字母转成另外一个字母**，那么字典序最小的情况就是首尾配对，保留前$\frac{k}{2}$个

然后考虑长度为奇数的情况，那么需要保留一个字母作为中间的，同样也是保留前$\frac{k}{2}$，那么相当于这个字母就是所有出现次数为奇数按排序后的中间那个字母，那么剩下的字母首尾对应

# Area of Two Circles' Intersection

## 题目大意

分别给出两个圆的圆心坐标和半径（(x1,y1),r1和(x2,y2),r2），求两个圆相交部分的面积。

## 算法讨论

首先判掉两个圆相离或者相包含的情况

然后相当于我们需要求一个弓形的面积，首先需要计算出两个圆心的距离，然后进而通过余弦定理求出弦心距以及角度，算出扇形的面积和三角形的面积，做差即可

需要注意精度问题，需要开long double

# Load Balancing

## 题目大意

![20211020T](D:\Blog\image\20211020T.PNG)

## 算法讨论

首先最终情况一定是有$sum\%n$个$\lfloor \frac{sum}{b}\rfloor+1 $，然后$n-sum\%n$个$\lfloor \frac{sum}{b}\rfloor$

那么显然就是将这个从小到大进行排列，然后将任务也从小到大进行排序，那么答案就是
$$
\frac{1}{2}\sum\limits_{i=1}^n |a_i-b_i|
$$

# Gadgets for dollars and pounds

## 题目大意

描述 一个人手上有s卢布，他要在n天内买m样东西中的k样. 有两种支付方式，每个物品有一种支付方式,要么用美元，要么用英镑。每天有不同的支付方式代价，即换取一美元或英镑，需要付出x[i]卢布的代价。 要求：最早完成买k样东西的天数。如果无法完成任务，输出-1 一种商品只能购买一次，但是一天可以买多种商品 输入 第1行：n, m, k, s 第2行：n个整数，表示多少卢布换一美元 第3行：n个整数，表示多少卢布换一英镑 接下来是m行，每行2个整数，表示每样东西用什么货币结账（1是美元，2是英镑），以及要多少那种外币 输出 输出最短到第几天买完k样商品

## 算法讨论

首先二分答案，然后进行check

首先将两种货币购买的物品分别进行排序，显然是从前往后进行购买

那么由于一天之内购买的物品不设上限，那么显然用同一种货币支付的物品是在mid天之前最小的$a_i$的那一天进行购买

那么可以处理出来最小兑换率和是哪一天，然后枚举每一种货币购买多少，判断需要的钱数是否小于等于拥有钱数即可

# Minimum spanning tree for each edge

## 题目大意

给定一张图，对于每一条边求出包含这条边的最小生成树

## 算法讨论

首先需要求出最小生成树，那么对于树上的边那么答案就是最小生成树的答案

然后考虑那些不在树上的边，相当于是与两个端点在树上路径边权的最大值进行替换

那么只需要对于最小生成树求出倍增数组即可

时间复杂度$O(n\log n)$

# Replace To Make Regular Bracket Sequence

## 题目大意

给定一个只含 `>`，`(`，`)`，`{`，`}`，`[`，`]`的字符串。记`<`，`(`，`{`，`[`为左括号，`>`，`)`，`}`，`]`为右括号。每次可以将任意一个左括号换为任意一个不同的左括号，或将任意一个右括号换为任意一个不同的右括号，记为一次操作。求使括号序合法的最小操作次数，若无解，输出 `impossible`。

## 算法讨论

首先用栈求出每一个括号匹配另外哪个括号，如果中间栈空并且新出现一个右括号那么一定不合法

最终栈不为空也是不合法的

那么考虑每一个括号匹配的那个，如果是一样的类型，就不需要进行操作了

否则就需要进行一次操作，那么答案就是类型不一样的括号对数

# The Union of k-Segments

## 题目大意

```cpp
给你 n 条线段，再给你一个整数 k。如果一个点至
少被 k 条线段覆盖，那么这个点是符合条件的，如果符合条件的点可以不间断的连起来组成
一条条的线段（注：线段中间是不能有断开的），并且要求符合条件的线段数越少越好。 （注：
只有一点也可以）。 换句话说就是让你将覆盖 k 次及 k 次以上所有的区间都找出来，如果两
个区间能够合并，那么输出他们合并的结果，例如：k=1,区间[0-3],[3-5]可以合并成[0-5]，但
是 k=1,区间[0-3][4-5]，是不能合并的，因为他们两个区间没有重叠部分。
```

## 算法讨论

首先注意到是所有点，而不是所有整点，那么我们就需要将小数位置的点也考虑进来

那么考虑将所有区间端点的坐标$\times 2$，然后对于一个区间对$l-1,l,r,r+1$进行离散化

然后就是差分，只需要求出有多少个连续$\geq k$的覆盖位置就是答案

构造方案就是连续段的两个端点/2，显然端点一定是原来区间的端点

### Solution 2

可以将区间拆分成两个后缀然后进行扫描线，同时维护当前扫描线的位置被多少个区间覆盖，如果遇到加上一个后缀的，那么k+1，如果当时为1的话，那么说明需要开始一段新的区间

如果遇到一个减去后缀的话，那么k-1，如果减完之后=0，那么说明当前区间结束

这样就避免了，要讨论小数位置的情况

https://codeforces.com/contest/609/submission/14881222

# Square Root of Permutation

## 题目大意

给定排列$p$，求一个排列$q$使得$q^2=p$

## 算法讨论

首先考虑q代表的有向图，那么可以发现进行两次映射，长度为奇数的环大小不变，然后顺序步长变成2，对于偶数的环来说，会分成两个环，分别为偶数位置和奇数位置的环

然后进行复原

那么$p$中长度为相同偶数的环个数一定是偶数，否则一定不合法

那么对于p中奇数的环只需要重新编号即可，对于偶数的环需要将两个长度相同的偶环进行合并，按顺序合并即可

# The Labyrinth

给你一张图，‘*’表示墙，‘.’表示空地，问每个'*'周围的联通快中‘.’的数量和 mod 10，属于同一个联通快的只计算一次。

## 算法讨论

还是求出所有的.联通块并且给联通块内部的点标上这个联通块的标号

那么对于$*$来说只需要将周围不同联通块大小加起来+1就是答案

# Longest k-Good Segment

## 题目大意

给定一个包含n个整数的序列a，$0\le a_i \le 10^6$ ，询问不重复数字个数$\le k$的最长区间的左右端点。如果有多解输出任意一组。

## 算法讨论

考虑单指针，显然随着区间右端点增加，左端点也是单调的

那么可以通过维护每一种颜色出现了多少次，来进行快速的单点删除插入

# Sum of Remainders

## 题目大意

$$
\sum\limits_{i=1}^n n\bmod i
$$

## 算法讨论

$$
\sum\limits_{i=1}^m n-\lfloor \frac{n}{i}\rfloor i\\
nm-\sum\limits_{i=1}^m \lfloor \frac{n}{i}\rfloor i
$$

那么可以直接整除分块，时间复杂度$O(\sqrt m)$

# Pearls in a Row

## 题目大意

现在有N个数，你的任务是将这N个数尽可能切割成多段。每一段必须包括两个相同的数。

## 算法讨论

首先从开头开始分割，一出现两个相同的数就分出新的一段

由于每一个位置都是要分在一个段中，那么显然这样的方案最优

# Professor GukiZ and Two Arrays

## 题目大意

给定两个序列$a,b$，要求交换最多两个位置，求$|s_a-s_b|$的最小值
$$
n,m\leq 2000
$$


## 算法讨论

首先可以先枚举只做一次交换的位置

然后考虑交换两次的情况，可以对于其中一个序列来说，我们只关心其选择交换的位置，假设$a$中两个位置的和为$x$，$b$中两个位置的和为$y$

那么$s_a'=s_a-(x-y),s_b'=s_b+(x-y)$，假设一开始的序列和$s_a>s_b$

那么$x-y=\frac{s_a-s_b}{2}$时候$s_a',s_b'$最接近

那么只需要用set维护其中一个序列的$y$，找到$x-\frac{s_a-s_b}{2}$前驱后继即可

# New Year Tree

## 题目大意

- 给出一棵n个节点的树，根节点为1。每个节点上有一种颜色$c_i$。m次操作。操作有两种：
  1. `1 u c`：将以 u 为根的子树上的所有节点的颜色改为 c。
  2. `2 u`：询问以 u 为根的子树上的所有节点的颜色数量。

## 算法讨论

首先将这棵树的dfs序求出，然后相当于就变成了序列上的问题

由于颜色数量不多，我们可以用线段树维护区间内每一种颜色是否出现过，可以状压用long long存下

那么线段树需要支持区间赋值和区间或

# Ants in Leaves

## 题目大意

给定一棵 n 个节点的树，根节点是 1。这棵树的每一个叶节点都有一只小蚂蚁。每过 1 秒钟，可以选择让一些蚂蚁向父节点走一步。注意，两只蚂蚁不能同时在一个除去根节点的节点上。

问这些蚂蚁最少用多少秒的时间，使得所有蚂蚁都走到根节点。

## 算法讨论

首先对于每一个1的儿子子树单独进行考虑，显然答案为这些子树需要最少时间的max

考虑同一个深度的叶子节点，其必然可以在一个连续的时间段中到达根节点（这个时间段每一个时刻都有恰好一只蚂蚁走到根节点）

如果不考虑其他深度的蚂蚁，那么如果深度为$k$的有$cnt$只蚂蚁，这个时间段为$[k,k+cnt-1]$

显然每一个深度的时间段是不交的，那么我们从小到大考虑这个深度，然后维护一个最终时间t，一段的开头时间为$\max(t+1,de_i)$

# Optimal Number Permutation

## 题目大意

求一个序列，有n种数，每一种数只出现2次，两个出现位置的距离为$d_i$，要求构造一个序列最小化
$$
\sum\limits_{i=1}^n (n-i)|d_i+i-n|
$$

## 算法讨论

首先最小值为0，即$d_1=n,d_2=n-i,...,d_{n-1}=1$，然后$d_n$任意

那么可以将奇数排在前n个位置，然后偶数排在后面的位置，最终剩余的两个位置用n填充

类似1 3 5 .... 5 3 1 2 4 6... 6 4 2 n

# Bear and String Distance

## 题目大意

Limak是一只小北极熊。他喜欢单词——只由小写字母构成，长度为n的单词。

他规定dist(s,s')的值为s与s'在26个字母中的间距。如，dist(c,e)=dist(e,c)=2,dist(a,z)=dist(z,a)=25。

而且，当dist两个单词时，其值为dist第一个字母+dist第二个字母+…… 如，dist(af,db)=dist(a,d)+dist(f,b)=3+4=7,dist(bear,roar)=16+10+0+0=26。

现在，Limak给你一个字母或单词s和值k，令你寻找一个s'使dist(s,s')=k。输出s'。如果没有合适的s'，输出-1。

## 算法讨论

使前面的字母尽可能差距大，如果k减到0，那么就相同

# Magic Numbers

## 题目大意

1. $l≤x≤r$
2. x 的偶数位是 d，奇数位不是 d。 （这里定义偶数位为从高位往低位的数的偶数位）
3. m|x

### 算法讨论

考虑数位DP，设$f(x,y,0/1)$表示当前填到第x位数，当前数模m等于y，当前为奇数位数还是偶数位数

然后同时还需要记录当前是否顶格还是是否有前导0

然后得到当前位最大能填到多少数字，**枚举需要注意的如果当前从前导0变成不为0的数字，当前算是奇数位不能填d**

# Zbazi in Zeydabad

## 题目大意

给定一个$n\times m$的矩阵, 每个格点为'.'或'z'。

我们称一个子矩阵合法, 当且仅当这个矩阵为正方形, 且该矩阵的第一行和最后一行元素全部为'z', 从右上到左下的对角线上元素全部为'z', 其余位置元素随意。注意, 一个1×1的内容为'z'的矩阵是合法的。

## 算法讨论

首先枚举一个斜线，那么相当于z的两个右上左下端点都是在斜线的一个区间

考虑枚举其中一个端点，首先可以预处理出来最多向上延伸多长的距离，就是斜线上的连续z段，还有这个端点右边的连续z段的长度min

然后对于一个合法的右上端点，其向左延伸的距离至少为两个端点的列数差，那么可以用扫描线进行维护

# The Smallest String Concatenation

## 题目大意

给定n个字符串，要将这些字符串拼接起来，求能得到的最小字符串

## 算法讨论

首先定义比较函数为$cmp(a,b)=(a+b<b+a)$，可以发现这个形成了一个偏序集

直接按照这个排序即可

# Longest Subsequence

## 题目大意

给出n个数，要求选出尽可能多的数，满足它们的最小公倍数不大于m。允许数列里没数，此时这个数列的最小公倍数为1。

## 算法讨论

可以枚举其LCM，然后求出序列中为其因子的有多少个，取其中最大的数，如果有相同的情况，那么取最小的

显然这样就得到的最大可能LCM

至于求因子可以在调和级数的时间内完成

# Thief in a Shop

## 题目大意

有一个小偷进入了一个商店。

像平常一样，他把他的幸运背包带在身上，他的背包里能放 k 个东西。商店里有 n 种产品，每种产品都有无限多个。对于每个第 i 种产品，它的价值是 a[i] 。

小偷很贪婪，所以他会准确地拿 k 个产品（他有可能把某一种产品拿很多个）。

你需要找出所有小偷可能偷走的物品价值之和。

## Solution 2

首先每一种物品的代价都是最多只有10位，可以拆成两端进行考虑，相当于根号分治

设$f(i,j)$表示当前得到的数最低5位为$i$，通过加上$a$中一个数得到最高位为$j$的后五位情况，这个需要32位状压

然后bfs所有出$\sum a_i$范围内每一个数被得到的最小+操作次数，如果+操作次数>k，那么说明无法达到

bfs过程中枚举最高位变化情况$h\rightarrow h+i,i<2^5$，然后求出对应的所有低位情况，这里需要记忆化，如果当前高位的已经考虑过一些情况，那么就不需要再考虑了

那么这样的时间复杂度$O(n^2\log^2 n+n\sqrt n)$

[Submission #38390716 - Codeforces](https://codeforces.com/contest/632/submission/38390716)

## 算法讨论

假设一个多项式$f$，一个指数为一个随机数当序列a中出现了这个数，否则为0

那么答案就是$f^k$直接DFT即可

# Foe Pairs

## 题目大意

给定一个1到n数字组成的全排列，同时给定m元素$(a_i,b_i)$。 你的任务是统计有多少个不同的区间(x,y)($1 \le x \le y \le n$)，这些区间不包含任意一个给定的元素对，即不能同时含有元素对$(a_i,b_i)$的两个元素，这两个元素的先后顺序不限定。

## 算法讨论

当固定左端点的时候，合法的右端点显然是一段区间

那么只需要将所有二元组按照最左边的那个位置进行排序，从后往前进行扫描，那么可以发现这段区间就是最优左端点在这个位置右边最小的二元组右端点

取后缀MIN即可

# Nested Segments

## 题目大意

给定n个区间，求每一个区间包含了其他多少个区间

## 算法讨论

首先离散化，然后按照区间左端点排序，从后往前枚举，利用树状数组维护区间右端点，查询就是有小于当前去加右端点的右端点有多少个

# Pursuit For Artifacts

## 题目大意

- 给定一张 n 个点 m 条边的简单无向连通图，边有边权，边权要么为 0，要么为 1。
- 每条边只能通过一次（两个方向加起来只能通过一次）。
- 求是否存在一条从 a 到 b 的路径，满足路径上至少存在一条权为 1 的边。

## 算法讨论

首先边双连通分量缩点，那么可以得到一颗树，对于一个联通分量中存在1边的，将这个点设为1，那么相当于就是查询a所有联通分量与b所在连通分量直接是否存在1的边或者1的点

直接dfs即可

