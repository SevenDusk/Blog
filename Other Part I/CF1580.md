# B.Mathematics Curriculum

## 题目大意

给定$n,m,k$，要求求出有多少个长度为$n$的排列，满足以下条件

我们称一个元素是好的，当且仅当包含这个元素的所有子段不同的max个数等于$m$，要求这个排列中有$k$个元素是好的
$$
n,m,k\leq 100
$$

## 算法讨论

首先观察到对于包含有x子段max的数量，相当于从$x$出发，向前向后进行求前缀后缀不同max的数量，相当于可以用单调栈进行维护，往某一个方向找最近大于当前数的位置，不难想到笛卡尔树

求右边第一个大于当前数是在笛卡尔树上找到第一个向右走的祖先，向左边走相当于在笛卡尔树上找到第一个向左走的祖先

对于对一个$x$，包含$x$的子段不同max数量等于在笛卡尔树上深度（根节点深度为1）

那么问题转化为，求出有多少个排列的笛卡尔树深度为$m$的节点有$k$个

考虑设$dp(i,j,k)$表示当前考虑到深度为$i$的节点，子树内有$j$个点，其中深度为$m$的点数为$k$
$$
dp(i,j,k)\times dp(i,p,q)\times \binom{j+p}{j}\rightarrow dp(i+1,j+p+1,k+q+[i+1=m])
$$
$dp(i,1,[i=m])=1$

直接转移复杂度$O(n^5)$，看上去有点危险，但是仔细分析一下常数
$$
\sum\limits_{i=0}^n \sum\limits_{j=0}^i \sum\limits_{p=0}^{n-i}p
$$
常数大概只有$\frac{1}{12}$

然后有以下几个剪枝

- 当固定$i,j$时用vector存下来$dp(i,j,k)\neq 0$的$k$，非常有用，单独使用就可以稳定在$200ms$左右
- 有$k$个叶子节点的树，至少需要有$2k-1$个节点，如果$n$超出这个范围，那么直接返回
- 当总深度比较小的时候，j会小于$2^i-1$（如果使用第一个剪枝，这个剪枝是无用的）

第一个剪枝：[Karry5307_AK_NOI2021](https://codeforces.com/contest/1580/submission/130363173)

第二个剪枝：[Farhod_Farmon](https://codeforces.com/contest/1580/submission/130367468)

# C.Train Maintenance

## 题目大意

现在有n列火车由一个二元组进行表示$(x_i,y_i)$，表示从加入时间开始$x_i$时间运行，$y_i$时间休息，现在有$m$天，每一天会加入或者删除某一个火车，要求每一天休息的火车数量

## 算法讨论

像这种分段的题目往往是可以进行根号分治的

首先我们记$s_i=x_i+y_i$，那么相当于从加入的那天起，将m天每$s$天划分成一段，对于这$s$天的后面$y$，需要加上$1$

- 如果$s\leq \sqrt m$，那么本质不同的天数只有$s$个，那么可以用一个桶$t_{s,i}$记录天数模$s$下等于$i$的休息个数，当加入的时候直接暴力修改桶中的内容

- 如果$s>\sqrt m$的时候，会发现分出来的段最多只有$\sqrt m$段，并且段内需要修改的位置是一段区间，我们可以维护一个差分数组，在当前天之间都已经求出前缀和，后面的还是差分，需要注意的是删除操作要从加入的时间进行修改

时间复杂度就是$O(m\sqrt m)$

一开始的时候用了树状数组进行区间修改，像这种就是可以差分解决的，复杂度$O(m\sqrt {m\log m})$浪费了一些时间

Bestcode:[medium_waxberry]([Submission #130347074 - Codeforces](https://codeforces.com/contest/1580/submission/130347074))

# D.Subsequence

## 题目大意

给定长度为$n$的序列$a$，要求求出一个长度为$m$的子序列，$b_1<b_2<...<b_m$，最大化
$$
\sum\limits_{i=1}^m (m\times a_{b_i})-\sum\limits_{i=1}^m \sum\limits_{j=1}^m f(\min(b_i,b_j),\max(b_i,b_j))
$$
其中$f(i,j)=\min(a_i,a_{i+1},...,a_j)$
$$
m\leq n\leq 4000
$$

## 算法讨论

~~绕来绕去还是需要绕到笛卡尔树上~~

首先会发现如果直接在序列上进行DP，转移一次是需要记录之前所有选的位置，主要就是后面这个式子导致

后面这个式子就是区间取$\min$，我当时想如果在后面增加一个元素，那么需要预处理出来前面比其小最大位置在哪里，那么不妨建一个笛卡尔树出来，事实上一段区间的$\min$，就是区间左右端点$l,r$在笛卡尔树上LCA的数值

那么如果我们知道LCA，那么看起来就好办了很多，那么我们先枚举LCA在那个节点上，左右子树组合起来的贡献就是在当前枚举的节点上，并且只和左右子树内选择点的数量有关

可以设$dp(i,j)$表示$i$子树内选择了$j$个节点的最大贡献
$$
dp(x,i)+dp(u,j)-2ij\times a_x\rightarrow dp'(x,i+j)
$$
最开始$dp(x,0)=0,dp(x,1)=(m-1)a_x$

建出笛卡尔树相当于是给序列重新进行一种特殊的“排序”，使得从具体位置有关变为与数量有关的转移

具体实现的时候，可以不用将笛卡尔树显式的建出，可以分治进行，具体实现参见[medium_waxberry](https://codeforces.com/contest/1580/submission/130353694)的代码

