# H.Higher Order Functions

## 题目大意

定义一个算式$f(T)$

- ()为单位算式$f('()')=0$
- $f((T))=f(T)$
- $f(T_1\rightarrow T_2)=\max(f(T_1)+1,f(T_2))$

其中第三个算符是右结合的

## 算法讨论

是类似表达式求值的，首先给所有的$\rightarrow $运算符标一个优先级，在计算区间$[l,r]$的算式的时候，需要先找出最低优先级的运算符最靠左的位置$pos$，返回$[l,pos-1]+1,[pos+1,r]$答案的最大值

如果当前区间不存在运算符直接返回0

求最小优先级可以用st表求出

时间复杂度$O(|S|\log |S|)$

# K.Kingdom of Islands

## 题目大意

给定$n$个点，每一个点都属于一个集合，每一个集合内至少有一个点，集合内部没有边，对于两个不属于同一个集合的点之间一定有一条边

现在有$k$条特殊边，如果这条边连接的是同一个集合内的点，那么就在这两个点之间连边，否则就删除这两个点之间的边
$$
n\leq 10^5,k\leq 20
$$

## 算法讨论

首先只考虑这$k$条边涉及到的$O(k)$个集合，对于没有被设计到的集合，集合内最多只能贡献1个点，对于这$O(k)$个集合内，一个集合内没有涉及到的点可以缩成1个点

假设集合内部的特殊边有$a$条，集合之间的特殊边有$b$条

先$2^a$枚举，集合内边的选择情况，如果一条边选了，那么将两端的点加入点集内，加入完后，再判断这个点集$S$是否合法

然后对于特殊边的关系有三种状态，两端端点都不选，只选择一侧端点，那$3^b$次方枚举是不可以接受的，那么可以考虑强制其中一个点不选，另外一个点任意的情况，那么只需要$2^b$枚举

如果存在$x\in S$，$x$被强制不选了，那么当前枚举的就是不合法，考虑剩下那些没有S内点的集合，如果其中不是所有点都被强制不选了，那么可以找一个点加入到$S$中

求出最大的$S$即可

时间复杂度$O(k2^k)$



一开始没有想到可以将$3^b$次方枚举，转化为$2^b$枚举，就写了搜索，结果TLE，导致了浪费了很多时间

还有最初的时候，认为转化为$O(k)$80个点的时候，直接用Bron–Kerbosch算法求最大团，结果也是TLE

# M.The Mind

## 题目大意

现在有一个合作游戏，游戏有两个玩家，每一个人手上都有5张牌，游戏的目标是在所有牌之前打出最小的牌，游戏进行5轮，每一轮两个玩家可以选择跳过，或者打出最小的牌，同一轮是玩家的操作是同时进行的

现在给出n种情况，要求给出一个概率分布$p_i$，表示在i轮打出最小牌的概率，求出按照给出的概率分布，对于所有的游戏，平均获胜概率为$85\%$

## 算法讨论

首先如果将最小值出现在统一位的分成一组，总共分成5组，对于最小值在第i位上的组，让第i轮打出的概率为1，那么如果两个人的牌在不同组的话，获胜的概率为$100\%$，如果在同一组的获胜概率为$0\%$

按照这样的策略，总的获胜概率为$82\%$，其实到这里离正解就差了一点点

然后我们开始了爬山调整方案，大概用3个多小时，只将概率提高为$82.9\%$，**然后才注意到可以在这5轮不讲牌打出**

那么相当于是分成6组，前5组跟之前的叙述一样，最后一组不在5轮中打出牌，这样获胜的概率为$86\%$

# E. Easy Scheduling

## 题目大意

给定高度为$h$的满二叉树，每一次任务是可以进行$p$个，现在最开始任务在根节点，完成一个任务会传递给儿子求出最小进行次数
$$
h\leq 50
$$

## 算法讨论

首先记$k=\log_2 p$，如果$k\geq n$，那么每一层任务都可以一次解决输出$n$

否则就处理出来第一次不能完整的删除一层的时间也就是k，求出剩下的节点数量$rem$

答案就是$k+\lceil \frac{rem}{p}\rceil +1$

# L.Labyrinth

## 算法讨论

从后往前考虑这个问题，在某一个时刻，所有节点都会被划分成若干即可

对于每一个集合来说，都可以得到当前的宽度和最大起始宽度，如果对于一个集合来说，其节点上的糖果都被吃掉了，那么可以吃掉剩下没有吃掉的糖果

将边按照下降序列进行排序，如果一条边的两个端点是在同一个集合中的，那么就可以忽略这条边

否则我们将可以将这两个集合合并得到一个新的集合