# CF416D Population Size

## 题目大意

给定一个序列,-1可以被替换成任意正整数,求该序列最少可以被分成多少个等差数列.(分成的是子串而不是子序列)

## 算法讨论

首先需要考虑一段区间是否可以形成一个等差数列

首先如果这个区间内只存在一个或者零个不是-1的元素，那么一定是可以的，只要将公差设为0即可

接下来考虑区间内存在两个以及以上不为-1的元素情况，首先我们可以选取其中**下标最小**的两个相邻的不为-1的元素，计算其公差（就是数值差除以下标之差），如果公差为小数那么不合法，否则**依次枚举**后面不为-1的元素，**同时记录上一个不为-1的元素坐标**，每增加一个不为-1的元素，需要判断一下加入的元素是否满足公差，如果不满足说明这个区间就不能形成一个等差数列

**由于题目中要求只能填正整数，那么就需要判断一下序列的两端元素按照公差计算出来，如果$<0$，也是不合法的**

由于是依次枚举的，那么说明判断一个区间是否合法可以支持快速加入后面一个元素

由于题目中要求划分成最小段，那么可以维护一个指针，并且动态维护当前的区间，指针不断向后移动，如果出现了上面叙述不合法情况，那么就将这段区间分成一段，然后将指针指向下一个位置，进行考虑

显然这样划分在可能的情况最大化了每一段的长度，那么就是最优的，当然也可以进行DP用单调队列优化

[Teapot](https://codeforces.com/contest/416/submission/6533909)

# HDU 2487 Ugly Windows

## 题目大意

给一个n*m（1 <= n, m <= 100)的矩阵表示电脑屏幕，类似于我们电脑打开多个网页，找出最顶层的页面。矩阵由‘.’（非边框区域）和‘A’—‘Z’（打开窗口的边框）组成，边框的大写字母只出现一次；边框形状为矩形，相互之间只有覆盖和不覆盖的关系。输入保证：
1、至少有一个窗口；
2、**窗口长和宽都不小于3；**
3、没有边框在矩阵外面
输出顶端窗口（即没有任何部分被其他窗口覆盖）的大写字母。

## 算法讨论

首先枚举每一种字母，求出这个字母格子的最左上角和最右下角的格子，如果不存在这个字母的格子，显然这个字母不是答案

然后得到这两个格子相当于就是确定了整个矩形，那么首先需要枚举矩形的边界，如果其中存在一个格子不是当前枚举的字母，那么显然整个窗口是被其他窗口覆盖的

**然后需要检查内部是否都是"."，以保证没有窗口在其内部然后覆盖了当前窗口**

**由于题目需要满足第二条性质，那么还需要检查当前矩阵的边长是否都是$\geq 3$**的

# TheTicketsDivTwo

## 题目大意

现在有$n$个人排成一列，然后进行$k$轮选择，每一轮选择会随机生成一个$[1,6]$的整数，然后如果这个数为4，那么选择第一个人，结束这个过程，如果这个数为奇数那么将第一个人移到最后一个位置，如果为偶数，那么删除第一个人，如果序列中只有一个人或者k轮之后没有选出结果，就直接选择第一个人

求序列中第$m$个人被选中的概率

## 算法讨论

会发现所有人的相对位置关系是不变的，那么如果我们确定剩下给定一个序列,-1可以被替换成任意正整数,求该序列最少可以被分成多少个等差数列.(分成的是子串而不是子序列)的集合以及第一个人的编号，那么就可以确定这个序列

那么设$dp(i,j,mask)$表示进行了$i$轮之后，第一个位置的人为$j$，剩下人的集合为$mask$的概率

记$nxt$表示mask中j之后那个人的编号

如果$j=m$，那么对答案有$\frac{1}{6}dp(i,j,mask)$的贡献

如果$mask=\{j\}$，那么对答案有$dp(i,j,mask)$的贡献

否则有转移
$$
\frac{1}{2}dp(i,j,mask)\rightarrow dp(i+1,nxt,mask)\\
\frac{1}{3}dp(i,j,mask)\rightarrow dp(i+1,nxt,mask\backslash\{i\})
$$
最终贡献有$\sum\limits_{m\in mask} dp(k+1,m,mask)$

# RectangleArea

## 算法讨论

现在给定两个数组$X,Y$，元素个数分别为$N+1,M+1$，满足$0 = X[0] < X[1] < ... < X[N] = W , 0 = Y[0] < Y[1] < ... < Y[M] = H$

现在可以询问一个二元组$(i,j)$，计算$(X_{i+1}-X_i)(Y_{j+1}-Y_j)$

给出一些已经询问过的二元组，求最少还需要询问多少二元组，使得可以求出$H\times W$的值

## 算法讨论

考虑将$X,Y$差分得到长度

首先考虑将这个$(i,j)$写成矩形的形式，那么这个矩形大小为$N\times M$

那么如果同一列中存在两个位置$(a,x),(b,x)$已经被询问过了，那么可以通过面积的比例求出$X_a,X_b$之间的比例，那么我们需要求出所有位置关系的比例，那么如果将$a,b$之间连一条边，那么说明$1...N$代表的点是联通的，那么就可以计算出整体的比例

如果我们已经得到$X$各个元素之间的比例，那么只要每一列上都存在一个元素，就可以得到所有列的比例，而我们可以通过X之间的比例求出某一列的面积，那么就可以算出总面积了

那么就需要计算给出询问行标号的联通块数量，以及一列上没有元素的列数，两者之和-1就是答案

需要将行列反转再计算一次

# Algrid

## 算法讨论

给出程序的输出结果，构造字典序最小的可能输入数据

```
For i = 0 to H-2:
    For j = 0 to W-2:
        //Get the current colors of cells (i,j) and (i,j+1)
        A = Color(i,j) , B = Color(i,j+1)

        If (A,B) == (White, White) Then:
             Do nothing.
        EndIf
        If (A,B) == (Black, White) Then: 
             Repaint cells (i+1,j) and (i+1,j+1) Black.
        EndIf
        If (A,B) == (White, Black) Then:
             Repaint cells (i+1,j) and (i+1,j+1) White.
        EndIf
        if (A,B) == (Black, Black) Then:
             Swap the colors in cells (i+1,j) and (i+1,j+1).
        EndIf
    EndFor
EndFor
```

$$
n,m\leq 16
$$

## 算法讨论

首先第一行的字符串是不会改变的，然后考虑后面的字符串

首先输出数据的前一行就是可以得到后面一行的结果

只需要$2^m$枚举所有可能性，然后取其中最小的结果即可

# KingdomXCitiesandVillagesAnother

## 题目大意

现在有$n$个城市，$m$个农村，给出坐标，现在需要使得所有农村与一个城市联通，连接两个地方的代价为其坐标的欧几里得距离，求最小代价

## 算法讨论

类似prim求最小生成树的方法

每一轮求出还没有连接城市的农村离所有城市最小值的最小农村，然后连接，删除这个农村，加入到城市中，进行m轮即可

# TheCowDivTwo

## 题目大意

在$[0,n-1]$中选出$k$个数，使得其和为$n$的倍数
$$
n\leq 1000,k\leq47
$$

## 算法讨论

设$dp(i,j,k)$表示考虑到前i个数，选出的数个数为j，选出数的和模n为k的方案数
$$
dp(i,j,k)=dp(i-1,j,k)+dp(i-1,j-1,(k-i)\bmod n)
$$
直接转移即可

时间复杂度$O(n^2k)$

# FoxAverageSequence

## 题目大意

称一个序列为好的，当且仅当

- Each element of the sequence is an integer between 0 and 40, inclusive.
- Each element of the sequence is less than or equal to the arithmetic mean of the previous elements. That is, for each i, 1 <= i < N, we have A[i] <= (A[0] + A[1] + ... + A[i-1]) / i.
- There are no three consecutive elements in the sequence that follow in strictly decreasing order. In other words, there must be no index i, 0 <= i < N-2, such that A[i] > A[i+1] > A[i+2].

现在给出一个数组，里面元素范围为$[-1,40]$，如果某一个位置上为-1，那么可以将这个位置变成任意一个$[0,40]$的数，求变成好序列的方案数
$$
n\leq 40
$$

## 算法讨论

对于第二个条件，我们只需要记录前面元素的和就可以了，至于第三个条件，只需要记录之前一位的元素，以及之前一位与之前两位是否符合$A[i]>A[i+1]$的条件

设$dp(i,j,k,0/1)$表示考虑到序列中第$i$个位置，前缀和为$j$，最后一个位置为$k$，前面是否递减0/1的方案数

转移就是枚举这一位填哪个数，判断是否符合条件即可

时间复杂度$O(n^5)$

# GeometricProgressions

## 题目大意

求$\{b_1p_1^i | i\in [0,n_1)\}\cup \{b_2p_2^i|i\in [0,n_2)\}$
$$
b_1,b_2,p_1,p_2\leq 5*10^8,n_1,n_2\leq 10^6
$$

## 算法讨论

直接对$b_1p_1^i$，进行大质数取模hash，然后用map去重

**注意模数需要$>5*10^8$，否则会冲突，一开始选了$3*10^8$左右的模数，结果WA了**

# SlimeXResidentSlime

## 题目大意

给定$n\times m$的网格，网格上有如下四种格子

- '.' : an empty cell.
- '#' : a wall.
- '$' : an empty cell where you initially reside.
- '1'-'9' : a stationary undead slime whose regenerative power is equal to the digit representing it.

您正在玩一款名为《Resident Slime》的游戏。你将扮演英雄的角色，消灭不死史莱姆。 您处于由 String[] 字段中给出的 RxC 矩形单元格网格表示的级别。行从上到下编号为 0 到 R-1，列从左到右编号为 0 到 C-1。 field[r][c] 表示位于第 r 行和第 c 列的单元格的内容，并且是以下之一： '.' : 一个空单元格。 ＃' ： 一堵墙。 \$ ：您最初居住的空单元格。 '1'-'9'：静止的不死史莱姆，其再生能力等于代表它的数字。 你将消灭这个关卡中的所有史莱姆。不幸的是，在每个史莱姆被杀死后，它只会在有限的时间内保持死亡状态，然后才能复活。你的目标是让关卡进入每个史莱姆都死的状态。到那时，他们将不再复活。更具体地说，游戏的工作原理如下。 您从用\$表示的单元格开始。 在每一回合开始时，您要么等待，要么移动到四个相邻的单元格之一（与您当前位置共享一侧的单元格）。您不能移动到包含墙的单元格。 接下来，如果您的新位置有死史莱姆，它会复活。 接下来，如果您的新位置被不死史莱姆占据，则该史莱姆会被杀死。被杀死的史莱姆会留在细胞中。 接下来，如果每个史莱姆的再生能力等于它上次被杀死前的回合数，它就会复活。 最后，如果此时所有不死史莱姆都被杀死，您就赢得了关卡。否则，转牌前进，游戏继续。 赢得此关卡所需的最少回合数是多少？如果不可能，则返回 -1。 

## 算法讨论

首先当杀死第一个怪兽的时刻开始，最多只能再走9步，否则第一个怪兽就会复活

那么我们就可以枚举这9步是往哪个方向走的，枚举量$4^9$

然后枚举从哪个怪兽开始，需要预处理起点到这个怪兽的最短路

时间复杂度$O(nm+4^{9})$

