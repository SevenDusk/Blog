1.进制转换

2.一条链即可

3.模拟过程

4.2006 **Frances Allen** 2008 **Barbara Liskov** 2012 **Shafi Goldwasser**

5.稳定排序：归并，插入，时间复杂度$O(n\log n),O(n^2)$

6.根据dileworth定理，定义$A<B$为$A,B$之间不相交

那么这个问题就是求最小链覆盖，那么等价于求最长反链，那么就相当于求出最大的集合$S$

$\forall i,j\in S,i\neq j$，$i$与$j$不相交

相当于求出在数轴上最大的被覆盖次数，只要离散化差分就可以了求出一个点最多覆盖多少次 6 被覆盖5次

7.光盘驱动器不是存储设备

8.姚期智 2000年获奖

9.计算机之父，人工智能之父：图灵

10.$\binom{24-3*2+2}{2}=190$，先让每一个人拿走2个，然后就是经典的放球问题，球同盒不同，插板法

11.$2^{15}-1=32767$

12.$\binom{10-7+6}{6}=84$，同样还是插板法

13.

## 题目大意

给定$n$位bit，一开始全为$1$，现在有两种操作，目标要把这$n$位bit全变成$0$

- 翻转第n位
- 如果bit最后z位都是0，那么翻转z+2位

### A.对于没有重复进行一个操作的序列来说，只存在唯一的操作序列使得达成目标

### B.描述解决这个问题的算法

### C.达成目标需要多少步操作

A.如果将每一种bit看作一个节点，连向可以通过操作得到的bit，那么起始点和目标点都是在同一条链上

B.根据A的结论可以知道，最终的操作序列肯定是第1个操作和第2个操作交替出现的，那么直接模拟这个过程就可以了

C.可以发现n为奇数的时候才存在解

设$f(n)$表示$n$位bit时候需要多少次操作才能完成

首先我们可以将后$n-2$位bit都变为$0$，操作数$f(n-2)$

然后用一次第二次操作使得变成$010000...00$，接下来就是把这个$1$不断后移

首先需要将$n-2$继续变回1，然后在$n-2$的链上往另一个方向走，直到变成$011000..00$，然后再进行一次第二次操作，变成一个规模更小的子问题，这里进行操作需要$2^{n-2}$次操作
$$
f(n)=f(n-2)+1+\sum\limits_{i=0}^{n-2}2^i=f(n-2)+2^{n-1}
$$
其中$f(1)=1$
$$
f(n)=\sum\limits_{i=0}^{\frac{n-1}{2}}4^{i}=\frac{4^{\frac{n+1}{2}}-1}{3}
$$

14.主定理$\log_24=2 $，复杂度带log，$O(n^2\log n)$

15.$D(n)=\sum\limits_{d|n,d>1} D(\frac{n}{d})$，按照这个计算即可

完善程序 1

判断 1.构造全0序列，输出为0

2.程序23行使得后缀0不会对nowm产生影响

选择 1.最后一位为100，其他都为0

2.每一位都是10，计算得出最小为11

3.由于每一次hastime都会减1，由于m=1，只能在最初进行一次操作，会衰减n次，那么答案就是$n+\sum\limits_{i=0}^{n-1}init_i$

4.如果$m\geq \sum init_i$，那么每一次只减1 ，m都是足够的，那么hastime就是n-后缀0的数量

完善程序 2

判断1.显然会执行，可以构造一组无解数据

2.由于2n一定是偶数，那么出现次数为奇数的一定只有偶数个

3.由于10行，需要vector ans 的大小大于等于n才会返回true值，dfs函数中没有其他地方可以产生true值，并且一旦产生true值就会结束这个dfs，那么说明如果有解，那么ans大小=n

4.显然会改变结果

选择题

1.如果不约分，显然分母为49，约分之后一定是49的因数，只有B选项符合答案

2.构造a={0,0,0,0,0,0,0,0,0},b={1,1,1,1,1,1,1,1,1}

完善程序 3

dp[0]求得是从左上角出发走到$(i,j)$ 的最短路径最大权值和

dp[1]求得是从左下角出发走到$(i,j)$ 的最短路径最大权值和

dp[2]求得是从右下角出发走到$(i,j)$ 的最短路径最大权值和

dp[3]求得是从右上角出发走到$(i,j)$ 的最短路径最大权值和

判断题1.由于1<n-1,1<m-1，显然$n,m\geq 3$

2.对的，$(i,j)$这个地方的权值不会被统计到答案中去

3.$dp[0,0,i]=\sum_{j=0}^{i}a[0][j]$

4.错误，画图就知道，$(i,j)$一定在第2行中，缺少了第2行的贡献

选择题

1.四个区域中三个区域都放全0，然后在剩下那个区域放置数值相同的数（需要至少有2条路径）

2.$x-1+y+n-1-x-1+m-1-y+y-1+n-1-x+x+m-1-y-1$

=36

完善程序 1

通过模拟一下过程，可以发现，下一个图形是上一个图形顺时针旋转90度，然后拼接上原来图形得到的，那么就可以将每一个边看作一个向量，有4个方向依次是$RDLU$，然后假设原点是(0,0)，每一个就是将向量旋转90度，最终得到这个总的向量数组，然后就按这个向量不断走，走出的范围可以用矩形表示，最大数据下这个矩形边长不会超过$250$，一行一行扫描这个矩形就可以输出结果了

1.最初的方向是向右，那么最初ans中要为0

2.顺时针旋转90度，按照程序中的顺序是+3

3.4.如果给每一个格子编号的话，如果是上下，比如U，当前为$(i,j)$，下一个为横向的方向，那么下一个格子就是$(i-1,j-1)$或者$(i-1,j+1)$会发现不止是要加上当前的方向，还要加上下一个线段的方向

观察一下程序，就知道第一个填3，第二个填1

5.通过观察（归纳法证明），竖着的线段和横着的线段一定是交替出现的，奇数为|，偶数为-

完善程序 2

set里面维护的是每一段区间的左端点，以及这段区间是否可以通过

1.注意到23行有**it--**，要求的是**小于等于**当前二分的最大的元素，那么说明一定是upper_bound，而如果是lower_bound找的就是**小于**当前二分的元素，而这里是在找一段连续的障碍右边那段区间是否可以通过，那么就是upper_bound，由于是右边的空余位置，那么显然查询的是$pos[i][j]+1$

2.这里是在set里面删除，在上一行中是可以通过的，然后在这一行中是有障碍的极长线段，那么就是当前位置为$pos[i][j]$，可以通过为$1$，那么就是$make_pair(pos[i][j],1)$

3.注意到这一行的上面一行是已经将当前障碍不能通过的点加入set里面，由于1中我们确定了右边是否可以通过，如果可以，那么就要加上右边这个可以通过的区间，左端点为$pos[i][j]+1$

4.观察下面的程序，会发现tp=0代表的是出发点附近的矩形，那么一开始所有区间都是可以通过，那么加入$(l,1)$

5.关注103,105行，会发现，如果当前的$x_i\geq n-lmt$会被编号到$[lmt,2lmt)$的区间内，如果是$cord-n+lmt$编号的就是到$[0,lmt)$区间内，所以还要加上一个$lmt$

# F.One-Four Overload

## 题目大意

给定$n\times m$的网格，有若干被标记点，其中一定不在轮廓上，每一个未被标记过的点都可以填1或4，要求被标记的点周围未被标记点之和要为5的倍数，构造方案
$$
n,m\leq 500
$$

## 算法讨论

首先如果有某一个被标记点周围只有奇数个未被标记的点，那么说明一定不合法，因为一个被标记的点周围1和4出现的次数都是相同的

既然只有1和4两种选择，那么就考虑可以2-sat（事实上如果建的出来的话也一定是一个二分图）或者构造二分图然后黑白染色

由于存在一个点周围4个点都为未标记点的情况，2-sat并不能解决这个问题

首先显然一个标记周围如果只有两个未标记点，这两个未标记点之间一定要有一条连边，然后对于有四个未标记点的情况，考虑斜着连边

![IMG_20210906_231442](D:\Blog\image\IMG_20210906_231442.jpg)

如果每一条边都是斜着连的，那么连出的图一定不会存在奇环，因为每一个环至少需要绕这一个点，那么需要有4条边，如果往外扩展，一定加上的边和删去的边奇偶性相同

考虑有横着连的边，这种情况只会在周围只有两个未标记点出现，由于另外两个方向上也是存在标记点的，那么不可能存在长度为3的环，那么根据上面的扩展情况，也是同理

那么连出来的图一定是二分图，只要黑白染色就可以了

时间复杂度$O(nm)$