# **String Cards**

## 题目大意

给定n个字符串，求选出其中k个字符串按照任意顺序拼接起来，可以得到最小的字典序
$$
n,|s|\leq 50
$$

## 算法讨论

首先我们按照$a+b<b+a$的顺序进行比较

可以发现如果我们将a,b看作的数字的话，这个比较函数左右两边只与a或者b有关，那么最终的排序序列就是唯一确定的

如果直接从前往后做背包是不对的，因为我们需要选择其中k个，而不是全部选择，那么就会有长度的问题，如果长度固定这样选择是没问题的

那么既然要长度固定，那么我们从后往前做背包，这样的话，前面的权重比后面的大，最后确定最优就可以确定整体最优了

设$dp(i,j)$表示考虑到第i个字符串，选择了j个的最小字典序字符串
$$
dp(i,j)=\min(dp(i+1,j),s_i+dp(i+1,j-1))
$$
答案就是$dp(1,k)$

# X

## 题目大意

给定$n\times m$的网格，每一个格子上都有权值，现在要在上面画若干X，每一个X是将一个格子的左上端点与右下端点连接，左下端点与右上端点连接

一个画X的方案代价为所有画X格子的权值和-C*需要画的线段数量

## 算法讨论

首先假设一开始所有格子上面都画了X，并且先不记录需要画线段的代价

那么我们需要将一些格子的X去除，然后最小化其代价

考虑最小割，对于每一个格子建一个节点，$S\rightarrow x$代价为0表示不将这个格子的X去除，$x\rightarrow T$代价为$a_{i,j}$表示将这个格子的X去除

然后考虑画线段，考虑一个斜线，在画X格子与一个空白格子之间分界的时候计算代价

那么相当于$(i,j)$的格子如果选，$(i-1,j-1)$的格子不选那么就有C的代价，其中$(i+1,j-1)$也是同理，那么只需要将$x(i-1,j-1)$连向$x(i,j)$容量为c的边

需要注意的是如果$(i-1,j-1),(i+1,j-1)$在网格之外，那么直接由源点连出

然后跑最小割即可

将所有格子的权值之和-最小割的结果即可

![IMG_20211101_164032](D:\Blog\image\IMG_20211101_164032-16357561279471.jpg)

# Social Distance 2

## 题目大意

现在有n个椅子，有m个人要坐到椅子上，假设被坐的椅子序列为$B_1,B_2,..,B_m$，这种方案的贡献为
$$
\prod\limits_{i=1}^{m-1} (B_{i+1}-B_i)
$$
现在给定k个人的情况，求出剩下所有人坐的所有情况的贡献和
$$
n\leq 2\times 10^5
$$

## 算法讨论

首先考虑左右两端坐了人的情况，就是$(A_i,A_{i+1})$区间内再坐了k个人

假设$m=A_{i+1}-A_i$

那么我们要求的就是$[x^m](x+2x^2+...)^{k+1}$，其中一个单位就是表示两个人之间的差，由于中间再坐了k个人，那么就有k+1个差
$$
\begin{align}
&[x^m](x+2x^2+...)^{k+1}\\
&=[x^{m-k-1}](1+2x+3x^2+...)^{k+1}\\
&=[x^{m-k-1}]((\frac{1}{1-x})')^{k+1}\\
&=[x^{m-k-1}](\frac{1}{1-x})^{2k+2}\\
&=\binom{m-k-1+2k+2-1}{m-k-1}\\
&=\binom{m+k}{m-k-1}
\end{align}
$$
显然$k<m$，那么我们可以将这个间隔的所有k写成多项式的形式，然后将所有间隔的多项式相乘，取其中$[x^{m-k}]$项前面的系数即可

由于一个间隔的最高次数等于这个间隔的长度，由于总长度$=n$，那么最终多项式的次数为$O(n)$

需要注意的是我们还需要讨论一下只有一个端点和没有端点k=0的情况，就是将k变成k-1,k-2,其中后面那个情况需要枚举一个开头转化为第一种情况

然后直接分治乘即可，时间复杂度$O(n\log ^2n )$