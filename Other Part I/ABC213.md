# E.Stronger Takahashi

## 题目大意

给定$n*m$的网格图，其中有一些格子可以走，有一些格子不能走，现在一个人用1的代价可以破坏$2*2$的格子

求从$(1,1)$走到$(n,m)$的最小代价
$$
n,m\leq 500
$$

## 算法讨论

我傻了。。

把位置记录到状态里面去了，还写一个dij，是可以写bfs双向搜索的

正确的做法是

如果当前扩展的是可以通过的格子，直接扩展，不用代价，加入bfs队列队首

如果是不可以通过的格子，那么扩展到一个与当前$2*2$格子有交的所有$2*2$格子的范围，就是从局部往外扩展的20个格子

{0, -1}, {0, 1}, {-1, 0}, {1, 0}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}, {-2, -1}, {-2, 0}, {-2, 1}, {2, -1}, {2, 0}, {2, 1}, {-1, -2}, {0, -2}, {1, -2}, {-1, 2}, {0, 2}, {1, 2}

时间复杂度$O(nm)$

第一次提交:AC

# F.Common Prefixes

## 题目大意

给定一个字符串，对于每一个后缀求出所有后缀跟其的LCP之和
$$
n\leq 10^6
$$

## 算法讨论

显然需要用一些后缀数据结构进行维护，我使用的是sam

考虑先将字符串翻转，然后一个经典结论，两个前缀的LCS就是两个代表这个两个前缀的节点在parent树上的LCA，贡献就是LCA集合中最长的字符串长度

那么对于一个查询就是对应一个节点到根的链，答案就是
$$
\begin{align}
&\sum\limits_{x\in chain} (len_x-len_{fa_x})cnt_x\\
\end{align}
$$
那么先dfs求出cnt，然后再dfs一遍求出一个点到跟的如上形式的和

第一次提交:AC

#  G.Connectivity 2

## 题目大意

给定一张图$n$个点$m$条边，每条可以选也可以不选，求出所有选边使得$1$到$k$，联通的方案数
$$
n\leq 17
$$

## 算法讨论

首先需要求出给定一个点集$s$，使得这个点集之间联通的方案数$g_s$，那么答案就是
$$
\sum\limits_{1,k\in s} 2^{edge(C_US)} g_s
$$
至于求$g$，可以像我一样利用子集卷积求ln，来得到

也可以对于每一条边令$g'(\{u,v\})+1$，然后对$g'$做高维前缀和，然后结果就是$g$

时间复杂度$O(n2^n)/O(n^22^n)$

第一次提交:AC