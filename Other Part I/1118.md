# Kill My Eyes

## 题目大意

![20211118T1](D:\Blog\image\20211118T1.PNG)

## 算法讨论

首先如果$k1+k2>0$，那么显然答案或者答案的反面是在这n个答案中出现过的

那么就枚举哪个是答案（或者是答案的反面），然后建出多少个与答案相同，多少个是答案的反面，剩下的都是人回答的答案，看是否满足k1,k2的条件即可

然后考虑$k1=0,k2=0$的情况

由于需要字典序最小，那么需要枚举一个前缀和当前字符，查看后面是否存在一种方案合法

那么现在所有已知回答都是人的回答，那么不与答案相同也不与答案的反面相同

那么假设当前枚举第k个，那么答案中与前k位前缀相同的本质不同答案等于$2^{m-k}$，那么就不存在合法可能方案

那么需要改变当前字符，如果无法改变，那么说明无解

# Kill My Time

## 题目大意

![20211118T2](D:\Blog\image\20211118T2.PNG)

## 算法讨论

> 对于复杂的图上的询问问题一般不存在polylog做法

考虑对于所有操作序列进行分块

假设块长为$B$

那么对于在当前块内不存在修改的边，其权值是固定的，那么我们可以将这些边预处理处理，按照边权排序即可，然后相当于边权会发成改变的边最多只有B个

可以将所有询问按照询问的权值从大到小排序，对于固定边权的边，如果其边权$\geq v$，那么加入并查集中，然后考虑边权可能变化的边，在其中暴力找出符合条件的边（注意需要是在当前询问时间之前的最后一次修改的边权进行判断），加入到并查集中

那么答案就是s所在并查集的大小

然后在处理下一个操作的时候，对于边权可能变化的边需要撤回，那么并查集需要支持栈序撤回操作，可以发现暴力枚举的边的数量为$O(B)$级别

那么复杂度就是$O(\frac{qm\log m}{B}+qB\log n)$（事实上如果用set维护边集合，遍历整个set的时间复杂度为$O(m)$，那么前面的复杂度就变成$\frac{qm}{B}$，最优时间复杂度为$O(m\sqrt {q\log m})$）



也可以不用并查集维护，对于边权不变的边加入并查集之后，可以将所有点缩点，然后在缩点完之后的联通块之间连上那些边权可能变化的边，那么按时间顺序枚举询问，在原图上dfs即可，这样询问的时候不需要并查集查询

配合上set遍历的复杂度为$O(n)$，那么总时间复杂度可以为$O(n\sqrt q)$

# Kill My Justice

## 题目大意

![20211118T3](D:\Blog\image\20211118T3.PNG)

## 算法讨论

显然的斯坦纳树

设$dp(i,j,s)$表示当前走到$(i,j)$，经过的特殊点集合为k的最小代价

显然最终最优解一定是一棵树，那么可以假设当前$(i,j)$就是根

那么可以分出若干儿子
$$
dp(i,j,s)=\sum \limits_{t\subset s} dp(i,j,t)+dp(i,j,s\backslash t)-a_{i,j}
$$
其中$-a_{i,j}$代表当前代价被计算了两遍

然后也可以向其他位置扩展
$$
dp(i,j,s)=\sum dp(x,y,s)+a_{i,j}
$$
其中后面这个转移存在环，需要通过最短路实现

时间复杂度$O(nm3^k+nm2^k\log nm)$

输出方案，就是记录每一个状态最优解是从哪一个状态转移过来的，然后dfs进行遍历，在遍历过程经过的格子都设为o或者x即可

# Kill My Name

## 题目大意

![20211118T4](D:\Blog\image\20211118T4.PNG)

## 算法讨论

首先在判断一个数字是否合法的时候，数字的顺序是没有关系的，那么只需要关系这个数字集合

对于一个数字集合，相当于要将其分成两个集合，使得两个集合的数字和的差的绝对值尽可能小

那么可以用bitset维护这个背包问题

那么甚至不需要知道这个数字集合具体是什么，只需要知道这个bitset的内容，就可以判定是否合法了

可以将所有可能的bitset集合求出，大约为$10^5$个数

然后求出每一种可能bitset对应的数字的个数，具体来说，就是我们可以处理$nxt_{s,i}$表示当前bitset的状态为s，下一位数字填i得到bitset状态是什么

那么设$f(i,j,k)$表示当前bitset的状态为i，数字的长度为j，最小差的绝对值为k的方案数即可

转移的时候只需要枚举下一位填什么数字即可

那么在求出$\leq lim$的合法数字个数的时候

按照最小化字典序的枚举顺序进行枚举，就是从高位到低位进行枚举，枚举合法数字在哪一位开始于限制不同，如果这一位小于限制，那么之后的数位都是可以任意填的

那么假设之前高位数字形成的bitset状态为s，当前为第i位，当前位填的数字位j的

那么答案就是$f(nxt_{s,j},m-i,k)$，将其求和即可