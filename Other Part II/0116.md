# SRM540 ProductQuery

## 题目大意

给定若干个限制$(l,r,x)$表示$A$序列$[l,r]$区间内所有数的乘积模10为$x$

求出A可能的数量
$$
n\leq 100,m\leq 50
$$

## 算法讨论

首先模10是很难进行处理的，就是需要处理2,5这个两个因子，需要关注很多细节，但是如果将模10拆成模2,5的话，那么由于模数都是质数，那么在处理起来就很方便

如果我们确定每一个位置上的数模2,5的值的话，那么我们可以通过CRT唯一确定这个位置上的数模10的结果

那么只需要对于两个模数分别求出答案，然后相乘就是结果

考虑模5意义下的答案

对于限制来说如果$x=0$，那么说明$[l,r]$区间中至少存在一个0（这个就是模质数的好处，如果是模10，还有一种情况就是区间内2,5的因数个数都存在）

而$x\neq 0$的情况，由于是对于一个区间的限制，那么可以通过前缀积变成对于两个数的限制，假设A数组的前缀积为$s_i$，那么限制就是要求$\frac{s_r}{s_{l-1}}=x$，并且要求区间中不能出现0

那么我们考虑用DP统计放置0的位置，那么相邻的两个0之间都是填非0的数，并且要求$x=0$的限制不能被完全包含在这个区间内，并且$x\neq 0$必须要完全包含在这个区间之内

那么设$dp(x)$表示当前$x$位置填了一个0的方案数，转移的时候枚举上一个0填在哪里$j$，如果$[j+1,i-1]$合法，那么$dp(i)=dp(j)\times f(j+1,i-1)$，其中$f(l,r)$表示对于$x\neq 0$在这个区间内的方案数

那么现在问题就转化为所有限制$\neq 0$的问题，那么考虑$l-1\rightarrow r$边权为$x$，表示$s_{l-1}\times x=s_r$，同样的$r\rightarrow l-1$边权为$\frac{1}{x}$

那么对于一个联通块来说，如果确定了某一个位置的取值，那么其他位置都能被确定出来，同时可以确定是否合法（就是将确定的点权代入到边的限制上去，如果存在不满足条件的，那么说明不合法），由于一个位置上的数最多填$p-1$个，那么可以枚举一个联通块中一个节点位置上的数，然后判定是否合法，然后将所有联通块的答案乘起来就是答案

时间复杂度$O(n^2m)$

# TCO12 Round 2A EvenPaths

## 题目大意

给定一个n个点的DAG，然后每一个点上可能存在障碍物，其中如果$?$表示这个点上可能存在障碍物，其中$-$表示这个点上一定没有障碍物，然后求出在所有的可能中，$1\rightarrow 2$点的路径数量为偶数的情况数量
$$
n\leq 50,m\leq 500
$$
保证$?$数量不超过32

## 算法讨论

首先注意到?的数据范围很小，只有32，但是显然这个问题是很难在多项式内解决的，那么就需要考虑对于$?$的数量进行折半枚举

可以先预处理出来这个DAG的拓扑排序，那么取拓扑排序中前$\frac{k}{2}$个?（包含其他点）作为一半，剩下的作为另一半

一种暴力的做法就是，在枚举左边所有？的取值之后，将1号点到左边所有点的路径数量奇偶性求出$s$，在枚举右半部分时，处理出来左边每一个点经过右半部分的点之后到达2号点路径数量的奇偶性，压缩成$t$，那么如果$popcount(s\&t)$为偶数，那么说明就是存在偶数个路径

但是由于实现$s\&t$需要FWT进行AND卷积，时间复杂度是$O(n2^n)$的

那么就需要考虑在压缩状态的时候不要把左边所有点都记录进去，而只记录？的点，那么可以预处理出来左边每一个点是由哪些特殊?的点转移过来的，这个只需要记录系数的奇偶性即可，同样状压成一个整数进行记录$f(x)$，其中需要特殊注意如果转移到了某一个?点，那么$f(x)=2^x$即可，而不是$+=2^x$，因为这个点的路径数量就是等于$f(x)$中各项系数乘上路径之和，如果+$2^x$，相当于多算了一遍

同时将1号点到左边所有点的路径数量奇偶性求出$s$

那么在枚举右边端点的时候，同样按照拓扑序处理出来左边特殊点到某一个点的路径系数之和，记$t=f(2)$$popcount(s\&t)$为偶数，那么说明就是存在偶数个路径

可以用桶记录$s,t$取值次数，然后FWT进行AND卷积即可，统计1的个数为偶数的答案之和

时间复杂度$O(2^{\frac{k}{2}}m)$

# ABC235H **Painting Weighted Graph**

## 题目大意

给定一个n个点m条边的无向图，边有边权，现在可以进行如下操作至多k次

- 选择一个节点$v$和一个整数$x$，将所有可以从$v$出现经过边权不超过$x$的点染成红色

求可以形成多少个不同的红色点集
$$
n\leq 10^5,k\leq 500
$$

## 算法讨论

首先根据操作的性质，那么进行一次操作相当于在最小生成树上将$\leq$一个数的所有边连起来，将其中一个联通块染成红色，但是这样做会比较难做，因为选择的是一个形状不定的联通块而不是一个子树

那么考虑建出重构树，对于每一条在最小生成树上的边建立一个点，左右儿子为加入这个点的时候合并的两个联通块，那么相当于每一次可以选择一个子树，将子树内部的所有节点染成红色

但是需要注意如果边权存在相同的，按照常规建立二叉重构树就会有问题，就是需要将多个子树同时染成红色而不能单独染一个子树

那么就可以考虑建立多叉的重构树，那么相当于将同一个边权的边同时加入到最小生成树中，将合并的联通块连接在这个点下方即可

由于我们需要对于可能的点集进行计数，那么对选择的子树就有一些限制

- 不能存在有祖先关系的节点对
- 不能存在某一个节点的所有儿子都被选择（这是因为，如果儿子都被选择，那么相当于就是这个节点被选择了，由于需要尽可能的少用操作，那么就可以转化为直接选择这个节点）

然后就可以考虑DP，设$dp(x,i)$表示在$x$子树内选择了$i$个节点的方案数

考虑转移的时候进行背包合并，最后将$dp(x,|son(x)|)-1$，将$dp(x,1)+1$以满足第二条限制

需要注意的是在卷积过程中需要保证枚举的次数$\leq k$，那么可以证明这样的时间复杂度为$O(nk)$

证明：首先考虑子树大小$\leq k$的子树，一开始每一个节点都是孤立的，每合并一次相当于将某些节点合并，代价为两堆节点中节点数的乘积，那么合并次数为$k^2\leq nk$

然后考虑子树大小$>k$的子树，首先我们对于$\leq  k$的子树只保留极大的子树即可，那么显然这样的子树不会相交，并且个数最多为$\frac{n}{k}$，而每一次将两个子树进行合并都是会将子树总数减少1，也就是说对于$>k$的点度数$\geq 2$的点数量不会超过$\frac{n}{k}$（对于度数为1的点，直接继承即可），而这些点的度数之和为$\frac{n}{k}$，那么进行一次合并的复杂度为$k^2$，最多进行$\frac{n}{k}$次合并

时间复杂度为$O(nk)$

