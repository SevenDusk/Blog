# A.树上的串串

首先考虑将树进行轻重链剖分，那么我们可以将一条路径划分成$\log n$段

为了方便起见，我们令$s'_{dfn_i}=s_i$，由于$b$号节点在跳重链的时候所经过的节点顺序按照dfs序编号并不是从小到大经过的，那么我们可以将串再复制一份然后进行翻转

那么将$(a,b),(c,d)$分别进行分解，我们可以对应到字符串上的若干个区间

分别记作$(l_1,r_1),...,(l_x,r_x)$和$(L_1,R_1),...,(L_y,R_y)$

那么一开始我们可以判断一下长度为$\min(r_1-l_1+1,R_1-L_1+1)$的前缀是否是相同的，如果是相同的，那么我们可以将开头那个较小的区间删除，将较大的那个区间缩小范围，继续判断接下来的区间

如果是不同的，那么说明在这个长度只能已经出现了不同的字符，那么直接二分出这个位置即可

由于每一次判断要么直接二分退出整个判断过程，要么至少删除一个区间，那么只需要$O(\log n)$次判断即可

判断两端区间内的字符串是否相同可以用hash，**如果使用单模数hash的话，常数可以减半，还有一些特判就是，所有字符都相同那么直接输出两条路径中较短那条的长度，如果开头字符就不同，直接输出0，跳过之后的步骤，这样在数据没有特意卡的情况下，常数非常小**

时间复杂度$O(n+q\log n)$

# B.小丑

记$sp_i=\sum\limits_{j\leq i} [a_j>0] a_j,sn_i=\sum\limits_{j\leq i} [a_j<0]a_j$

那么$s_i=\frac{sp_i}{P}+\frac{sn_i}{|N|}$

假设$s_i<s_j$

那么有$|N|sp_i+Psn_i>|N|sp_j+Psn_j$

那相当于要找到$|N|sp_i+Psn_i$最大的那个$i$

令$c=|N|sp_i+Psn_i$可以得到$sn=-\frac{|N|}{P}sp_i+\frac{c}{P}$

那么将$(sp_i,sn_i)$放到平面直角坐标系中，那么我们只需要维护一个右上凸包即可，每一次查询的时候用斜率为$-\frac{|N|}{P}$的直线去查询切点即可

考虑如何进行修改，我们修改一个数的时候会对这个后缀的$sp_i$或者$sn_i$加上一个数

那么可以考虑分块，假设我们要对$[pos,n]$的后缀进行修改，那么我们可以先暴力重构$pos$所在块的凸包，然后至于后面的整块，我们只需要维护一个全局加标记即可

然后查询的时候直接在凸包上二分，这样平衡复杂度之后是$O(n\sqrt{n\log n})$

如果我们将所有询问离线下来，将对凸包两次重构之间的询问按照斜率排序，这样切点就是单调的，如果斜率排序用基数排序的话，那么总时间复杂度$O(n\sqrt n)$但常数较大

# C.博弈

首先如果树上只有一个白点的情况显然是先手必胜

然后考虑树上至少存在两个白点的情况，首先我们可以将树分裂成若干以白色节点作为根的子树（就是去除包含根并且只包含黑色节点的极大联通块，因为我们不能选择黑色节点，这些节点实际上是没有意义的），而对于这样所有的子树来说，其可以看作若干独立的子游戏的

接下来考虑根为白色节点的情况

注意到如果一个子树内存在两个白色节点并且根节点是白色的，先手选择子树内部的节点一定是不优的，因为在选择根节点之后可以任意改变子树内部的节点颜色，如果先手先选择子树内部的白色节点所产生的影响一定会被选择根节点抵消掉

并且选择了子树内部的白色节点，不会对根节点产生任何影响，最终还是需要选择根节点的，一旦先手对子树内部的操作对后手不利（此处不利的影响就是在之后选择根节点的时候会交换先后手），后手一定可以选择根节点来抵消这个不利的影响

那么我们就可以从上到下进行考虑，首先对于根节点的操作存在两种不同选择

一种是只选择根节点，对子树内部的节点不产生影响，那么相当于将这个根节点染黑，那么同样可以分裂出若干子游戏

一种是将子树内部的节点任意进行变换，由于可以任意进行变换，我们博弈最后的结果实际上跟树的形态是没有关系的，考虑将这种情况的sg函数求出来

首先如果只有一个单独的白色节点，其sg值等于1，然后考虑不断向上扩展节点，第二层的时候可以限制白色节点子树都是单个节点（因为有更深的子树最终可以不断向下找到第二层的节点），可以得到其sg值等于2

那么按照类似的过程向上计算，那么可以得到最终一个最深深度为$d$的子树的sg值等于$2^d$

由于第一种操作，我们实际上是可以将所有白色节点看作独立的游戏，根据sg定理可以知道整个游戏的sg值等于各个子游戏的sg异或和，直接计算即可

时间复杂度$O(n)$

