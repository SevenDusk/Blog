# A.打

首先可以直接用$m$元组记录当前每一种血量的随从有多少个，当$k=3,m=8$的时候状态数量为165种

然后考虑从后往前用矩阵乘法加速计算，我们在过程中维护一个向量，表示当前状态下的期望，假设当前有一个三元组$(a,b,c)$，那么攻击魔王的概率就是$\frac{1}{a+b+c+1}$，那么产生的期望贡献就是$\frac{1}{a+b+c+1}$

由于我们是从后往前进行DP的，那么转移的举证需要转置

然后我们可以预处理转移矩阵的$2^i$次幂，然后在询问的时候用向量和预处理的矩阵相乘即可

时间复杂度$O(V^3\log n+TV^2\log n)$

# B.极

首先可以发现有效的数段只有$2q$个，那么可以把每一个限制的左右端点离散化，然后可以得到$2q$个连续的区间，并且可以发现每一个连续的区间可以填的数的上界是相同的，上界就是所有覆盖这一点限制$m$的最小值

考虑如果只有一个限制的时候，方案数可以简单容斥计算，就是$m^{r-l+1}-(m-1)^{r-l+1}$，那么考虑多个限制的时候，就可以容斥地计算，即$\sum\limits_S (-1)^{|S|} f(S)$，其中$f(S)$表示强制满足$S$集合中限制条件的，其他的条件不满足的方案数，记$x\in S$的所有线段的并的长度为$a$，$x \notin S$所有线段的并长度为$b$，那么$f(S)=m^a+(m-1)^b$，那么这个可以用$DP$解决

设$dp[i][j]$表示到第$i$个区间，所选的区间最远到达$j$的容斥计算结果之和，注意需要把$-1$乘入到结果中

转移如下

$dp[i][j]\rightarrow dp[i+1][j]$

$-g(l[i],r[i],j)dp[i][j]\rightarrow dp[i+1][max(j,r[i])]$

$g(l,r,i)$表示$[l,r]$这个区间与长度为$i$前缀扩展的方案数，也就是讨论一下左右端点$l,r$与$i$的大小关系，利用上面计算容斥系数的算法计算即可

注意到任意一个线段只会出现在点的上界为$m$的区域中，那么可以对于上界相同的点单独考虑，算出容斥系数，将所有的容斥系数相乘起来，就是答案

需要特判某一个限制一定不会被满足的情况，并且需要注意常数，要预处理幂次，否则会在extra test被卡

# C.森 (「WC2018」通道)

首先对第一棵树进行边分治，那么我们现在可以得到两个不交的点集，记$d_1(x)$表示$x$这个点到分治中心的边权和，然后要在这两个点集中选择两个点$x,y$，最大化$d_1(x)+d_1(y)+w+dis_2(x,y)+dis_3(x,y)$

现在就变成了两棵树的问题，一种想法是在第二棵树上建出当前点集的虚树，然后对这个虚树再进行边分治，转化成一棵树的问题

考虑一棵树的情况如何做，固定一个点，求出另一个点集中到这个点的距离最大值，经典结论最优情况一定是点集虚树的直径两个端点之一，由于这里是带权的情况，并且需要对单点多加一个权值，那么事实上我们可以看作再所有点下挂一个点，边权为需要加的权值即可

那么我们只需要求出第三棵树的虚树，然后求出虚树上的直径的两个即可

不过由于直径具有可合并性（即合并两个点集得到新点集的直径，一定是在原来两个点集直径的四个端点之中）

那么对于第二棵树的边分治实际上是没有必要的，可以直接枚举选择两个点在第二棵树建出的虚树上的LCA即可

此时由于第一棵树进行边分治，现在分成了两个不同的点集$A,B$，建出的虚树的点会分成三类点：不属于任何两个点集，属于其中一个点集

那么在第二棵树的虚树每一个点维护子树内所有属于$A$点集在第三棵树上的直径端点$pa_x$，维护子树内所有属于$B$点集在第三棵树上的直径端点$pb_x$

那么在合并子树的过程中，检查$pa_x,pb_u$的四对点的贡献，$pb_x,pa_u$的四对点的贡献，更新答案即可

这样的时间复杂度就是$O(n\log ^2n)$，瓶颈在于在第二棵树上建虚树的时候需要进行排序，事实上如果建出第一棵树的边分树，通过归并排序，就可以优化到$O(n\log n)$

