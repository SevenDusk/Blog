# A.树

首先可以发现的是，如果我们强制钦定某一个节点是叶子节点的话，在统计加入这个节点的方案数之后就可以将这个节点直接删除，对之后的节点选择父亲没有影响

那么注意到题目中的限制是在一棵树中是叶子节点在另一棵树上是非叶子节点，那么就可以考虑对这个非叶子节点进行容斥

那么对于一个节点相当于有四种选择

- 在第一棵树中作为叶子节点，在另一棵树中任意放置，贡献的容斥系数是1
- 在第一颗树中作为叶子节点，在另一棵树中作为叶子节点，贡献的容斥系数是-1
- 在第一棵树中任意放置，在第二棵树中作为叶子节点，贡献的容斥系数是1
- 在第一颗树中作为叶子节点，在第二棵树中作为叶子节点，贡献的容斥系数是-1

然后考虑如何计算固定一个叶子节点时候的贡献

对于第一颗树来说，假设当前固定的节点是$i$，$[1,i-1]$没有作为叶子的节点有$k$，那么贡献就是需要乘上k

对于第二棵树来说也是类似的，但是有一点不同的是，在统计$i$的贡献的时候，需要记录$>i$没有作为叶子节点数量

这样在DP的过程中只能统计一个方向的贡献，在DP时候不能预先知道第二棵的贡献，但是我们可以在DP之前预先确定第二棵树中有多少个节点不作为叶子节点，那么这样就可以进行DP了

那么可以设$f(i,j,k)$表示考虑了$[1,i]$中的点，第一棵树中没有作为叶子的节点有$j$个，第二棵树中$[i+1,n]$没有作为叶子节点有$k$的贡献

一开始预处理$f(1,0,i)=i!$，然后转移就是按照上面四种情况转移

那么对于一个$n$，答案就是$\sum f(n-1,i,1)\times i!$

时间复杂度$O(n^3)$

# B.众数

首先题意等价于选出一个区间$[l,r]$使得区间内出现次数最多的数个数+区间外出现次数最多的数个数最大

我一开始先发现了一个性质，假设$a_i$表示$i$出现的次数，那么$k\geq \max a_i$，那么也就是要求两种涉及到的数$i,j$满足$\max(a_i,a_j)\geq \frac{\max a_i}{2}$

那么也就是说如果$\max a_i\geq \sqrt n$，那么$\max(a_i,a_j)$是在$O(\sqrt n)$的级别

假设$a_i>a_j$，那么我们可以只枚举$a_i\geq \frac{\max a_i}{2}$的个数，这样的数也只有$O(\sqrt n)$个，然后枚举$a_j\leq a_i$，然后通过记录$i$出现次数的前缀和，我们可以做到$O(a_j)$求出最大的$k$

那么这样的时间复杂度就是$O(n\sqrt n)$并且常数很小，在这种情况下的构造方案，可以讨论一下$i,j$哪一个是作为区间外的那个数，同样比较简单

就提示根号分治，主要需要解决$\max a_i\leq \sqrt n$的情况

那么答案一定是$O(\sqrt n)$级别的，那么我们可以先考虑枚举区间内出现最多的数个数$L$

那么对于每一种数，就可以求出$O(a_i)$个对应区间（区间中恰好存在$L$个$i$），那么总共有$O(n)$个这种区间，但是我们需要对这所有的区间之外求出区间众数

通过莫队的话，就可以做到$O(n^{\frac{5}{3}})$的复杂度，考虑进一步优化

首先在莫队过程中，我们肯定是需要一个桶来统计区间外每一个数的出现次数，但是由于这些区间都是任意交错的，为了保证复杂度就需要用莫队，但是如果我们可以将这些区间有序处理的话，就有可能规避掉莫队

注意到，如果一个区间包含了另一个区间的话，那么大区间是一定不优的，那么就可以将大区间删除，那么在最终得到的所有区间按照左端点排序，那么右端点就是单调递增的

那么就可以用双指针进行维护，这样时间复杂度就是$O(n\sqrt n)$

然后需要考虑构造方案，我们需要先将最大值$k$求出，然后枚举$L$，然后枚举在区间外的数种类，那么也是存在$O(a_i)$种方案，就是枚举一个区间$[l,r]$满足$a_{l+1}=i,a_{r+1}=i$，并且$[1,l)\cup (r,n]$中$i$出现了$k-L$次，然后需要求出$[l,r]$是否存在一种数出现次数$\geq L$

等价于求出这个区间中是否包含之前所说的$O(n)$个区间中一个，那么可以记录区间右端点的后缀最小值即可$O(1)$判断

那么总时间复杂度就是$O(n\sqrt n)$，由于后面这种方法的常数比较大，所以阈值需要调小一些