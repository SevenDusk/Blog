# 2017 ACM-ICPC World Finals J Son of Pipe Stream

首先考虑将A的流量乘v，然后看作与B同样的流量即可，那么相当于将一个流拆成两个流，并且两个流的源点分别为1,2并且汇点相同为3

那么假设我们固定了总流量$T$，假设我们拆成两个流分别为$A,B$其中$A+B=T$

那么价值函数为
$$
f(A)=A^\alpha B^{1-\alpha}=A^\alpha(T-A)^{1-\alpha}
$$
考虑对这个函数进行求导
$$
f'(x)=x^{\alpha -1}(\alpha T-x)(T-x)^{-\alpha}
$$
通过令$x_1<x_2$计算$\frac{f'(x_1)}{f'(x_2)}$就可以证明其单调性，那么$f'(x)$的零点为$A=\alpha T$，那么$B=(1-\alpha )T$

但是需要考虑$A$的范围，显然$A$的取值不能超过只把1作为源点跑出的最大流记作$A_{max}$，$B$的范围也是同理$B_{max}$

那么说明$A\in[\max(0,T-B_{max}),\min(T,A_{max})]$，那么如果$\alpha T$落在区间之内的话，那么令$A=\alpha T$就可以取到最大值，否则就是取到两个端点中较大的那个即可

那么可以发现的是T越大可以得到的最大值也就越大，那么显然$T$取到最大流的时候最优，那么剩下的问题就是能否构造一组解

那么我们在跑$T$的最大流的时候，源点连向$1,2$这个两个点，然后将3号点设为汇点，然后跑最大流，相当于我们现在要求源点流向1这个点的流量要恰好为$A$，流向2号点的流量要恰好为$B$

我们可以假设当前流向1的流量$<A$（对于大于的情况也是类似的）那么我们要增加A的流量，那么不妨令1号点作为源点，然后2号点作为汇点，在残量网络上跑有流量上限的网络流即可，流量上限为A-(一开始流向1的流量)，结束这个过程之后得到图仍然是一个合法的残量网络

这样我们就可以保证流向1号节点的流量$=A$，那么就可以固定每一条边的流量方向，新建一个得到的有向图，从1号节点到3号节点再跑一遍最大流，其中1的流量限制为A，那么可以得到每一条边的A物质的流量，显然剩下的图也是可以组成一个从2号节点出发的流，那么就完成了构造

# CF1530H Turing's Award

首先我们可以考虑将整个过程倒过来进行考虑，那么这样的话所有格子的数字就是走过的第一个数字，那么显然走过的位置形成了一段区间，并且我们并不需要关系其在数轴上的绝对位置，我们只关心各个元素之间的相对关系

下面是一个关键的想法，就是考虑的DP过程关于LIS的信息是无法用$O(1)$个变量进行表示的，并且对我们的移动操作来说，由于可以停留在原地，那么如果向某一个方向拓展一格我们可以选择任意的比当前填的数小的数进行操作，那么我们可以考虑去除那些不在LIS中的数字，相当于我们最终得到的序列就是得到的LIS

事实上我们是可以做到的，除了一种情况就是由于我们需要强制选择$a_n$放到序列中如果LIS中不存在$a_n$这个元素的话，那么实际的序列长度需要+1

然后还需要用到一个结论就是，**对于一个任意的排列来说，其LIS和LDS的长度期望是$O(\sqrt n)$**，由于我们形成的序列可以从一个IS和一个DS组成，那么显然长度也是$O(\sqrt n)$的

那么我们就可以考虑DP了，由于我们只关心可能在LIS中的序列，那么我们只需要记录这个序列的开头元素和结尾元素还有这个序列的长度即可，并且假设当前使用到$i$这个数，强制当前位置在两个端点其中一个，那么说明开头元素和结尾元素其中之一为$i$

那么设$f_L(i,len)$表示当前i在左端点LIS的长度为$len$的最小可能右端点，$f_R(i,len)$的定义类似

那么就有转移
$$
f_L(i,len)=\min \limits_{j>i,a_j>a_i} f_L(j,len-1)\\
f_L(i,len)=\min\limits_{j\geq i+len-1,f_R(j,len-1)>a_i} a_j
$$
对于$f_R(i,len)$的转移是类似的，那么我们可以通过用树状数组来优化这个转移

由于状态总数为$O(n\sqrt n)$

那么总复杂度为$O(n\sqrt n\log n)$

# 「ZJOI2017」字符串

由于是区间修改操作，那么我们就肯定需要用线段树进行维护，那么考虑在线段树中维护什么信息

考虑一个串可能成为最小后缀的位置集合$S$，在线段树节点中就是维护这个$S$，当然不能直接维护，我们肯定需要找一点性质出来

假设当前的区间为$[l,r]$并且整个字符串记作$s$

那么对于$i,j\in S,i< j$来说，如果其$lcp(s[i...r],s[j...r])<r-j+1$，也就是说这两个后缀在区间内已经分出大小，那么显然对于比较出来字典序较大的那个字符串就不能留在$S$集合中了

但是通过这个限制我们并不能减小$S$集合大小范围

那么接下来考虑$lcp(s[i...r],s[j...r])=r-j+1$的情况，那么也就是说$s[j...r]$是$s[i...r]$的一个前缀同时也是一个后缀

根据border的性质可以知道其一定存在一个循环节$s[i...j+1]$

如果$2(r-j+1)>(r-i+1)$，那么循环节长度$\leq r-j+1$，那么假设$s[i...r]=T^{k+1}c,s[j..r]=T^kc$

其中假设$c=T[1..p],p\leq|T|$

那么考虑往后加入一个字符$q$，如果$q>T[p+1]$，那么显然我们取$s[i...r]$一定比$s[j...r]$字典序小，如果$q\leq T[p+1]$那么我们取$c$这个后缀一定也比取$s[j..r]$优

那么我们就可以说明$|s[i..r]|\geq 2|s[j...r]|$，那么说明$|S|=O(\log n)$(因为确定最小可能后缀，剩下的后缀长度至少倍增)

那么我们可以在线段树中暴力合并两个儿子的可能的$S$，那么我们唯一需要计算的就是两个后缀的LCP长度，我们考虑用hash进行维护，我们需要一个数据结构维护这个序列的hash值，可以发现的是我们查询某一个位置hash值的次数会远远大于修改次数

那么考虑平衡复杂度，那么可以用分块做到$O(\sqrt n)$单次修改，$O(1)$单次查询，那么在求LCP的时候直接二分即可

由于每一次修改之后需要重新更新涉及到的线段树节点，而每一次合并的复杂度为$O(\log ^2n)$

那么总的时间复杂度$O(n\log ^2n+q\log^3 n+q\sqrt n)$

