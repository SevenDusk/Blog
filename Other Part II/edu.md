# Yet Another Card Deck

## 题目大意

有 n张卡片从高到低叠放在桌子上，最上面的编号为 11，最下面的编号为 n。第 i张卡片的颜色为 a_i。

现在你需要执行 q 次操作，第 i 次操作对应的操作码为 t_i。需要执行三步操作：

- 找到最高的颜色为 t_i 的卡片（即编号最小的）
- 输出这张卡片当前编号
- 将其抽出来放到所有卡片的最上面（这一步后有些卡片的编号可能会发生改变）

$$
n\leq 2*10^5,a_i\leq 50
$$



## 算法讨论

首先会移动位置的卡片都是在对应颜色中第一个位置，那么说明在整个过程中会移动的位置只有50个

并且如果这50个都被移动过只会在前50张卡片中

那么直接从前往后暴力找出来位置，然后放到最前面即可，删除可直接删除，也可链表删除

时间复杂度$O(n\max a_i)$

 # Nearest vectors

## 题目大意

有n个点,每个点表示原点到该点的向量,让你求出两个向量最小的夹角,输出向量的序号

## 算法讨论

对所有向量极角排序，用象限+叉积进行判断

计算两个向量所成角可以用点乘除以两个向量的模长求出cos值

**这里需要注意不能直接浮点数比较，需要记录当且最小角的两个向量，然后将相除的形式改写为交叉相乘的形式，然后进行整数比较**

需要用__int128

# Igor In the Museum

## 题目大意

给定一个$n\times m$的地图，有k次查询。每次查询，询问位置（x,y）的'.'连通块周围有多少个'*'

## 算法讨论

首先记录每一个.是属于哪个联通块

直接对于每一个联通的.枚举周围可以得到的位置，如果为$*$，并且在这个联通块中没有被枚举到，然后将计数器+1

查询只需要查询.对应联通块周围的情况即可

# Chocolate Bar

## 题目大意

你有一块长方形的巧克力，这块巧克力共有n*m小块。你想吃k小块巧克力，因此你也许需要掰开这块巧克力。

在每一次操作中你可以把任意一块矩形形状的巧克力掰成两块矩形形状的巧克力。你只能沿着巧克力小块之间的分割线掰开巧克力——可以沿着水平方向或是竖直方向掰开。掰开巧克力的花费等于分割线长度的平方。

例如，如果你有一块$2*3$的巧克力，那么你可以沿着水平方向掰从而得到两块$1*3$的巧克力，这次操作的花费即为3^2=9。或者你也可以沿着竖直方向掰从而得到一块$2*1$的巧克力和一块$2*2$的巧克力，这次操作的花费即为2^2=4。

对于每一个给出的n，m和k，计算出最小花费。你可以用多块巧克力凑出k小块巧克力。剩余的巧克力可以不是完整的一块。

## 算法讨论

设$f(n,m,k)$表示一块$n\times m$的巧克力分成面积为$k$的巧克力最小代价
$$
f(n,m,k)=\min\{\min \limits_{i,j} f(i,m,j)+f(n-i,m,k-j),\min\limits_{i,j} f(n,i,j)+f(n,m-i,k-j)\}
$$
直接记忆化搜索即可

# Make Palindrome

## 题目大意

给出一个由小写字母组成的字符串 $s$。首先你可以改变 $s$ 中任意多个字母。然后你可以改变 $s$ 中各个字母的排列顺序。问如果要将 $s$ 变成回文串至少要改变多少个字母？（改变排列顺序不算改变字母）

## 算法讨论

首先考虑偶数的情况，可以发现字符串中出现次数为奇数的字母是有偶数个，那么需要将一些字母变化成其他字母，**那么操作数最小的情况不是只转化成一个字母，而是两两配对将其中一个字母转成另外一个字母**，那么字典序最小的情况就是首尾配对，保留前$\frac{k}{2}$个

然后考虑长度为奇数的情况，那么需要保留一个字母作为中间的，同样也是保留前$\frac{k}{2}$，那么相当于这个字母就是所有出现次数为奇数按排序后的中间那个字母，那么剩下的字母首尾对应

# Area of Two Circles' Intersection

## 题目大意

分别给出两个圆的圆心坐标和半径（(x1,y1),r1和(x2,y2),r2），求两个圆相交部分的面积。

## 算法讨论

首先判掉两个圆相离或者相包含的情况

然后相当于我们需要求一个弓形的面积，首先需要计算出两个圆心的距离，然后进而通过余弦定理求出弦心距以及角度，算出扇形的面积和三角形的面积，做差即可

需要注意精度问题，需要开long double

# Load Balancing

## 题目大意

![20211020T](D:\Blog\image\20211020T.PNG)

## 算法讨论

首先最终情况一定是有$sum\%n$个$\lfloor \frac{sum}{b}\rfloor+1 $，然后$n-sum\%n$个$\lfloor \frac{sum}{b}\rfloor$

那么显然就是将这个从小到大进行排列，然后将任务也从小到大进行排序，那么答案就是
$$
\frac{1}{2}\sum\limits_{i=1}^n |a_i-b_i|
$$

# Gadgets for dollars and pounds

## 题目大意

描述 一个人手上有s卢布，他要在n天内买m样东西中的k样. 有两种支付方式，每个物品有一种支付方式,要么用美元，要么用英镑。每天有不同的支付方式代价，即换取一美元或英镑，需要付出x[i]卢布的代价。 要求：最早完成买k样东西的天数。如果无法完成任务，输出-1 一种商品只能购买一次，但是一天可以买多种商品 输入 第1行：n, m, k, s 第2行：n个整数，表示多少卢布换一美元 第3行：n个整数，表示多少卢布换一英镑 接下来是m行，每行2个整数，表示每样东西用什么货币结账（1是美元，2是英镑），以及要多少那种外币 输出 输出最短到第几天买完k样商品

## 算法讨论

首先二分答案，然后进行check

首先将两种货币购买的物品分别进行排序，显然是从前往后进行购买

那么由于一天之内购买的物品不设上限，那么显然用同一种货币支付的物品是在mid天之前最小的$a_i$的那一天进行购买

那么可以处理出来最小兑换率和是哪一天，然后枚举每一种货币购买多少，判断需要的钱数是否小于等于拥有钱数即可

# Minimum spanning tree for each edge

## 题目大意

给定一张图，对于每一条边求出包含这条边的最小生成树

## 算法讨论

首先需要求出最小生成树，那么对于树上的边那么答案就是最小生成树的答案

然后考虑那些不在树上的边，相当于是与两个端点在树上路径边权的最大值进行替换

那么只需要对于最小生成树求出倍增数组即可

时间复杂度$O(n\log n)$

# Replace To Make Regular Bracket Sequence

## 题目大意

给定一个只含 `>`，`(`，`)`，`{`，`}`，`[`，`]`的字符串。记`<`，`(`，`{`，`[`为左括号，`>`，`)`，`}`，`]`为右括号。每次可以将任意一个左括号换为任意一个不同的左括号，或将任意一个右括号换为任意一个不同的右括号，记为一次操作。求使括号序合法的最小操作次数，若无解，输出 `impossible`。

## 算法讨论

首先用栈求出每一个括号匹配另外哪个括号，如果中间栈空并且新出现一个右括号那么一定不合法

最终栈不为空也是不合法的

那么考虑每一个括号匹配的那个，如果是一样的类型，就不需要进行操作了

否则就需要进行一次操作，那么答案就是类型不一样的括号对数

# The Union of k-Segments

## 题目大意

```cpp
给你 n 条线段，再给你一个整数 k。如果一个点至
少被 k 条线段覆盖，那么这个点是符合条件的，如果符合条件的点可以不间断的连起来组成
一条条的线段（注：线段中间是不能有断开的），并且要求符合条件的线段数越少越好。 （注：
只有一点也可以）。 换句话说就是让你将覆盖 k 次及 k 次以上所有的区间都找出来，如果两
个区间能够合并，那么输出他们合并的结果，例如：k=1,区间[0-3],[3-5]可以合并成[0-5]，但
是 k=1,区间[0-3][4-5]，是不能合并的，因为他们两个区间没有重叠部分。
```

## 算法讨论

首先注意到是所有点，而不是所有整点，那么我们就需要将小数位置的点也考虑进来

那么考虑将所有区间端点的坐标$\times 2$，然后对于一个区间对$l-1,l,r,r+1$进行离散化

然后就是差分，只需要求出有多少个连续$\geq k$的覆盖位置就是答案

构造方案就是连续段的两个端点/2，显然端点一定是原来区间的端点

### Solution 2

可以将区间拆分成两个后缀然后进行扫描线，同时维护当前扫描线的位置被多少个区间覆盖，如果遇到加上一个后缀的，那么k+1，如果当时为1的话，那么说明需要开始一段新的区间

如果遇到一个减去后缀的话，那么k-1，如果减完之后=0，那么说明当前区间结束

这样就避免了，要讨论小数位置的情况

https://codeforces.com/contest/609/submission/14881222

# Square Root of Permutation

## 题目大意

给定排列$p$，求一个排列$q$使得$q^2=p$

## 算法讨论

首先考虑q代表的有向图，那么可以发现进行两次映射，长度为奇数的环大小不变，然后顺序步长变成2，对于偶数的环来说，会分成两个环，分别为偶数位置和奇数位置的环

然后进行复原

那么$p$中长度为相同偶数的环个数一定是偶数，否则一定不合法

那么对于p中奇数的环只需要重新编号即可，对于偶数的环需要将两个长度相同的偶环进行合并，按顺序合并即可

# The Labyrinth

给你一张图，‘*’表示墙，‘.’表示空地，问每个'*'周围的联通快中‘.’的数量和 mod 10，属于同一个联通快的只计算一次。

## 算法讨论

还是求出所有的.联通块并且给联通块内部的点标上这个联通块的标号

那么对于$*$来说只需要将周围不同联通块大小加起来+1就是答案

# Longest k-Good Segment

## 题目大意

给定一个包含n个整数的序列a，$0\le a_i \le 10^6$ ，询问不重复数字个数$\le k$的最长区间的左右端点。如果有多解输出任意一组。

## 算法讨论

考虑单指针，显然随着区间右端点增加，左端点也是单调的

那么可以通过维护每一种颜色出现了多少次，来进行快速的单点删除插入

# Sum of Remainders

## 题目大意

$$
\sum\limits_{i=1}^n n\bmod i
$$

## 算法讨论

$$
\sum\limits_{i=1}^m n-\lfloor \frac{n}{i}\rfloor i\\
nm-\sum\limits_{i=1}^m \lfloor \frac{n}{i}\rfloor i
$$

那么可以直接整除分块，时间复杂度$O(\sqrt m)$

# Pearls in a Row

## 题目大意

现在有N个数，你的任务是将这N个数尽可能切割成多段。每一段必须包括两个相同的数。

## 算法讨论

首先从开头开始分割，一出现两个相同的数就分出新的一段

由于每一个位置都是要分在一个段中，那么显然这样的方案最优

# Professor GukiZ and Two Arrays

## 题目大意

给定两个序列$a,b$，要求交换最多两个位置，求$|s_a-s_b|$的最小值
$$
n,m\leq 2000
$$


## 算法讨论

首先可以先枚举只做一次交换的位置

然后考虑交换两次的情况，可以对于其中一个序列来说，我们只关心其选择交换的位置，假设$a$中两个位置的和为$x$，$b$中两个位置的和为$y$

那么$s_a'=s_a-(x-y),s_b'=s_b+(x-y)$，假设一开始的序列和$s_a>s_b$

那么$x-y=\frac{s_a-s_b}{2}$时候$s_a',s_b'$最接近

那么只需要用set维护其中一个序列的$y$，找到$x-\frac{s_a-s_b}{2}$前驱后继即可

# New Year Tree

## 题目大意

- 给出一棵n个节点的树，根节点为1。每个节点上有一种颜色$c_i$。m次操作。操作有两种：
  1. `1 u c`：将以 u 为根的子树上的所有节点的颜色改为 c。
  2. `2 u`：询问以 u 为根的子树上的所有节点的颜色数量。

## 算法讨论

首先将这棵树的dfs序求出，然后相当于就变成了序列上的问题

由于颜色数量不多，我们可以用线段树维护区间内每一种颜色是否出现过，可以状压用long long存下

那么线段树需要支持区间赋值和区间或

# Ants in Leaves

## 题目大意

给定一棵 n 个节点的树，根节点是 1。这棵树的每一个叶节点都有一只小蚂蚁。每过 1 秒钟，可以选择让一些蚂蚁向父节点走一步。注意，两只蚂蚁不能同时在一个除去根节点的节点上。

问这些蚂蚁最少用多少秒的时间，使得所有蚂蚁都走到根节点。

## 算法讨论

首先对于每一个1的儿子子树单独进行考虑，显然答案为这些子树需要最少时间的max

考虑同一个深度的叶子节点，其必然可以在一个连续的时间段中到达根节点（这个时间段每一个时刻都有恰好一只蚂蚁走到根节点）

如果不考虑其他深度的蚂蚁，那么如果深度为$k$的有$cnt$只蚂蚁，这个时间段为$[k,k+cnt-1]$

显然每一个深度的时间段是不交的，那么我们从小到大考虑这个深度，然后维护一个最终时间t，一段的开头时间为$\max(t+1,de_i)$

# Optimal Number Permutation

## 题目大意

求一个序列，有n种数，每一种数只出现2次，两个出现位置的距离为$d_i$，要求构造一个序列最小化
$$
\sum\limits_{i=1}^n (n-i)|d_i+i-n|
$$

## 算法讨论

首先最小值为0，即$d_1=n,d_2=n-i,...,d_{n-1}=1$，然后$d_n$任意

那么可以将奇数排在前n个位置，然后偶数排在后面的位置，最终剩余的两个位置用n填充

类似1 3 5 .... 5 3 1 2 4 6... 6 4 2 n

# Bear and String Distance

## 题目大意

Limak是一只小北极熊。他喜欢单词——只由小写字母构成，长度为n的单词。

他规定dist(s,s')的值为s与s'在26个字母中的间距。如，dist(c,e)=dist(e,c)=2,dist(a,z)=dist(z,a)=25。

而且，当dist两个单词时，其值为dist第一个字母+dist第二个字母+…… 如，dist(af,db)=dist(a,d)+dist(f,b)=3+4=7,dist(bear,roar)=16+10+0+0=26。

现在，Limak给你一个字母或单词s和值k，令你寻找一个s'使dist(s,s')=k。输出s'。如果没有合适的s'，输出-1。

## 算法讨论

使前面的字母尽可能差距大，如果k减到0，那么就相同

# Magic Numbers

## 题目大意

1. $l≤x≤r$
2. x 的偶数位是 d，奇数位不是 d。 （这里定义偶数位为从高位往低位的数的偶数位）
3. m|x

### 算法讨论

考虑数位DP，设$f(x,y,0/1)$表示当前填到第x位数，当前数模m等于y，当前为奇数位数还是偶数位数

然后同时还需要记录当前是否顶格还是是否有前导0

然后得到当前位最大能填到多少数字，**枚举需要注意的如果当前从前导0变成不为0的数字，当前算是奇数位不能填d**

# Zbazi in Zeydabad

## 题目大意

给定一个$n\times m$的矩阵, 每个格点为'.'或'z'。

我们称一个子矩阵合法, 当且仅当这个矩阵为正方形, 且该矩阵的第一行和最后一行元素全部为'z', 从右上到左下的对角线上元素全部为'z', 其余位置元素随意。注意, 一个1×1的内容为'z'的矩阵是合法的。

## 算法讨论

首先枚举一个斜线，那么相当于z的两个右上左下端点都是在斜线的一个区间

考虑枚举其中一个端点，首先可以预处理出来最多向上延伸多长的距离，就是斜线上的连续z段，还有这个端点右边的连续z段的长度min

然后对于一个合法的右上端点，其向左延伸的距离至少为两个端点的列数差，那么可以用扫描线进行维护

# The Smallest String Concatenation

## 题目大意

给定n个字符串，要将这些字符串拼接起来，求能得到的最小字符串

## 算法讨论

首先定义比较函数为$cmp(a,b)=(a+b<b+a)$，可以发现这个形成了一个偏序集

直接按照这个排序即可

# Longest Subsequence

## 题目大意

给出n个数，要求选出尽可能多的数，满足它们的最小公倍数不大于m。允许数列里没数，此时这个数列的最小公倍数为1。

## 算法讨论

可以枚举其LCM，然后求出序列中为其因子的有多少个，取其中最大的数，如果有相同的情况，那么取最小的

显然这样就得到的最大可能LCM

至于求因子可以在调和级数的时间内完成

# Thief in a Shop

## 题目大意

有一个小偷进入了一个商店。

像平常一样，他把他的幸运背包带在身上，他的背包里能放 k 个东西。商店里有 n 种产品，每种产品都有无限多个。对于每个第 i 种产品，它的价值是 a[i] 。

小偷很贪婪，所以他会准确地拿 k 个产品（他有可能把某一种产品拿很多个）。

你需要找出所有小偷可能偷走的物品价值之和。

## Solution 2

首先每一种物品的代价都是最多只有10位，可以拆成两端进行考虑，相当于根号分治

设$f(i,j)$表示当前得到的数最低5位为$i$，通过加上$a$中一个数得到最高位为$j$的后五位情况，这个需要32位状压

然后bfs所有出$\sum a_i$范围内每一个数被得到的最小+操作次数，如果+操作次数>k，那么说明无法达到

bfs过程中枚举最高位变化情况$h\rightarrow h+i,i<2^5$，然后求出对应的所有低位情况，这里需要记忆化，如果当前高位的已经考虑过一些情况，那么就不需要再考虑了

那么这样的时间复杂度$O(n^2\log^2 n+n\sqrt n)$

[Submission #38390716 - Codeforces](https://codeforces.com/contest/632/submission/38390716)

## 算法讨论

假设一个多项式$f$，一个指数为一个随机数当序列a中出现了这个数，否则为0

那么答案就是$f^k$直接DFT即可

# Foe Pairs

## 题目大意

给定一个1到n数字组成的全排列，同时给定m元素$(a_i,b_i)$。 你的任务是统计有多少个不同的区间(x,y)($1 \le x \le y \le n$)，这些区间不包含任意一个给定的元素对，即不能同时含有元素对$(a_i,b_i)$的两个元素，这两个元素的先后顺序不限定。

## 算法讨论

当固定左端点的时候，合法的右端点显然是一段区间

那么只需要将所有二元组按照最左边的那个位置进行排序，从后往前进行扫描，那么可以发现这段区间就是最优左端点在这个位置右边最小的二元组右端点

取后缀MIN即可

# Nested Segments

## 题目大意

给定n个区间，求每一个区间包含了其他多少个区间

## 算法讨论

首先离散化，然后按照区间左端点排序，从后往前枚举，利用树状数组维护区间右端点，查询就是有小于当前去加右端点的右端点有多少个

# Pursuit For Artifacts

## 题目大意

- 给定一张 n 个点 m 条边的简单无向连通图，边有边权，边权要么为 0，要么为 1。
- 每条边只能通过一次（两个方向加起来只能通过一次）。
- 求是否存在一条从 a 到 b 的路径，满足路径上至少存在一条权为 1 的边。

## 算法讨论

首先边双连通分量缩点，那么可以得到一颗树，对于一个联通分量中存在1边的，将这个点设为1，那么相当于就是查询a所有联通分量与b所在连通分量直接是否存在1的边或者1的点

直接dfs即可

# Number of Parallelograms

## 题目大意

给定n个点，求形成多少个平行四边形
$$
n\leq 2000
$$

## 算法讨论

首先枚举两个点，然后计算其向量差，找到共线并且**长度相同**的向量即可

用map存即可

# Different Subsets For All Tuples

## 题目大意

有一个长度为$n$的数列，每个位置上数字的值在[1,m]范围内，则共有$m^n$种可能的数列。分别求出每个数列中本质不同的子序列个数（包含空序列），然后求和，答案对$10^9+7$取模（$1≤n,m≤10^6$）

## 算法讨论

首先对于所有子序列，求出有多少个序列出现过这个子序列

会发现两个子序列如果长度相同其本质是相同的，就是出现的序列个数相同

设$f(i,j)$表示当前匹配到第i个位置，子序列匹配到第j个位置的方案数
$$
f(i,j)=f(i-1,j-1)+(m-1)f(i-1,j)
$$
可以简单得出$f(n,i)=\binom{n}{i}(m-1)^{n-i}$

那么最终答案就是
$$
\sum\limits_{i=0}^m m^i(m^n-f(n,i))
$$

# Bear and Bowling 4

## 题目大意

给定一个序列，求出一个子序列，$a_1,a_2,...,a_m$

最大化$\sum\limits_{i=1}^m i\times a_i$

## 算法讨论

首先记$A_i=\sum\limits_{j=1}^i j\times a_j ,B_i=\sum\limits_{j=1}^i a_j$

那么一段区间的答案就是
$$
A_r+B_r-lB_r-A_{l-1}-(1-l)B_{l-1}
$$
那么对于一个固定的l，需要最大化$A_r+B_r-lB_r$

那么就以$(B_r,A_r+B_r)$作为点，求出上凸包即可

需要动态插入点，用set进行维护，**需要注意一下叉积判断的时候正负性，维护的是上凸包**

# Simple Subset

## 题目大意

给定一个序列，求出其中一个子集，使得子集中任意两个元素之和为质数

## 算法讨论

首先集合中不为1的个数不能超过两个，否则就会产生奇偶相同的数，其和为偶数，不为质数

那么将所有1求出，然后尽量加入1个其他元素，并且这个元素+1为质数

然后与是否能选出两个元素取集合最大的那个

# Beautiful Subarrays

## 题目大意

给定一个序列$a$，求出有多少个区间的xor大于等于k

## 算法讨论

首先枚举区间内的xor和在哪一位比k大，假设为第i位，其中k的第i位为0，那么说明前i位的xor和确定，后面的任意

那么相当于确定一个区间的xor和为多少，这个是方便计算，只需要记录xor前缀和，然后用hash表记录每一个数出现的次数即可

**需要手写hash表，直接用unordered_map速度不够**

# Four Divisors

## 题目大意

求出n以内的数只有4个因数的数个数
$$
n\leq 10^{11}
$$


## 算法讨论

只有四种因数的数，有两种形式，一种是由两个质数相乘得到，另外一种是某一个质数的三次方

其中第二种情况很好处理，直接枚举即可

然后考虑第一种情况，假设$k=p_1p_2$

可以发现$\min(p_1,p_2)\leq \sqrt n$

那么我们可以枚举这个最小值p，那么剩下的问题就是解决$1$到$\frac{n}{p}$中有多少个质数的问题，这是一个经典问题，可以用洲阁筛或者min25筛解决

当然需要设一个阈值，前面的用线性筛预处理，后面使用洲阁筛或者min25筛

# Iterated Linear Function

## 题目大意

设$f(x)=Ax+B,g^{(n)}(x)=f(g^{(n-1)}(x))$

求$g^{(n)}(x)\bmod 10^9+7$

## 算法讨论

手动展开几项可以发现
$$
g^{(n)}(x)=A^n x+B(A^{n-1}+A^{n-2}+...+A+1)=A^nx+B\frac{A^n-1}{A-1}
$$
需要注意的是，**如果$A=1$是不满足等比数列求和公式的，需要特殊处理**

# Another Sith Tournament

## 题目大意

你是一位骑士，与其他n-1个骑士决斗

幸运的是你知道任意骑士i击败骑士j的概率，你还被推选为组织委员。决斗一开始你需要任意选择两名骑士（包括自己）进行决斗，胜利方继续和你另外选择的一名骑士决斗，直到仅剩一人

你非常渴望取得胜利，想知道自己获胜最大概率是多少，注意你是1号。
$$
n\leq 18
$$


## 算法讨论

考虑进行状压DP，由于我们计算的最大获胜概率，就需要从后往前进行DP，**相当于一个DP状态是由之后的状态转移而来**

设$dp(mask,i)$表示当前已经比赛过的骑士集合为mask，当前留下的骑士为i状态之后1号获胜的最大概率
$$
dp(mask,i)=\max\limits_{j\notin mask} p_{i,j}dp(mask\cup \{j\},i)+p_{j,i}dp(mask\cup \{j\},j)
$$
初始状态为$dp(full,0)=1$

答案就是$\max dp(0,i)$

# Lena and Queries

## 题目大意

![20211026](D:\Blog\image\20211026.PNG)

## 算法讨论

首先所有修改操作都是对一段时间区间有影响

那么就可以考虑线段树分治，将所有要加的点加入到线段树上，然后在线段树上遍历的过程中维护一个凸包，然后到查询叶子节点的时候在凸包上二分即可

**需要注意将点加入凸包时候叉积的正负性，还有栈序撤销，一种方便的写法就是每一个都存一个副本，然后当dfs完一个儿子节点的时候，将当前的凸包替换成副本，但空间复杂度就变成了$O(n\log n)$**

时间复杂度$O(n\log ^2 n)$

# Swaps in Permutation

## 题目大意

给定一个排列p，和m对二元组$(a,b)$，每一个次可以选择一个二元组$(a,b)$，然后交换$p_a,p_b$

求可以得到字典序最大的排列

## 算法讨论

对于每一个位置建点，二元组之间建边

那么对于同一个联通块的点，上面的数都是可以任意排列的，那么只需要将原来上面的数降序排序即可

# Xor-sequences

## 题目大意

给定一个数集A，现在你需要构造一个长度为k的序列B，序列B的元素从数集A中任意挑选，要求B中任意相邻的两个数字的异或值二进制表示中1的个数是3的倍数，请问B的有多少种合法的构造方案？两种方案不同当且仅当存在Bi在A中的位置不同。
$$
n\leq 100
$$

## 算法讨论

考虑暴力的做法

每一次确定了一位之后，可以枚举下一位填什么，然后进行转移

显然每一个都是等价的，那么可以用矩阵进行优化

$O(n^2)$枚举两个相邻的数，看其异或和是否合法，如果合法，那么设为1

最初矩阵第一行为1即可

时间复杂度$O(n^3 \log k)$

# Road to Post Office

## 题目大意

Vasiliy 要从家到 d 千米远的警察局去，Vasiliy 有一辆车，但很破旧，每行驶 k 千米就要坏掉，需修复 t 秒才能重新启动，已知 Vasiliy 开车开 1 千米要 a 秒， 步行 1km要 b 秒（a < b）, Vasiliy 可以在任何一个时刻步行，请问 Vasiliy 最少要多少秒才能到达警察局。

## 算法讨论

假设开了x段，代价函数就是
$$
f(x)=\min(d,xk)a+\max(0,x-1)t+\max(d-xk,0)b
$$
显然去掉min,max就是一次函数，所以极值只会在$0,1,\lfloor \frac{d}{k}\rfloor,\lceil \frac{d}{k} \rceil$上取到

**一开始没有注意到min,max，wa了一次**

# Analysis of Pathes in Functional Graph

## 题目大意

有一个n个点n条边的带权有向图（点编号0~n-1），每个点有且仅有一条出边，对于每个点i求出由i出发经过k条边，这k条边的权值最小值和权值和。

## 算法讨论

直接倍增即可

# T-Shirts

## 题目大意

![20211026T2](D:\Blog\image\20211026T2.PNG)

## 算法讨论

首先将所有 T恤排序，然后对于所有的询问统一进行处理，显然单条进行处理没有什么优化的空间，那么就需要用一个可以支持快速区间操作的数据结构进行维护

我们需要用平衡树进行维护，以$v_i$作为关键字进行建树

当前的T恤价格为c的话，那么对于所有$v_i\geq c$的人，需要将$v_i-c$，然后计数器+1

由于$v_i-c$会破坏之间的相当大小关系，那么不能直接打标记

考虑只有$v_i\in [c,2c)$的人才会被破坏大小关系，注意到减c之后，$v_i$变小了至少一半，**那么说明在整个过程中$v_i\in [c,2c)$个数和不会超过$O(n\log n)$个**

那么我们可以将这一段区间的人，暴力从树中删除，然后将$v_i$减去c，然后再插入到平衡树中

而至于$v_i\in [2c,\infin)$的树，不会破坏相当于大小关系在，直接打标记修改即可

需要注意splay可能不支持树中存在两个权值相同的元素，但是一旦两个元素相同了，那么其之后的决策都是相同的，那么可以用带权并查集进行维护这个关系

时间复杂度$O(n\log ^2 n)$

### Solution 2

我们可以对于每一个顾客的钱数在值域上分成$\log V$个块，对于一个钱数为x的人，讲其放到编号为$\log x$的块内，然后对于每一个块都维护当前在这个块中的顾客集合以及钱数，还有一个全局加标记

对于当一个T恤的价格$c$，讨论一下有哪些人会走到下一个格子中，然后讲这些人暴力取出，然后插入到下一个块中

那么我们可以对于每一个块维护一个set实现即可，就不需要手写平衡树

# Two Arithmetic Progressions

## 题目大意

You are given two arithmetic progressions: *a*1*k* + *b*1 and *a*2*l* + *b*2. Find the number of integers *x* such that *L* ≤ *x* ≤ *R* and *x* = *a*1*k*' + *b*1 = *a*2*l*' + *b*2, for some integers *k*', *l*' ≥ 0.

## 算法讨论

首先列出等式
$$
a_1x+b_1=a_2y+b_2\\
a_1x-a_2y=b_2-b_1
$$
然后利用扩展欧几里得计算出一组特殊解

然后求出一组非负整数解，然后求出在范围内的数个数

# Generate a String

## 题目大意

![20211026T3](D:\Blog\image\20211026T3.PNG)

## 算法讨论

首先需要发现，由于我们可以删除字符，在获得特定长度的时候，可能需要先倍长，然后删除一个字符

可以发现的是，如果我们需要删除字符，那么最多只会连续删除一次

否则我们就可以将删除操作放到倍长操作之间，可以减少一次操作

那么设$f(n)$表示得到长度为n的字符串最小代价
$$
f(n)=\min(f(n-1),f(n/2)+x),\ n\bmod 2\equiv 0\\
f(n)=\min(f(n-1),f(n/2+1)+x+y),\ n\bmod 2 \equiv 1
$$

# String Set Queries

## 题目大意

![20211026T4](D:\Blog\image\20211026T4.PNG)

## 算法讨论

考虑进行二进制分组

我们可以对于这个字符串集合用线段树（一开始的大小就是$3*10^5$）进行维护，当加入一个字符串的时候，增加一个下标，然后在这位置上插入字符串

在线段树上的每一个节点上都维护当前区间有哪些字符串，一旦当前节点插入满之后，就将当前所有字符串建立AC自动机

那么查询就是相当于查询一个区间，当在一个AC自动机上查询出现的次数

需要注意的是如果一个节点插入满之后，需要将两个子节点的AC自动机清空，

时间复杂度$O(n\log n)$

### Solution 2

考虑进行根号分治，

对于集合中长度$\leq \sqrt n$的串，插入到Trie中，如果是加入，那么在最末尾的那个元素上+1,否则删除的话就是-1，当查询的时候枚举查询串的所有后缀，在Trie中匹配，每一次到一个新的节点的时候，就加上这个节点的权值即可，然后一旦访问到空节点，就退出循环，由于Trie的深度最大为$\sqrt n$，所以复杂度为$|S|\sqrt n$

然后对于$>\sqrt n$的串，预处理出来其kmp的前缀函数，然后当查询的时候暴力匹配即可，由于这样的串个数$\leq \sqrt n$，查询的复杂度也是$|S|\sqrt n$

那么总复杂度$O(n\sqrt n)$

# Maximum path

## 题目大意

你被给了一个3*n的矩形表格。每个小格含有一个整数。如果两个格子有共享的边，你可以从一个格子移到另一个格子。 找到如下从左上角的格子到右下角的格子的路径，这条路径不能重复参观同一个格子，并且路径中的格子中的数字的和应该是可能的最大值。

## 算法讨论

首先可以发现，只有中间那一行是可以反着走，首先先不管这个情况

我们一列一列进行DP，设$dp(i,1/2/3)$表示当前走到第i列，当前位置在第几行的最大可能值

直接转移就是很显然

然后需要考虑反着走的情况，显然最终停下的位置为1/3，假设最终停下的位置为1，那么起始位置就是3，也就是求出一个$j<i-1$，假设每一列数字和的前缀和为$b$，那么最大化$dp(j,1)-b_j$，然后进行转移

这个可以通过记录前缀MIN即可

**需要注意的是，如果从1走到3，最初起点位置就可以当作开始位置**

# Radio stations

## 题目大意

一共有 n 个电台，对于每个电台 i 有三个参数： $x_i, r_i, f_i$,分别指它的一维坐标、作用半径和频率。如果两个电台的频率差值在 k 内，并且它们的作用范围都能覆盖到彼此，那么就称这两个电台相互干扰。问这 n 个站台中相互干扰的站台有多少对。
$$
n\leq 10^5,k\leq 10
$$

## 算法讨论

首先可以直接暴力枚举$f_i,f_j$，然后对于两个对应的集合，统计满足前面的条件$\min(r_i,r_j)\leq |x_i-x_j|$的对数

那么首先对于所有集合的电台按照半径排序

然后枚举合法$i,j$中$r_i$较小的那个，然后用单指针维护出另一个位置的合法区间，同时用树状数组维护每一个位置，然后相当于是查询$[x_i-r_i,x_i+r_i]$中有多少个位置

可以先离散化然后树状数组直接维护

时间复杂度$O(nk\log n)$

# Tree nesting

## 题目大意

给定两棵树 S,T，求 S 有多少个连通子图与 T 同构。
$$
|S|\leq 2000,|T|\leq 12
$$

## 算法讨论

**首先钦定T中度数最大的节点为根**，有了这个后面的复杂度才有保证

然后我们枚举$S$选出子树的与这个根匹配的节点$x$，然后对于S中节点x子树分配$T$中根的子树，这个可以通过状压DP实现

然后我们相当于将问题转化为了询问以x为根，节点$y$的子树和$T$中节点z的子树匹配的方案数

由于有根的限制，那么我们用边来确定y子树的方向，$dp(id,op,z)$表示第$id$条边的op段位置为当前的子树，与T中节点z的匹配方案数

转移还是需要用一个状压DP辅助

直接转移就可以了，由于一开始我们选择最大的度数节点作为根，那么其儿子子树的最大度数不超过$12$，那么时间复杂度$O(|S||T|2^{|T|})$

# Paths in a Complete Binary Tree

## 题目大意

![20211027T1](D:\Blog\image\20211027T1.PNG)

## 算法讨论

首先一个节点的深度可以通过二进制表示下后缀0的个数来确定

可以发现走到左右儿子是加上或者减去一个关于深度有关的2次幂

直接模拟这个过程即可

# Colored Balls

## 题目大意

将n个数分解成若干组，如4 = 2+2， 7 = 2+2+3，保证所有组中数字之差<=1。

## 算法讨论

首先记$s=\sum\limits_{i=1}^n a_i$

假设当前分出来$x$组，那么其中$s\bmod x$个是$\lfloor \frac{s}{x}\rfloor +1$，然后$x-s\bmod x$个是$\lfloor \frac{s}{x}\rfloor$

考虑进行整除分块

假设当前相同的块区间为$[l,r]$为$d$

首先需要满足的条件是，对于所有的i来说，$a_i\bmod d\leq \lfloor \frac{a_i}{d}\rfloor $

那么记$A=\sum\limits_{i=1}^n \lfloor \frac{a_i}{d}\rfloor,B=\sum\limits_{i=1}^n a_i\bmod d$

其中A就是分成的组数，那么我们要最小化组数，那么可以将$\lfloor \frac{a_i}{d}\rfloor-k,a_i\bmod d+kd$

求出最多可以减少多少，然后求出其之和$C$

那么A最小可以是$A-C$判断一下是否在范围内，还需要判断$s\bmod A=B$是否满足，注意到$s\bmod A=s-Ad$，如果$A$减小k，那么有$s-(A-k)d=B+kd$其中$kd$抵消，那么只需要满足$s\bmod A=B$即可

时间复杂度$O(n\sqrt s)$

### Solution 2

首先假设分成了k个集合，集合的大小为$x,x+1$，那么显然有$\min(x,k)\leq \sqrt n$

那么我们可以分开进行枚举

对于枚举k个集合的情况，我们要检查是否可以通过集合大小 ![img](https://espresso.codeforces.com/9a5e3ce4d94df85a444226e04a945f2a7f90fe9a.png) and ![img](https://espresso.codeforces.com/62b812cfb692c41b4600f0c2a051f7c0f5b9711d.png)得到合法情况，也有可能是![img](https://espresso.codeforces.com/b121c27d67ea865bdb80253d559677097567f563.png) and ![img](https://espresso.codeforces.com/9a5e3ce4d94df85a444226e04a945f2a7f90fe9a.png).

当我们固定集合大小的时候，我们只需要检查$x\lceil \frac{a_i}{x+1}\rceil \leq a_i$是否成立即可

这样就不需要整除分块了

# Mages and Monsters

## 题目大意

![20211027T2](D:\Blog\image\20211027T2.PNG)

## 算法讨论

首先建立一个线段树，线段树的下标就是法术的伤害值

对于一个怪物来说，使用法术的伤害值至少为$\frac{h}{t}$，并且要满足$\frac{y}{x}h\leq m$，显然我们在这个后缀中最多只会使用一种法术，就是$\frac{y}{x}$最小的那个

这个可以用线段树很好的进行维护

**但是我们由于存在第一个限制，那么就有可能只用一个法术会破坏第二限制，因为伤害过高并且消耗的法术值过高，那么在这种情况我们在前面的前缀里面选择一个$\frac{y}{x}$最小的法术，来进行配合使用**

如果用两个法术都不行，那么说明一定不合法

使用两个法术我们可以先固定两个条件，然后最大化另外一个条件，手解一下线性规划即可

# Broken BST

## 题目大意

给一棵二叉搜索树,但是不保证这是一棵正确的二叉搜索树,那么按照二叉搜索树的搜索算法(小往左,大往右),可能找不到某些节点,你的任务是计算有多少节点将不会被遍历到.  

## 算法讨论

首先将所有的数按照数值排序，然后显然遍历到一个某一个节点的数都是一段区间

设$x$节点上遍历到的区间为$[l,r]$

那么二分出$[l,r]$$v_x$的分界点，然后如果存在等于$v_x$，那么在区间中删除这个数，然后分治到左右儿子即可，最终达到空节点还没有找到，那么说明这些数字代表的节点不会被正确遍历到

# Array Queries

## 题目大意

- 给定长度为 n 的序列 a。m 次询问。
- 每次询问给出 p,k。您要不断地执行操作 $p\gets p+a_p+k$，直到 p>n 为止。询问的答案为操作次数。

## 算法讨论

我们用记忆化搜索直接暴力解决这个问题

可以发现如果$k\leq \sqrt n$的话，至少需要$\sqrt n$个询问遍历到所有位置，如果$k\geq \sqrt n$的话，一次询问遍历到的节点数量不超过$\sqrt n$，**直接搜索空间可能存不下，那么需要离线处理，将k相同放在一起处理**

# Mice and Holes

## 题目大意

n个老鼠，m个洞，告诉你他们的一维坐标和m个洞的容量限制，问最小总距离。

## 算法讨论

首先将每一个洞和老鼠按照坐标排序，那么显然对于进同一个洞的老鼠形成的一定是一个区间

那么可以设$dp(i,j)$表示考虑前i个洞，已经确定j只老鼠的情况

设$s_i(j)=\sum\limits_{k=1} ^j |c_i-x_j|$
$$
dp(i,j)=\min\limits_{k=0} ^ {p_i} dp(i-1,j-k)+s_i(j)-s_i(j-k)
$$
直接用单调队列优化即可

时间复杂度$O(nm)$

# Roma and Poker

## 题目大意

![20211027T3](D:\Blog\image\20211027T3.PNG)

## 算法讨论

设$dp(i,j)$表示考虑到前i位，$W$与$L$出现次数差为j是否合法

转移枚举下一位填什么，注意不要达到$|j|=k$的情况，设一个偏移量即可

构造方案用DP出来的结果倒序构造即可

# Coprime Subsequences

## 题目大意

给你一个序列，问你有多少个子序列的gcd=1

## 算法讨论

$$
\begin{align}
&\sum\limits_{s\in T,s\neq \empty} [gcd(s)=1]\\
&=\sum\limits_{s\in T,s\neq \empty} \sum\limits_{d|gcd(s)} \mu(d)\\
&=\sum\limits_{d} \mu (d)\sum\limits_{s\in T,s\neq \empty }[\forall x\in s,s.t.\ d|x]\\
&=\sum\limits_{d}\mu (d)(2^{\sum\limits_{i\in T}[d|i]}-1)
\end{align}
$$

直接计算即可

时间复杂度$O(n\log n)$

# Periodic RMQ Problem

## 题目大意

![20211027T4](D:\Blog\image\20211027T4.PNG)

## 算法讨论

首先建出$nk$的动态开点线段树，然后对于区间操作进行动态开点，如果在pushdown 的过程中发现左右儿子为空，那么就新建节点

对于查询一段区间的最小值，如果当前区间不为空节点，那么就是这个节点上存的MIN数组

否则如果为空节点，那么需要讨论一下区间端点的位置，如果都在同一个周期内，那么直接rmq查询即可，否则如果在两个相邻的周期，相当于查询前缀后缀最大值，否则就整个序列的最小值

**注意在pushup的时候，如果左右节点为空节点，那么就按照空节点的最小值进行更新，不是不进行更新**

# Selling Souvenirs

## 题目大意

![20211027T5](D:\Blog\image\20211027T5.PNG)

## 算法讨论

首先只用3个重量，考虑将其中一个重量转化为另一个重量

那么就是将1转化为2，首先如果选取的是偶数个，那么从大到小排序之后，相邻的两个合并即可

如果为奇数个，那么将最大的取出，然后将相邻两个合并

然后枚举3选取了多少个，用前缀和记录2的情况即可

# Card Game

## 题目大意

![20211027T6](D:\Blog\image\20211027T6.PNG)

## 算法讨论

首先枚举答案，然后对于l在枚举范围内的节点，进行最小割

每一条边代表选或者不选，其中奇数和偶数要相反

**1需要特殊处理**，然后在形成质数的和之间让其不能同时选择即可

然后跑网络流即可，需要将负权边设置一个偏移量即可

# Anthem of Berland

## 题目大意

![20211027T7](D:\Blog\image\20211027T7.PNG)

## 算法讨论

设$dp(i,j)$表示s中考虑到第i个位置，然后kmp上匹配到t中第j个位置

我们预处理处理$to(i,j)$表示kmp上匹配到的t中第i个位置，下一位填j的最终情况

然后直接转移即可

# Four Melodies

## 题目大意

定义一个 Melody 子序列为，子序列中任意两个相邻元素差为 1 或模 7 同余，这里的子序列不要求连续。

给定一个长度为 n 的序列，求出一种选出 4 个互不相交的 Melody 子序列的方案，使得它们的并的大小尽量大。输出这个大小。

## 算法讨论

首先edu之前有一道题目[Problem - D - Codeforces](https://codeforces.com/contest/813/problem/D)

是拆分成两个序列，这个是可以直接DP解决，但是这道题是分成了四个序列，那么就无法这样进行

考虑一个子序列中某一个位置的下一个位置，可以到达的位置要么是跟当前的元素同余的元素要么相差1，并且这个位置一定在当前这个位置之后

如果我们将所有位置拆点，限制这个位置最多只能出现在一个子序列中，然后这个价值设为为1，然后建图完跑最大费用最大流得到答案

首先考虑其中一个条件“与当前元素同余”，我们可以开7个桶，每一个桶中记录互相同余的元素，按照位置进行排序，相当于我们连边的是当前这个序列的一个后缀

我们可以用前后缀优化建图

<img src="D:\Blog\image\graph-1619099890299.png" alt="graph" style="zoom: 50%;" />

注意我们连边的是用拆点的一段连向拆点的另外一端

对于相差为1的情况也是同理

然后我们还要限制最多只能拆成4个子序列，那么我们将源点拆点，中间的连边容量设为4，然后另一端连向所有位置的上端节点

# Army Creation

## 题目大意

n个数a[i],q次询问,$n,a[i],q\leq 10^5$. 每次问$[l,r]$内最多可以选多少个数,满足同一个数的出现次数不超过k?

## 算法讨论

如果在区间内某一个种数出现了大于k次，那么我们只统计最后k个位置

我们可以预处理出来对于所有位置i，求出最小的位置$b_i$，使得$[i,b_i]$出现了恰好$k$个$a_i$

那么原问题答案为统计有多少个$i\in [l,r],b_i>r$，那么可以使用线段树进行统计

# Bipartite Checking

## 题目大意

给你一个由n个顶点组成的无向图，最初在图中没有边。同时给你q次查询，每次查询时会向图中添加一个无向边或者删除一个无向边。 在每次查询之后，您必须检查结果图是否为二分图（在保证没有连接相同颜色的两个顶点的边的条件下，您可以将图的所有顶点绘制为两种颜色）

## 算法讨论

直接将一条边存在的时间段插入到线段树中，然后用并查集判断一张图是否为二分图，然后需要实现栈序撤销

# Imbalanced Array

## 题目大意

对于一个序列的所有子段，求出其极差和

## 算法讨论

等价于，每一个子段的最大值和减去每一个子段的最小值和

那么可以用单调栈求出一个位置左边第一个$\leq a_i$的数，右边第一个$<a_i$的位置，然后这两个位置并且跨过i的区间的最小值都是$a_i$

那么统计就是$a_i(i-l)(r-i)$，求和即可

对于最大值计算也是同理

# Choosing The Commander

## 题目大意

有Q次操作，每次操作有三种类型，分别是

> 1 $p_i$ 把 $p_i$ 加入集合 S
>
> 2 $p_i$ 把 $p_i$ 从集合 S 中删除
>
> 3 $p_i,l_i$ 表示查询集合中有多少个元素异或上 $p_i$ 后 小于 $l_i$

集合为可重集。

## 算法讨论

对于第三个操作，我们可以枚举$p_i\bigoplus p_j$是在哪一位上小于$l_i$的，那么显然这一位$l_i$为1，那么我们需要的二进制前缀异或和这一位为0，至于之后位的数都是不需要考虑

那么我们需要统计存在某一个二进制前缀的数个数，可以直接用字典树进行维护即可

# MEX Queries

## 题目大意

![20211029T1](D:\Blog\image\20211029T1.PNG)

## 算法讨论

首先对于所有询问的区间进行离散化，我们需要离散化四个位置$l,r,l-1,r+1$，**（需要注意l-1可能等于0，不能将其离散化进去）**

那么所有询问的答案一定在这些离散化的位置中

那么对于所有位置建一个线段树，然后每一个节点维护当前区间内没有在s中出现的个数，那么第1，2个操作都是区间覆盖，然后第三个操作就是翻转，注意需要将1，2种的标记也翻转

然后回答询问就是线段树上二分即可

# Card Game Again

## 题目大意

![20211029T2](D:\Blog\image\20211029T2.PNG)

## 算法讨论

首先将k质因数分解，那么显然对于k的每一个质因数$p_i$，假设其次数为$r_i$，那么区间内$p_i$出现次数$\geq r_i$

那么我们对于每一个位置求出最小的位置为k个质数，那么显然我们对于每一个质因数都求出这个位置，然后进行取min即可

那么对于一个质因数来说就是求出出现次数的前缀和，然后进行二分即可

# Level Generation

## 题目大意

![20211029T3](D:\Blog\image\20211029T3.PNG)

## 算法讨论

首先假设一开始的图有n-1个桥，相当于就是一个树，那么我们现在要加入尽可能多的边，但同时需要满足条件，假设我们将原来x个桥变成不是桥，加入了k条边

那么我们需要有以下条件成立
$$
2(n-1-x)\geq m=n-1+k\\
k\leq \frac{x(x-1)}{2}
$$
解出$k\leq \min(\frac{x(x-1)}{2},n-1-2x)$

那么我们就需要求出$\min(\frac{x(x-1)}{2},n-1-2x)$的最值

由于这两个函数一增一减，那么显然是在两者最接近的时候取到最值，那么我们二分出这个位置即可

# Minimal Labels

## 题目大意

![20211029T4](D:\Blog\image\20211029T4.PNG)

## 算法讨论

反向拓扑序，然后用大根堆替代原来的队列即可

# String Compression

## 算法讨论

给定一个串s，其中重复出现的子串可以压缩成 “数字+重复的子串” 的形式，数字算长度。

只重复一次的串也要压。

求压缩后的最小长度。

## 算法讨论

设$g(n)$表示n十进制表示下数字的个数

设$f(i)$表示当前压缩到第i个位置的最小长度，那么我们需要将$[i+1,j]$压缩成一段的最小代价

那么我们先固定i，然后将$t=s_{i+1...n}$，对t求出kmp的nxt数组，那么对于其中第j个位置，记$d=j-nxt_j$，假设$d|j$，那么其最小循环节就是$d$，那么相当于我们需要求出一个最优的$k$，使得$kd+g(\frac{j}{kd})$最小

注意到$g(\frac{j}{kd})\leq 4,d\geq 4$，那么我们只需要求出最小的8个k，进行处理即可

预处理所有数的因数即可

时间复杂度$O(8n^2)$

# Tree Queries

## 题目大意

![20211029T5](D:\Blog\image\20211029T5.PNG)

## 算法讨论

首先将第一次修改的黑点抓出来，作为树根，然后我们 dfs 一遍这棵树，记 $a_i$ 代表第 i 个点到根节点路径上最小的编号

之后对于每一次修改，显然对于修改点的子树里的点的答案是不会有变化的，如果不在子树内，那么第 j 个点的答案就要与修改点到根路径的最小编号取min，所以在每次修改后记录一个所有黑点最小的到根路径上的最小编号，对于每次查询只需要将这个值与本身这个点到根路径上最小值取 min 即可

# Vasya's Function

## 题目大意

要求计算$f(a,b)$，定义为
$$
f(a,0)=0\\
f(a,b)=1+f(a,b-gcd(a,b))
$$

## 算法讨论

可以发现的是，随着这个过程进行，$gcd(a,b)$是不降的，并且增加的位置最多只有$\log n$个，那么我们需要求出每一个分界点

首先假设一开始$gcd(a,b)=1$，当前$a,b$进行$k\geq 0$次操作之后，$gcd(a,b-k)\neq 1$，那么我们可以 将问题转化为$a'=\frac{a}{gcd(a,b-k)},b'=\frac{b-k}{gcd(a,b-k)}$的问题

那么我们只剩下求出最小的$k$，那么我们可以枚举每一个$d|a$，然后求出$b\bmod d$的最小值，其中$d\neq 1$

求出的最小值就是k

时间复杂度$O(\sqrt n\log n)$

# Prefix Sums

## 题目大意

有一个函数p(x),其中x是一个包含m个整数的数组。p(x)会返回一个长度为m+1的数组y，yi是x数组前i项的和。（0<=i<=m）

例如：x={1,1,1} y=p(x)={0,1,2,3}

现有一列数组A0,A1,A2,……其中A0中的数据会给你，而Ai=p(A(i-1))。有一个整数k，你要求出一个i,在Ai中的某个数大于等于k。

输入第一行是n,k,第二行是A0中的n个数。

要求输出最小的i。

## 算法讨论

首先我们只需要关系$A_i(n)$
$$
A_i(n)=\sum\limits_{j=1}^n  \binom{i+n-j}{i} A_j
$$
那么我们先二分答案，然后按照这个式子计算即可

注意中间可能会超过long long的范围，化乘为除即可

**需要注意的是如果判断组合数的话，需要预处理前缀0的个数，然后直接break**

# Functions On The Segments

## 题目大意

![20211029T6](D:\Blog\image\20211029T6.PNG)

## 算法讨论

对于x的分界点建出主席树，节点记录$a,b$分别表示a之前的系数和常数和

然后需要标记永久化，然后询问就是两个主席树作差即可

# Fire in the City

## 题目大意

有一个 n 行 m 列的网格。其中有 k+1 个格子着火了。每个时刻，火会蔓延至相邻的格子（八联通）。现在给出其中 k 个着火的格子，请确定第 k+1 格子，使得网格被烧完的用时最短。

你只需要输出最短用时。

## 算法讨论

首先我们可以二分答案，那么问题就变成是否存在一个边长为2mid+1的矩形覆盖所有，原来k个点形成的矩形所没有覆盖到的点

那么我们可以将所有矩形的四个端点进行离散化（需要将左右各一个位置同样进行离散化），然后相当于我们需要求出没有被覆盖x,y坐标的最大最小值，然后将这四个值作为端点判断这个矩形是否边长小于等于mid

具体实现的时候，我们对于x,y离散化的点建出矩形，然后暴力在里面修改，直接枚举求出没有被覆盖的点上述四个值即可

# Guards In The Storehouse

## 题目大意

给定一个 $n\times m$ 的网格，有些位置是障碍（`x`），有些位置是空地（`.`）。

可以在每一个空地处放一个摄像头，这个摄像头会向右，向下监视第一个障碍前的所有方格。现在你需要在空地上安排摄像头，使得最多 1 个空地没有被摄像头监视。输出方案数对 $10^9+7$ 取模。
$$
n,m\leq 250,nm\leq 250
$$


## 算法讨论

首先注意到$\min(n,m)\leq \sqrt {250}=15$

那么这个数据范围是支持指数级复杂度的

那么我们假设$n=\min(n,m)$

那么我们考虑枚举列，一列一列进行计算，但是这样状压DP转移复杂度会不对，那么我们像轮廓线DP一样进行考虑，一个一个格子的进行DP

设$dp(i,j,s,0/1,0/1)$表示当前已经DP到$(i,j)$，整个行的是否被监视的状态，已经这个列上面是否放置了摄像头，之前是否有点没有被监视到

那么我们枚举下一个位置的状态，枚举下一个位置放不放摄像头就可以被监视到，按照DP的定义进行转移即可

这样的是时间复杂度
$$
O(nm2^n)
$$

# Shortest Path Problem?

## 题目大意

给定一张 n个点 m 条边的无向图，一开始你在点 1，且价值为 0

每次你可以选择一个相邻的点，然后走过去，并将价值异或上该边权

如果在点 n，你可以选择结束游戏

求一种方案，使得结束游戏后价值最小

## 算法讨论

首先将原图的一个dfs树求出，那么树上的返祖边形成了所有环的一个基

我们考虑树上1到n的路径异或和，如果我们要经过某一个环的话，来回的路径权值抵消，直接异或上环的值即可

那么由于返祖边形成的环是所有环的基，那么我们将返祖边形成的环插入线性基，然后用初始路径的异或和求最小值即可

# Monitor

## 题目大意

Luba最近买了个显示器，这个显示器是一个n×m的矩形。但是不久之后她发现这个显示器上有些像素不正常工作（可能会成为坏点）。如果屏幕上有一块k*k的区域都是坏点，那么Luba就觉得这个显示器坏了。她知道有q个像素不正常，而且知道它们彻底罢工变成坏点的时间。

请告诉Luba显示器会不会坏掉，如果会请告诉她具体时间。

## 算法讨论

直接二分答案，然后check的时候进行二维前缀和，枚举每一个可能k*k的左上端点求出这个矩形内是否存在坏点即可

# Chemistry in Berland

## 题目大意

![20211104T1](D:\Blog\image\20211104T1.PNG)

## 算法讨论

首先将i连向$x_i$，那么形成的图一定是一个树

那么我们设$f(x)$表示x子树内还需要输入多少材料，或者可以提供多少材料

那么对于每一个树上的节点x，求出需要的材料重量A，以及需要的材料重量B

其中如果儿子节点需要材料，那么需要的数量需要乘上$k_i$

# Random Query

## 题目大意

![20211104T2](D:\Blog\image\20211104T2.PNG)

## 题目大意

从后往前扫描这个序列，同时维护每一个颜色第一次出现的位置pos，那么这个就可以贡献$n-pos+1$，过程中同时维护贡献和即可

需要注意的是对于$l\neq r$的情况是需要计算两次的

# Turn Off The TV

## 题目大意

Luba有n台电视,并且她知道每台电视的工作时间是从l到r.现在Luba想要关掉一些电视,使得播放电视节目的时间点不少于关掉这些电视之前.请你帮助Luba,告诉她可以关闭哪些电视,若任何一台都不能关闭,输出-1 输入: 第一行一个整数n(1<=n<=200000),表示电视台的数量 接下来n行每行两个整数li,ri,表示第i台电视工作的时间(0<=li,ri<=10^9) 输出: 若不能关闭任何一台电视,输出-1,否则,输出任何一台可以关闭的电视的编号(编号在1~n之间)

## 算法讨论

假设所有时刻工作电视的数量为$v_i$

那么一个可以关闭的电视需要满足
$$
\min\limits_{i=l}^r v_i\geq 2
$$
我们可以将所有区间的端点进行离散化，然后直接在r+1处-1，l处+1然后前缀和就可以求出v

[Submission #30584826 - Codeforces](https://codeforces.com/contest/863/submission/30584826)

# Almost Permutation

## 题目大意

![20211104T3](D:\Blog\image\20211104T3.PNG)

## 算法讨论

首先我们可以求出所有位置上的数可以填的范围$[l_i,r_i]$

然后我们考虑网络流建图，对于每一种数值我们单独建一个点$v(i)$，然后对于所有位置单独建出一个点$pos(i)$，然后建立源点汇点$s,t$

显然对于位置$pos_i$，$pos_i$向$t$连$(1,0)$的边

然后数值连向每一个可以取到的位置，边为$(inf,0)$

对于每一个数值其流量就是$cnt(i)$，那么我们进行差分建边，也就是拆边，拆成(1,1),(1,3),(1,5)....连即可

跑最小费用流即可

# Forbidden Indices

## 题目大意

![20211104T4](D:\Blog\image\20211104T4.PNG)

## 算法讨论

首先将这个字符串的sam建出，然后我们对于每一个完整的后缀节点的权值设为[不为禁止位置]，然后在后缀树上求出子树内权值和$cnt(x)$，那么这个节点中要求贡献的最大值为
$$
cnt(x)len(x)
$$
然后对于每一个节点求出这个贡献的最大值即可

# Awards For Contestants

## 题目大意

![20211104T5](D:\Blog\image\20211104T5.PNG)

## 算法讨论

首先我们将所有学生按照$a$升序排序，那么每一种文凭发放的学生都是形成了一个连续子段，并且文凭出现的顺序为1，2，3，-1

那么我们可以枚举1,2分界点和2,3分界点，这个方案的前两个价值就是求出分界点左右两个a的数量差，然后我们需要最大化这个三元组

那么我们预处理出来所有后缀的相邻两个元素的差的最大值，剩下的那个3,-1分界点显然就是取这个最大值的位置

# Merge Sort

## 题目大意

![20211104T6](D:\Blog\image\20211104T6.PNG)

## 算法讨论

由于mergesort调用次数一定为奇数，那么对于调用次数为偶数的都是输出-1

那么我们调用过程中交换$a_{mid},a_{mid+1}$即可使调用次数+2

# Boxes And Balls

## 题目大意

你有 n 个盒子和 n 种颜色的球，第 i 种颜色的球的数量是 $a_i$。

起初所有球都在第 1 个盒子里，你希望让所有第 i 种颜色的球都在第 i 个盒子里。

于是你打算进行一系列操作。每次操作可以取出某个盒子中的所有球，腾空该盒子，但要扣除等于取出球数的点数，然后分成 2 或 3 组，将每组放到一个空盒子中。

求达到目标最少需要扣除的点数。

## 算法讨论

首先我们将这个过程反过来，那么我们相当于每一个次可以合并三堆或者两堆石子，并且代价就是合并完得到石子堆的大小

显然如果在都可以使用的情况，使用合并三堆的操作更优

但是如果一开始的堆数等于偶数，最终会剩下两堆，可以发现在最开始使用一次合并两堆的操作更优，那么就可以转化为奇数的情况

那么模拟哈夫曼树的过程，用堆维护所有的石子即可

# Binary Matrix

## 题目大意

![20211104T7](D:\Blog\image\20211104T7.PNG)

## 算法讨论

首先题目的空间限制存不下储存整个矩形的数组

那么我们就需要读入一行处理一行，那么我们同时需要记录上一行的每一个格子的联通情况，我们可以用一个数字表示，如果1格子上的数字相同，那么这两个格子就是联通的

那么在新增一行的时候，上一行本来两个不连通的1，变得联通

那么具体的我们对上一行每一个数字维护并查集，对于当前这一行的极长连续1，我们将上一行在这一段的数字进行合并

最终的当前行的联通性根据并查集的结果表示

也可以重复使用空间，对于不用的字符就用队列存下，要开新的空间优先在队列中找

https://codeforces.com/contest/884/submission/31807388

# Anti-Palindromize

## 题目大意

![20211104T8](D:\Blog\image\20211104T8.PNG)

## 算法讨论

考虑进行网络流建图，就是我们对于每一个字母单独建一个点$ch(i)$，然后对于所有位置建一个点$pos(i)$，对于一对位置$(i,n-i+1)$也建一个点$f(i)$

那么$f(i)$连向$pos(i),pos(n-i+1)$边为$(1,0)$

然后对于每一个字母连向$f(i)$容量都为1，其中如果这个字母在两个位置出现过

- 如果都出现过，那么边权为$\max(b_i,b_{n-i+1})$
- 否则为出现的那个b

然后源点向每一个字母点连边，位置向汇点连边

![IMG_20211104_213924](D:\Blog\image\IMG_20211104_213924.jpg)

# Connecting Vertices

## 题目大意

![20211108T](D:\Blog\image\20211108T.PNG)

## 算法讨论

首先将环破成链，那么两个线段合法的条件就是在数轴上不是相交

那么相当于问题就变成有多少种方案在任意两个点连n-1条边使得图联通，并且两两不相交

设$dp(i,j)$表示区间的答案

那么枚举i连向的位置k，对于$[i,k]$中间的数需要用另一个DP枚举从哪个位置分开使得前缀与i相邻，后缀与k相邻

假设记作$f(i,k)$
$$
dp(i,j)=f(i,k)\times dp(k,j)
$$
时间复杂度$O(n^3)$

# Xor-MST

## 题目大意

给定一个完全图，i与j的边权为$a_i$异或$a_j$，求最小生成树

## 算法讨论

首先将所有数加入到Trie中

我们每一次需要找到两个还不在同一个联通块的节点之间最小的边，那么显然两个节点在trie上的LCA位置开始

由于trie相当于每一次将某一位上0，1集合分开，那么所有两两节点之间的LCA只有n-1个，恰好对应了MST中n-1条边

那么只需要在每一个可能的LCA中查询左右子树的异或最小值即可，我们枚举子树大小较小的那个子树，然后在另一个子树查询即可，这样就是启发式合并的复杂度

时间复杂度$O(n\log ^2n)$

# Credit Card

## 题目大意

Recenlty Luba有一张信用卡可用，一开始金额为0，每天早上可以去充任意数量的钱。到了晚上，银行会对信用卡进行一次操作，操作有三种操作。 1.如果a[i]>0，银行会给卡充入a[i]元。 2.如果a[i]<0 银行从卡中扣除a[i]元。 3.如果a[i]=0 银行会查询卡里的金额。 有两条规则，如果违背信用卡就会被冻结。 1.信用卡里的金额不能大于d。 2.当银行查询卡里的金额时，金额不能为负。 Recenlty Luba想知道最少去充多少次钱，可以使她在接下来的n天里信用卡不被冻结。

## 算法讨论

从前往后进行枚举，同时维护当前卡内最多可以存在的钱MAX和最小可以存在的钱MIN

对于$a_i=0$的情况来说，如果$MAX\geq 0$，那么令MIN与0取max，否则答案加1，将MAX设为d，MIN设为0

对于$a_i\neq 0$的情况，$MAX+a_i,MIN+a_i$，如果$MIN>d$，那么不合法，然后令MAX与d取min即可

最终输出答案

# Counting Arrays

## 题目大意

对于每组数据，给出x和y，求一个长度为y的序列，其乘积为x，允许有负数，求这种序列的个数，对1e9+7取模

## 算法讨论

首先将x进行质因数分解$x=p_1^{r_1}p_2^{r_2}...p_k^{r_k}$

对于每一个质因数进行考虑，对于一个质因数可以放到任意的盒子中
$$
\prod\limits_{i=1}^k \binom{y+r_i-1}{y}
$$
然后考虑正负号的问题，乘上$2^{y-1}$即可

# Subtree Minimum Query

## 题目大意

![20211108T2](D:\Blog\image\20211108T2.PNG)

## 算法讨论

首先将数的dfs序求出

那么每一次询问都是询问区间内小于等于d的最小值

那么我们可以用线段树进行维护，每一个节点都是区间内的所有数，并且按照权值排序，预处理前缀min，区间查询的时候，到达被查询区间完全包含的节点时候二分出对应位置，然后取前缀min即可

d等于查询的节点深度+k

# Swapping Characters

## 题目大意

给你 k个串，每个串长度都是 n，现在问你是否可能这些串是同一个串交换两个位置的字符所产生的，输出这个原串。

## 算法讨论

首先需要预处理出来1号串和其他串不同的位置，如果不同位置大于4，那么一定不合法

然后我们枚举1号串是交换哪两个位置，然后用得到的串去匹配后面的串，同样需要求出有哪些位置不同，显然就是预处理出来的位置加上交换的两个位置，才有可能不同

如果不同的位置>2也是不合法的，对于没有不同的位置来说，必须串中至少存在两个相同字符才可能成立

# Clear The Matrix

## 题目大意

给定一个4×n的元素只为'*'或'.'的矩阵f

你可以不断地选择一个f的子方阵,并将方阵的元素都变为'.'

选择一个k×k的方阵需要代价$a_k$。

问最少要多少代价,才能将所有元素都变为'.'

## 算法讨论

考虑将一列之前的4*4的矩形进行状压，状压的状态就是是否还是X，那么像轮廓线DP一样进行转移，枚举下一个格子，然后我们枚举这个格子替代的格子作为子矩阵左上角的长度

然后对于状压状态进行更新即可

需要注意的是在换新的一列的时候，需要重新对于这个状压的矩形进行标号

# Yet Another Maxflow Problem

## 题目大意

![20211108T3](D:\Blog\image\20211108T3.PNG)

## 算法讨论

首先最大流等于最小割，那么相当于我们要在图中删除若干边使得$A_1,B_n$不连通

首先A,B中最多只会删除一条边（显然，如果有两条边去掉其中靠后的边显然不影响）

假设是$x,y$

那么对于A,B之间的边$(i,j)$，如果$i\leq x,j\geq y$，那么$(i,j)$一定需要被删除，那么我们固定x，用线段树维护$y$的序列，然后对于所有起点在$x$的A,B之间的边，假设终点为j，那么相当于就是将j的前缀+边权

然后维护全局最小值即可

至于修改，由于只会修改A中的边，那么可以将预处理的答案存入数组，相当于单点修改数组中的某一位，然后求最小值，可以用set实现

# Stack Sorting

## 题目大意

给你一排列的一部分,让你补全整个排列使其字典序最大并且经过一个栈调整顺序之后能够顺序输出

## 算法讨论

首先将已经给出的部分加入栈中，然后同时如何栈顶元素可以弹出，那么尽量弹出

得到剩下的栈来说，栈顶元素肯定大于下一个需要弹出的元素，那么其中的数不能在前面出现过，否则就是不合法情况，然后将其中的数从大到小输出，然后弹出栈顶元素，将下一个需要弹出的元素设为栈顶元素+1，然后继续递归考虑即可

# Tree Destruction

## 题目大意

给你一棵树,每次挑选这棵树的两个叶子,加上他们之间的边数(距离),然后将其中一个点去掉,问你边数(距离)之和最大可以是多少.

## 算法讨论

首先一个点到另一个点的最大值是到两个直径端点

那么先预处理出来直径的两个端点，对于不在直径上的点，求出到两个直径的最大值，然后删除这个节点即可

然后对于直径上的点就是按照顺序删除即可

# Mass Change Queries

## 题目大意

给出一个数列,有q个操作,每种操作是把区间[l,r]中等于x的数改成y.输出q步操作完的数列.

## 算法讨论

考虑用线段树进行维护，每一个线段树节点都维护一个tag，表示每一个颜色经过修改之后会变成什么颜色，由于函数复合是满足结合律的，那么我们可以用tag进行延时下传

时间复杂度$O(n\log n 100)$

### Solution 2

考虑进行分块，对于每一个块每一个颜色都用一个list维护一个下标序列

对于修改，先考虑整块的修改

就是我们要将其中一个颜色的list拼接到另一个颜色的list中去即可，这个可以使用splice进行$O(1)$实现（就可以替代vector的启发式合并，时间复杂度少了一个log）

然后考虑对于散块的修改，那么直接在对应颜色x中找到在修改区间内的位置，暴力插入到y颜色对应的list中即可

时间复杂度$O(n\sqrt n)$

![20211108T8](D:\Blog\image\20211108T8.PNG)

# Physical Education Lessons

## 题目大意

![20211108T4](D:\Blog\image\20211108T4.PNG)

## 算法讨论

相当于我们需要支持区间赋值操作和区间和

直接用线段树维护即可

# Imbalance Value of a Tree

## 题目大意

![20211108T5](D:\Blog\image\20211108T5.PNG)

## 算法讨论

求出所有路径上的最大值-所有路径上的最小值就是答案

考虑将所有节点按照a从小到大排序

依次加入节点，然后用并查集维护联通块，那么当一个节点连接两个联通块的时候，所有路径节点分别在这两个联通块的路径中的最大值就是这个节点的权值

# Coprime Arrays

## 题目大意

![20211108T6](D:\Blog\image\20211108T6.PNG)

## 算法讨论

考虑进行莫比乌斯反演

对于长度为n，元素上限为i的答案为
$$
\sum\limits_{d\leq 1} \mu(d)(\lfloor \frac{i}{d}\rfloor )^n
$$
那么我们枚举d，然后在所有$i/d$相同的区间进行差分即可

时间复杂度$O(k\log k)$

# Connected Components?

## 题目大意

给出一个n 个点，$\frac{n(n-1)}{2}-m$条边的无向图，问图中有多少连通分量以及每个连通分量有多少点

输入中给出m对点，表示这一对点之间没有边，否则就是有边

输出连通分量的个数以及每个连通分量有多少个点
$$
n,m\leq 200000
$$

## 算法讨论

经典补图联通块的问题

考虑维护一个待选点集合，然后进行bfs，当进行扩展一个点的时候，在集合中找到这两个点之间右边的点，然后将这个点加入bfs中的队列，然后在待选点集合中删除

这样的复杂度就是$O(n+m)$，因为每一次扩展要么删除一个点要么就是这两个点之间有一条边

# SUM and REPLACE

## 题目大意

![20211109T1](D:\Blog\image\20211109T1.PNG)

## 算法讨论

首先将一个数$x$变成$d(x)$，不断递归下去，变成1或者2的次数就是$O(\log n)$的次数

然后可以用并查集维护哪些还没有变成**1,2(需要注意不只是1，2的因数个数也是2)**的数，然后一次区间修改就是区间内还没有变1,2的数暴力进行修改，然后在树状数组上单点修改即可

区间查询树状数组可以简单维护

时间复杂度$O(n\log ^2 n)$

### Solution 2

可以考虑用分块进行维护还需要修改的元素以及前缀和

对于整块修改就是，就是取出还没有变成1,2的进行暴力修改即可，如果已经变成了1,2那么从这个列表中删除即可

然后对于散块就是在范围内不等于1,2的暴力修改，如果变成了1，2那么在当前块的列表中删除即可

事实上不需要显式的维护这个列表，每次打标记即可

然后查询区间和分块可以简单维护

# List Of Integers

## 题目大意

t组询问，求第k个大于x且与p互质的数

## 算法讨论

首先我们可以二分答案，那么剩下的要求计算的就是区间内和某一个数互质的个数
$$
\begin{align}
&\sum\limits_{i=l}^r [\gcd(i,p)=1]\\
&=\sum\limits_{i=l}^r \sum\limits_{d|i,d|p}\mu(d)\\
&=\sum\limits_{d|p}\mu(d) \sum\limits_{i=l}^r [d|i]
\end{align}
$$
这个式子可以$O(\sigma (p))$的时间算出

那么时间复杂度就是$O(n\max \sigma(p)\log n)$，其中最大因数个数不超过400

# Max History

## 题目大意

我们定义f(a)为：

1、开始时，f(a)=0,M=1。

2、对于每个2<=i<=n,如果a[M]<a[i],那么f(a)=f(a)+a[M],M=i。

现在对于一个给定的数组a，求其所有排列的f(a)之和，答案对1e9+7取模。

## 算法讨论

其中$f(a)$最终就是等于所有不同的前缀最大值之和，然后减掉整个的最大值

其中最后那个可以先不管，考虑单独一个数的贡献

首先将所有数排序，假设钦定当前数i一定出现在前缀最大值中，那么所有$\geq i$的数都是出现在第i个数之后，加色和与$a_i$相同的数有$cnt$个，那么放在最前面的数有cnt种方法，然后考虑插入$<i$的数，方案就是$n^{\underline{i-1}}$

那么总贡献就是
$$
a_i\times  cnt\times (n-i-1)!\times n^{\underline{i-1}}
$$
然后总方案数减去$\max a_i n!$即可

# Erasing Substrings

## 题目大意

![20211109T2](D:\Blog\image\20211109T2.PNG)

## 算法讨论

考虑一个暴力DP，设$dp(i,s)$表示考虑到第i个位置，其中已经使用的次数为s的最小字典序串

考虑下一个位置是进行删除还是加入到剩下的字符串中
$$
dp(i,s)+s_{i+1}\rightarrow dp(i+1,s)\\
dp(i,s)\rightarrow dp(i+2^j,s+2^j),j\notin s
$$
由于DP的值就是字符串还需要比较大小，那么时间复杂度$O(n^3)$

考虑优化，显然在转移中有很多不必要的转移，就是字符串前面已经小于最优解了，还需要不断转移，那么我们考虑求出每一位的最小字符，然后只有状态中字符串最后一位为这个最小字符才可以进行转移

那么DP值只需要记录最后一个字符即可，转移的时候需要枚举$k=i-s$，k从小到大进行枚举

时间复杂度$O(n^2)$

# Shortest Path Queries

## 题目大意

![20211109T3](D:\Blog\image\20211109T3.PNG)

## 算法讨论

首先我们可以通过对于加入删除的边进行线段树分治，使得修改操作只有加边

然后当固定一个图的时候求两个点之间最短路，就是一个经典问题，之前edu也有一样的题目，用线性基维护一个生成树上树边和一条非树边形成环异或和，然后求出u,v在树上的距离，然后用这个距离在线性基中求出最小值即可

那么我们在加边的时候需要动态维护图的一颗生成树，那么就需要并查集，同时我们还需要求出树上任意两点之间的异或和距离，那么就需要带权并查集

具体的，我们对于每一个点维护一个数字$d_x$，表示子树内所有点走到根的时候必须要异或上$d_x$，那么求出一个点到根的距离就是将到根路径上的所有$d$异或起来即可，记作$f(x)$

当我们要在u,v之间连一条边的时候

- 假设u,v在同一个联通块中，那么向线性基中加入$f(u)$异或$f(v)$异或边权的值
- 否则假设u,v的根分别为$x,y$，那么需要将x放到y的儿子中，那么需要将$d_x$异或（$f(u)$异或$f(v)$异或边权的值），然后合并

并查集需要实现栈序撤销，那么需要按秩合并，在线段树上的过程中同时维护一个线性基即可

时间复杂度$O(n\log ^2 n)$

# Largest Beautiful Number

## 题目大意

如果一个正整数在十进制表示法下，不含前导零，有偶数个数字，并且对于它的所有数字来说，有一种排列方式使得这些数字组成一个回文数，那么这个数就是“美丽数”。例如4242是一个美丽数，因为它含有4个数字，这4个数字可以组成一个回文数2442。

给定一个正整数s，求严格小于s的最大美丽数。

## 算法讨论

**首先将输入的数-1**

一个数字为美丽的条件就是每一种数字出现了偶数次

然后我们考虑从高位开始枚举当前位的数字，数字需要从大到小进行枚举

然后考虑如何快速判定是否合法，我们尽可能要让后面的数字小，那么将所有不为0并且前面出现次数为奇数的数放在最后面，中间全部放0

直接一位一位判断过去时间复杂度是n^2的，需要优化，我们可以预处理出来每一个位置之后第一个不等于0的位置nxt，假设当前前面已经填了m位，最后不为0的个数为s，

首先判断掉s=0和**已经不顶格的情况**

然后如果$nxt_{m+1}$在0上那么一定合法，否则暴力判断最后不为0的数是否小于等于原来的限制

那么总的时间复杂度就是$O(10^2n)$

# Fibonacci String Subsequences

## 题目大意

![20211109T4](D:\Blog\image\20211109T4.PNG)

## 算法讨论

首先考虑一个出现次数的贡献，那么我们在$F(x)$中找到一个与s相同的子序列，假设其最小的位置为$l$，最大的位置为$r$，那么贡献就是$2^{l-1+N-r}$

考虑设$dp(x,l,r)$在$F(x)$中匹配$s_{l...r}$的贡献之和

对于$l=1$的情况那么有贡献$dp(x-2,l,r)2^{f(x-1)}$，否则就是$dp(x-2,l,r)$

对于$r=n$的情况也是同理

对于其他的情况
$$
dp(x,l,r)=\sum\limits_{k=l}^{r-1} dp(x-1,l,k)\times dp(x-2,k+1,r)
$$
时间复杂度$O(n^4)$

# Almost Increasing Array

## 题目大意

定义一个序列A是Almost Increasing的，当A满足从A中去掉一个位置之后剩下的序列形成了一个严格递增序列。 给出一个长度为n*n*的序列，问最小需要改动多少个位置的值，使得这个序列变成Almost Increasing的。

## 算法讨论

首先不考虑可以删除一个元素的情况，就是将这个序列变成严格上升的序列需要的最小修改位置

我们考虑求出最大需要保留的位置，对于两个需要保留的位置$i,j$之间必须进行修改，并且填入的数在$[a_i,a_j]$区间内并且互补相同

那么要求$a_i-i\geq a_j-j$，令$b_i=a_i-i$，那么需要最小修改的位置就是b序列的最长不下降子序列

这个可以直接DP+树状数组算

然后考虑加入可以删除的一个位置，DP过程基本不变，**但需要注意的是如果删除的位置两个保留的位置之间的话，那么对于$b_j$下标是需要-1，那么对应着$b_j+1$，这里需要特殊判断一下**

然后删除的元素也可以放在保留序列的开头和结尾

时间复杂度$O(n\log n)$

# Castle Defense

## 题目大意

![20211109T5](D:\Blog\image\20211109T5.PNG)

## 算法讨论

首先二分答案mid，然后先求出在不增加弓箭手的情况下每一个墙被多少弓箭手覆盖$b_i$

从小到大扫描，如果$b_i<mid$，由于之间都墙都是$\geq mid$，那么直接在右边2r的墙都加上$mid-b_i$即可，可以用差分实现

时间复杂度$O(n\log n)$

#  Path Counting

## 题目大意

![20211109T6](D:\Blog\image\20211109T6.PNG)

## 算法讨论

我们考虑枚举所有路径的LCA进行统计

考虑动态维护一个数组$f(j)$表示子树内长度为j的路径数量

当枚举的深度减1的时候，$f(j)$的下标需要加2，并且数值乘$a_i^2$，然后还需要考虑新多出来的那一次的路径贡献，然后统计的答案的是还需要乘上这一层有多少个节点

然后还需要统计单个节点就是当前层节点延伸下去的路径

都是可以在$O(n)$的时间内统计

总时间复杂度$O(n^2)$

# Yet Another String Matching Problem

## 题目大意

![20211109T7](D:\Blog\image\20211109T7.PNG)

## 算法讨论

首先考虑如何求出两个字符串之间的距离，我们可以在$s_i$与$t_i$之间连一条边，对于其中一个联通块来说，我们可以找到这个一个生成树，然后全部定为根的方向，起点代表变换的字符终点代表目标字符，那么这样就可以将这个联通块内的所有字符变成相同的

那么答案就是6-联通块个数

然后我们考虑枚举所有联通的情况，也就是枚举划分数，将6个字符划分成若干集合，然后对于这样的一组方案，在S，T中替换成字符所在的集合编号，然后对于子串可以匹配的位置的答案取当前需要操作次数的min即可

划分的方案数是贝尔数$B_6=203$

时间复杂度$O(|S|B_6)$

# k-substrings

## 题目大意

![20211109T8](D:\Blog\image\20211109T8.PNG)

## 算法讨论

一开始想了一个在后缀树上有根树点分治，然后求出任意两个后缀的lcs，依次判定border的最大奇数，这样时间复杂度是$O(n\log ^2n )$而且很难写，写完发现要写有根树点分治。。。

假设k子串的答案为$f(k)$，可以发现的是，当k+1的时候，对于$f(k)-2$的border是一定存在的，画一下图就可以发现，这个相当于就是$f(k)$的border去掉第一个字符和最后一个字符的情况，这样前缀和后缀是一定相等的

那么我们就有$f(k+1)\geq f(k)-2$，那么如果直接暴力枚举的话就需要找到最后一个位置，然后不在枚举下去复杂度才是对的，但这样无法判断当前是否要停止复杂度就是错的

如果$f(k)\leq f(k+1)+2$，那么相当于找到第一个合法和border即可

那么从k大往小枚举，首先将$f(k)=f(k+1)+2$，然后不断减小$f(k)$,直到找到一个合法的border可以用hash实现（不能用自然溢出，需要双模hash）

这样势能还是随着位置的减小最多增加2，时间复杂度就是$O(n)$

### Solution 2

首先我们将原来串翻转隔位插入到原来串里面

比如原来的串为ABCAB，翻转后为BACBA然后隔位插入ABBACCABBA

可以发现的是对于原来串的一个border相当于得到新的串的一个回文串

那么我们可以先用manacher或者z函数求出每一个位置的回文半径，需要注意的是这里只取长度为偶数并且中心在偶数位置的回文串

然后利用单调栈去除被完全包含的回文串，那么得到的序列左端点一定递增，右端点也随之递增

按照左端点枚举这些回文串来更新答案，在回文串范围内的border都是可以被更新到的，就是$[l_i,\min(r_i,l_i)]$区间内的位置都是更新为$r_i-j$即可

# Partitions

## 题目大意

![20211109T9](D:\Blog\image\20211109T9.PNG)

## 算法讨论

首先考虑一个物品的贡献，枚举包含这个物品集合的大小
$$
\sum\limits_{j=1}^n w_i\times  j\binom{n-1}{j-1}\left\{\begin{matrix}n-j\\k-1\end{matrix}\right\}
$$

然后提出$w_i$，剩下的部分与i无关，将第二类斯特林数展开
$$
\begin{align}
&\sum\limits_{j=1}^n j\binom{n-1}{j-1}\left\{\begin{matrix}n-j\\k-1\end{matrix}\right\}\\
&=\sum\limits_{j=1}^n j\binom{n-1}{j-1}\frac{1}{(k-1)!}\sum\limits_{i=0}^{k-1} (-1)^i\binom{k-1}{i}(k-1-i)^{n-j}\\
&=\frac{1}{(k-1)!}\sum\limits_{i=0}^{k-1}(-1)^i\binom{k-1}{i}\sum\limits_{j=1}^n j\binom{n-1}{j-1}(k-1-i)^{n-j}
\end{align}
$$
其中可以使用吸收使得凑出二项式定理的形式
$$
j\binom{n-1}{j-1}=(n-1)\binom{n-2}{j-2}+\binom{n-1}{j-1}
$$
那么最终式子为
$$
\frac{1}{(k-1)!}\sum\limits_{i=0}^{k-1}(-1)^i\binom{k-1}{i}((n-1)(k-i)^{n-2}+(k-i)^{n-1})
$$
直接计算即可，最终乘上$\sum w_i$

# Byteland, Berland and Disputed Cities

## 题目大意

![20211117T1](D:\Blog\image\20211117T1.PNG)

## 算法讨论

首先R,B之间不可能连边，其他情况都是有可能的

首先可以发现将相邻的两个P,R连一条边，然后相邻的P,B连一条边

可以发现这样一定是满足题目条件的，并且没有使用多余的边

然后还有P,P之间连边

可以发现这样的话，对于两个P,P之间的PB,PR连边可以分别去掉一条，那么显然去掉的边就是边权最大的那一条，那么在这两种情况中取代价较小的那一个即可

# Simple Cycles Edges

## 题目大意

![20211117T2](D:\Blog\image\20211117T2.PNG)

## 算法讨论

首先将图按照点双连通分量缩点

如果某一个连通分量中点数等于边数的话，那么说明这些边只会被当前这个连通分量的环包含，那么说明只被一个简单环包含

那么相当于我们需要求出每一个连通分量内部的边数，需要注意的是不能枚举连通分量中的每一个点，然后枚举连出的边，这是由于一个点可能在多个连通分量中，在枚举边的时候可能枚举到其他连通分量的边，复杂度就是$O(n^2)$

那么我们需要在tarjan缩点的过程中计算一个联通分量中的边数

用栈维护访问到的边，记录这条边的走过的方向，那么当到达一个连通分量在dfs的根的时候，不断将当前栈中的边弹出，直到栈顶的边是当前点在dfs树上的父亲走过来的边位置，那么所有弹出的边都是属于当前双连通分量的（与用栈维护点是相同的）

然后栈中可能一条边会重复出现，需要去重，然后与双连通分量中的点数比较，如果相同，那么将这些边加入答案中即可

# Visible Black Areas

## 题目大意

给定一个多边形，保证多边形的边都是平行于坐标轴的，然后给定一个矩形，求这个多边形交矩形形成了多少个联通的区域

## 算法讨论

首先我们考虑从左到右进行扫描线，可以发现的是一旦出现了一条竖的线段，那么多边形在当前扫描线的交集在当前线段上进行异或，原来在多边形内部的变成外部，原来是外部的变成内部

然后如果我们将所有与y轴平行的线段按照逆时针遍历顺序进行标方向，可以发现对于从上到下的线段都是讲多边形外部的点变成内部的点

那么考虑用set维护这些分界点（这些分界点需要在矩形的上下范围之内），如果需要插入一条线段的话，那么是将两个端点插入set，如果set中已经存在这个点的话，那么需要将这个点从set中删除，否则就加入

如果加入了一条从上到下的线段，并且使得原来set里面分成的段数减少，那么说明当前一定是将某两个联通块合并，如果是增加说明增加了一个新的联通块

然后从左到右扫描线，直到扫描到矩形左边界，这时候我们知道左边界是分成了$|s|/2$段（其中|s|是set的大小，由于是相邻的两个位置配对形成一段，那么set中一定是存在偶数个元素）

那么在扫描之后的时候，就需要更新联通块的数量，在扫描之前的时候我们只是维护set的集合关系，而不记录联通块的数量

然后扫描到矩形右边界前面一个位置停止

时间复杂度$O(n\log n)$

# Degree Set

## 题目大意

![20211117T3](D:\Blog\image\20211117T3.PNG)

## 算法讨论

首先肯定是要递归的进行构造

那么我们需要先满足$d_n$的限制，那么当前图中至少存在一个点使得这个点与其他所有点相连，并且删除这些点之后，假设这些点的数量为k，，剩下点的度数为$k$，那么剩下点的数量要等于$d_{n-1}-k+1$

直接将剩下的所有作为下一步递归的点数可能是没有整数解k的

那么我们需要删除一部分点，那么如果$k=d_1$的，那么相当于剩下的点度数都是$d_1$，有一部分点不包含到下一步构造是没有关系的

我们只需要保留其中$d_{n-1}-d_1+1$个点即可

那么问题就转化为$d_2-d_1,...,d_{n-1}-d_1$的问题了

# Well played!

## 题目大意

![20211117T4](D:\Blog\image\20211117T4.PNG)

## 算法讨论

显然对于所有的第一种操作只会使用在一个位置上面

而对于第二种操作，我们维护前b大的$\max(0,x_i-y_i)$，然后将这前b大的数求和加上$\sum y_i$显然就是最优解

那么就枚举第一个操作使用的位置，然后如果当前位置是在前b大出现过，那么直接更新前b大的和即可

否则就找出前b大中最小的那一个，然后替换即可

时间复杂度$O(n\log n)$

# Minimal k-covering

## 题目大意

![20211117T5](D:\Blog\image\20211117T5.PNG)

## 算法讨论

肯定与网络流相关，那么对于限制$\geq k$比较难处理

那么就转化为不选的边度数$\leq dg_i-k$即可

那么当固定$k$的时候，源点向左部点连容量为$dg_i-k$的边，然后中间进行二分图连边，然后右部点向汇点连$dg_i-k$的边即可

然后跑二分图最大匹配，也就是最大流

然后不选的边都是在最大流中满流的边

然后由于需要对于所有的k求出，那么从大往小枚举k，然后不断增加源点，汇点连出边的容量，然后在残量网络上进行跑最大流即可

![graph (2)](D:\Blog\image\graph (2)-16371217549201.png)

# Pencils and Boxes

## 题目大意

![20211117F1](D:\Blog\image\20211117F1.PNG)

## 算法讨论

首先将这个序列进行排序，那么显然一组内的数都是在一个区间内的

那么可以处理处理从一个位置最多往前多少个为同一组是合法的$pre_i$

那么设$dp(i)$表示考虑到第i个数的时候是否存在分组方法
$$
dp(i)=\bigcup\limits_{j=pre_i}^{i-k+1} dp(j)
$$
用前缀和优化即可

# Isomorphic Strings

## 题目大意

![20211117F2](D:\Blog\image\20211117F2.PNG)

## 算法讨论

首先枚举26个字母，将$s'_i=[s_i=c]$，然后将$s_i$进行hash

查询的时候将两个区间的所有26种字符串的hash值求出

由于可以将字母任意进行替换，那么我们只需要关系位置相同的等价类集合是否相同即可

那么将所有这26种字符串的hash排序，如果组成的集合相同，那么说明可以匹配

时间复杂度$O(26n)$

# Team Players

## 题目大意

![20211117F3](D:\Blog\image\20211117F3.PNG)

## 算法讨论

考虑容斥，对三元组内部存在的边进行容斥

首先对于没有强制存在边的情况，就是考虑每一个位置的贡献即可

然后对于存在一条边的情况，对于输出的所有边，除这条边的两个端点之外的那个点的是在端点之间还是端点两侧，进行分类讨论，计算贡献

对于存在两条边的情况，那么就是枚举其中度数等于2的那个点的位置，然后相当于将连出的边分成了两个区间，剩下两个点落在这两个区间，还是分类讨论计算贡献即可

然后对于存在三条边的情况，那么相当于在原图上求出三元环，那么度数大的点向度数小的点连边，然后暴力枚举即可

时间复杂度$O(n\sqrt m)$

# Flow Control

## 题目大意

![20211117F4](D:\Blog\image\20211117F4.PNG)

## 算法讨论

首先$\sum s_i=0$，如果这个条件不满足，那么显然不合法

然后对于树来说，如果满足$\sum s_i=0$的条件的话，是一定有解的，那么就是从下往上的进行构造，将子树内的所有点的条件都满足，计算出当前点新的$s_i$
$$
s_x=s_x+\sum \limits_{u} s_u
$$
那么我们在原图中求出一棵生成树即可，然后按照树的方式进行构造，然后对于其他边都设为0即可

# GCD Counting

## 题目大意

![20211117F5](D:\Blog\image\20211117F5.PNG)

## 算法讨论

记$g(x)$表示$(x,y)$代表的gcd恰好为x的方案数

记$f(x)=\sum\limits_{d\geq 1}g(xd)$

那么显然$f(x)$就是$x,y$只经过可以被x整除的点的路径数量

如果可以计算$f(x)$

那么$g(x)=f(x)-\sum\limits_{d\geq 2} g(xd)$

那么枚举$x$，求出所有可以被x整除的点，然后求出所有联通块的贡献和即可

由于每一个点最多会被枚举到$\sigma(a_i)$次

那么复杂度为$O(n\max \sigma(V))$

# We Need More Bosses

## 题目大意

![20211204T1](D:\Blog\image\20211204T1.PNG)

## 算法讨论

首先从s到t所有必须经过的边一定是原图中的桥

那么我们可以将这个图进行边双缩点，对于以边双为节点的树来说，那么相当于就是求出树上两个点最大距离

那么就是树的直径，通过两遍dfs求出即可

# One Occurrence

## 题目大意

![20211204T2](D:\Blog\image\20211204T2.PNG)

## 算法讨论

考虑对于每一个位置上的数$a_i$处理出来最大的$p_i=j$，满足$a_i=a_j$，如果不存在这样的$j$，那么$p_i=0$，对于之后的后继也是同样处理，记作$s_i$

那么某一个数在区间只出现一次的条件就是$p_i<l\and s_i>r$

那么对于第二个条件，我们可以通过将所有询问离线，然后按照右端点进行排序即可，我们只需要关心区间内每一种数最后一个出现的位置即可

那么我们从小到大枚举所有询问的右端点，考虑在扫描过程中维护一个线段树，维护每一种数最后一个位置的最小$s_i$

那么在新增一个数的时候，将$s_i$位置上的贡献撤销，然后加入当前$i$的贡献，就是将线段树中$i$的值设为$s_i$，然后对于一个询问$[l,r]$，只需要查询$[l,r]$中的最小值即可，然后输出最小值对应的数字即可

时间复杂度$O(n\log n)$，空间复杂度$O(n)$

# Two-Paths

## 题目大意

![20211204T3](D:\Blog\image\20211204T3.PNG)

## 算法讨论

考虑对于询问两个点$u,v$

可以发现，对于任意一个2-path中树上u到v的简单路径上的边都是只会被经过一次的，其他边都是经过两次，并且所有边都是联通的

那么对于u,v简单路径上的贡献是确定的，只需要求出LCA用树上前缀和差分就可以求出贡献

主要是对于经过两次的边，可以发现对于挂在u，v简单路径上的子树，相当于是求出一个包含根的最大子树和

这里每一个点的权值设为该点的点权减去两倍的该点到父亲边权的两倍，$a_i-2w_{i\rightarrow fa_i}$

那么可以设$f(x)$表示包含x的最大子树和
$$
f(x)=a_i-2w_{i\rightarrow fa_i}+\sum \limits_{u\in son(x)} \max(0,f(u))
$$
那么考虑在询问过程中如何快速求出，所有挂在u，v路径上的子树$f(x)$的和

考虑对于整个树进行树剖，然后对于每一个点维护其所有儿子子树（除去重儿子）的$f(x)$和，然后求出前缀和

在u，v查询LCA的时候，只需要在重链上查询一段区间和，然后特殊处理跳轻边的贡献即可

然后需要特别注意的是，对于LCA的情况，是存在一个向上的子树的，那么我们需要用换根DP处理所有节点这个向上子树的贡献

换根DP比较简单，都是加法撤销比较方便

那么时间复杂度$O(n\log n)$

## Solution 2

可以发现上面这个做法难以处理的部分就是求出挂在u，v简单路径上的子树和

这个是可以通过简单容斥，变成可以用树上前缀和处理的东西（事实上如果不容斥也是可以直接通过倍增维护）

考虑一个节点x以及其父亲$fa_x$的贡献，记$s_x=\sum\limits_{u\in son(x)}\max(0,f(u))$

那么这两个点的贡献贡献就是$s(x)-f(son(x))+s(fa(x))-f(x)=(s(x)-f(x))+...$，对于这个链上所有贡献可以通过移项变成只与一个节点有关的贡献

可以发现的是，我们可以预处理处理$s(x)-f(x)$的树上前缀和，只需要单独处理端点和LCA的情况即可

如果配合上tarjan求lca可以做到时间复杂度$O(n)$

tarjan求LCA做法[Submission #39730030 - Codeforces](https://codeforces.com/contest/1000/submission/39730030)

倍增做法 [Submission #39822773 - Codeforces](https://codeforces.com/contest/1000/submission/39822773)

# Intercity Travelling

## 题目大意

![20211204T4](D:\Blog\image\20211204T4.PNG)

## 算法讨论

设$f(i)$表示考虑到第i个位置的所有情况的代价和，然后考虑枚举上一个休息站离现在i有多远，记$s_i=\sum\limits_{j\leq i}a_j$
$$
f(i)=s_i+\sum\limits_{j=1}^{i-1}f(i-j)+2^{i-j-1}s_j=s_i+\sum\limits_{j=1}^{i-1}f(j)+2^{i-1}\sum\limits_{j=1}^{i-1} \frac{s_j}{2^{j}}
$$
记$g(i)=\sum\limits_{j=1}^{i-1} f(j),h(i)=\sum\limits_{j=1}^{i}\frac{s_j}{2^j}$
$$
g(i)=2g(i-1)+s_i+h(i)
$$
直接递推即可

答案为$g(n)-g(n- 1)$

# Dominant Indices

## 题目大意

![20211204T5](D:\Blog\image\20211204T5.PNG)

## 题目大意

考虑预处理处理$f(i,k)$表示i子树中深度为k的点个数

由于这个$f(i,k)$第二维只跟子树内的最大**深度**有关，那么考虑用长链剖分进行维护

我们先递归处理处理重儿子的信息，直接继承上来用vector存起来，然后再递归其他轻儿子的信息，然后进行暴力合并即可

再合并过程中同时需要维护vector中的最大值，以及对应的深度即可

时间复杂度$O(n)$

# Allowed Letters

## 题目大意

![20211204T6](D:\Blog\image\20211204T6.PNG)

## 题目大意

首先考虑贪心，从前往后从小往大枚举字符

然后剩下的就是需要快速判断之后字符串是否是合法的

考虑建立二分图，对于所有字符建立左部点，对于所有位置都建立一个右部点即可

然后位置上可以放置的字符进行连边，然后求出二分图最大匹配，如果存在完美匹配，那么说明合法

注意到字符的种类只有8个，我们可以暴力按照Hall定理的内容进行判定

那么我们需要求出对于任何一个字符集合s，至少存在一个字符可以填到这个位置上的位置数量

假设位置i可以填的集合为$s_i$，那么对于所有的$s_i\subseteq t$令$f(t)+1$，然后假设当前枚举的集合为s那么需要满足
$$
\sum\limits_{i\in s} cnt_i\leq n-f(\{a,b,c,d,e,f\}\bigoplus  s)
$$
然后在确定一位之后，需要将$cnt$和$f$进行更新即可

时间复杂度$O(2^6n)$

https://codeforces.com/contest/1009/submission/40539383

# Rest In The Shades

## 题目大意

![20211206T1](D:\Blog\image\20211206T1.PNG)

## 算法讨论

首先对于每一个点来说，将光源移动的线段投影到x轴上

根据相似比，其左端点为$\frac{|sy|x+ya}{|sy|+y}$右端点同理

然后在给定的x轴线段上二分，利用前缀和求出区间内的长度，然后讨论一下两端的相交情况即可

时间复杂度$O(q\log n)$

# Road Projects

## 题目大意

![20211206T2](D:\Blog\image\20211206T2.PNG)

## 算法讨论

首先将1到n在树上的路径写成一条链

每一个链上的节点都存在一棵子树，那么我们需要加的边对原来的最短路影响最小

那么如果其中一个子树中除去链上的节点超过了两个，那么加入的边就可以 将这两个点连接起来，并不会影响最短路

那么现在需要考虑的情况就是链上每一个节点最多下挂一个节点，那么我们需要在所有连边方式中找到[加上的边的边权]-[去除链上的边权]最大的那个即可，假设记作$MAX$，那么答案就是$dis+\min(0,MAX+x)$

- 如果连接的节点是两个链上的节点，那么显然中间的边数最多为2，
- 如果连接的节点一个是链上的节点一个是下挂的节点，那么下挂的那个节点对应的链上节点和连接的节点是相邻的
- 如果都是下挂节点，那么这两个下挂节点之间不能存在其他链节点存在下挂节点

然后我们可以维护一个链上边权的前缀和，即可求出所有情况的答案



# Appropriate Team

## 题目大意

![20211206T3](D:\Blog\image\20211206T3.PNG)

## 算法讨论

首先如果$x$无法整除$y$，那么一定是不合法的

那么考虑将$y$分解质因数，记作$p_1,p_2,...,p_k$

因为$x|y$，那么x的所有质因数都是在$p_1,...,p_k$之中

将一个数$num$的质因数分解情况记作$r_i(num)$，那么我们有$r_i(x)\leq r_i(y)$，并且所有合法的$a_i,a_j$需要满足$x|a_i,a_j|y$

考虑其中的一个质因数$p_k$

对于$r_k(a_i),r_k(a_j)$与$r_k(x),r_k(y)$的大小关系讨论（根据上面的条件，一定有$r_k(a_i)\geq r_k(x),r_k(a_j)\leq r_k(y)$，那么每一个只需要讨论2种情况，总共4种情况）

可以发现，当$r_k(a_i)>r_k(x)\and r_k(a_j)<r_k(y)$的情况下，需要满足$r_k(x)=r_k(y)$，其中情况都是只需要满足$r_k(x)\leq r_k(y)$的即可

对于每一个位置进行状态压缩（所有可能的质因数不会超过20个），对于x来说，第i表示$r_k(a_i)>r_k(x)$的情况，y来说，第i位表示$r_k(a_j)<r_k(y)$的情况

记作$b_i,c_i$，那么对于b,c的桶进行AND卷积即可（可以通过fwt实现，或者将a取反进行高维前缀和）

那么对于AND卷积之后的结果查看其状态中1的位置是否符合条件即可



然后剩下的就是如何进行分解质因数，显然可以进行Pollard_Rho做到$O(m^{\frac{1}{3}})$，但是注意到这道题有一个特殊的地方就是如果一个质因数没有在任何一个$a_i$中出现，那么这个质因数是不用进行考虑的

那么如果在分解y的时候，我们先将$\leq 10^6$的质因数分解掉，然后剩下的情况就是$p^2,pq$其中$p^2$的情况直接处理即可

如果是$pq$的情况，那么对于所有$a_i$进行gcd，如果$\neq 1,y$，那么就找到了p,q

这样时间复杂度$O(m^{\frac{1}{3}}+n\log m+k2^k)$

非Pollard_Rho做法[Submission #125397889 - Codeforces](https://codeforces.com/contest/1016/submission/125397889)

# Inverse Coloring

## 题目大意

![20211206T4](D:\Blog\image\20211206T4.PNG)

## 算法讨论

如果确定了正方形的最上面的行的情况还有最左边的列的情况，那么可以确定整个正方形的情况

可以发现的是，如果将最上面的行将所有相邻的相同的极长段缩起来，然后将列上相邻的段缩起来，那么这个正方形中最大的同色矩形就是最长两个极长段组成的

那么设$dp(i,j)$表示当前极长段长度和为$i$，最长的为j的方案数

直接背包转移即可

答案为
$$
\sum\limits_{ij<k} dp(n,i)\times dp(n,j)
$$
时间复杂度$O(n^3)$

# Session in BSU

## 题目大意

现在有$n$场考试，有两个考试时间$a_i,b_i$，一个考试时间只能考一门，求最小结束考试时间

## 算法讨论

如果将$a_i,b_i$连一条边，那么对于每一条边都要确定一个端点，然后每一个端点最多只能被一条边选中

对于一个联通块有如下情况

- 如果点数<边数，那么一定不合法
- 如果点数=边数，那么所有都可以选
- 如果点数-1=边数，那么可以去掉其中一个最大的时间

那么时间复杂度$O(n)$

# X-mouse in the Campus

## 题目大意

求对于$ax^k$模m意义下的环个数

$(x,m)=1$

## 算法讨论

如果$(x,m)=1$，对于最终得到的图是形成了若干个环

**对于同一个环来说其环上所有数与$m$的gcd是相同的，并且对于gcd相同的环来说，环的大小也是相同的**

证明如下，假设其$(a,m)=g$

那么$g|ax^k-pm$，那么显然$g|(ax^k\bmod m,m)$，而g是最大的因数

假设$a=gA,b=gB$其中$(A,m)=(B,m)=1$，那么$A,B$一定存在逆元

假设$gAx^k\equiv gA$那么可以推出$gx^k=g$，那么$gBx^k=gB$



那么我们可以枚举gcd等于d

对于gcd=d的数有
$$
\sum\limits_{i}[\gcd(\frac{m}{d},i)=1]=\varphi (\frac{m}{d})
$$
然后求出最小的$f(\frac{m}{d})=k$使得$x^k\equiv 1(\bmod \frac{m}{d})$

那么答案就是
$$
\sum\limits_{d|m} \frac{\varphi(d)}{f(d)}
$$
其中$f(d)$可以，对于$A=\varphi(d)$进行分解质因数，然后对于一个质因数，不断将$A/p$，查看是否合法，如果合法，那么$A'=A/p$即可

那么剩下的就是如何求出$\varphi(d)$的值和其质因数

我们可以求出$m$的所有质因数，由于计算$\varphi(d)$过程中，需要枚举所有d的质因数p，然后进行$\frac{p-1}{p}$相乘，那么我们可以处理处理m所有质因数中p-1的所有质因数即可

那么时间复杂度$O(\sqrt m+d(m)\log ^2m)$



# Covered Points

## 题目大意

![20211208T1](D:\Blog\image\20211208T1.PNG)

## 算法讨论

首先考虑将线段一条一条加入，假设两个端点为$A_i,B_i$，求出$D_i=B_i-A_i$的两维的最简整数比

那么从A开始走多少次能到达B就是AB之间的整点数量

然后需要求出这条线段与之前线段在整数点的交点，然后在贡献中去除这个点即可

直接用直线相交的方法求出交点，然后判断如果不是整数点，那么返回，如果不在线段上返回（可以定义点的比较方法，就是先比较x轴然后比较y轴，那么在两个点之间的点一定在两个点之间的范围内）

由于需要去重那么时间复杂度$O(n^2\log n)$

# Relatively Prime Powers

## 题目大意

![20211208T2](D:\Blog\image\20211208T2.PNG)

## 算法讨论

首先可以发现的是一个数$n$不合法的条件就是存在$x,k\neq 1$使得$x^k=n$

那么如果$k\geq 3$那么n最大为$10^6$我们可以暴力预处理出来所有不合法的数字，存在一个vector里面

然后接下来考虑$k=2$的情况，我们可以预先处理出来所有$n\leq 10^6$的答案，那么只需要考虑$n>10^6$的答案

可以发现一个$k=2$的情况是唯一对应着一个合法的$x$，那么如果记2-n之间的好数个数为$f(n)$，那么$k=2$的情况就有$f(\sqrt n)$个

那么不断递归下去即可

# Sources and Sinks

## 题目大意

![20211208T3](D:\Blog\image\20211208T3.PNG)

## 题目大意

首先将任意一个s可以到达的t集合求出

如果源点的数量不等于汇点的数量，那么显然是不合法的，因为多余的源点/汇点一定不在其他的联通分量之中

一种暴力的做法就是枚举所有的匹配情况，然后用之前s可达t的信息建出一个40个点的图，然后进行强连通缩点，这样时间复杂度为$O(k^22^k)$，稍加卡常应该可以过去

然后这个看上去很像一个匹配问题

首先考虑如果图中存在两个联通分量的情况，集合分别为A,B，可以发现的是两个集合中至少存在一个集合中的所有汇点都是连向这个集合中的源点的，否则如果两个集合都存在汇点连向其他集合的源点，那么显然整个图都是一个连通分量与假设矛盾

对于源点的情况也是同理，很显然这个结论可以适用于多个联通分量的情况

那么我们可以枚举源点的集合，求出从这个集合出发可以到达的所有汇点，一旦这些汇点都是连向源点集合，那么就形成了一个独立的连通分量（需要保证源点集合不为全集）

时间复杂度$O(k2^k)$

# Vasya and Big Integers

## 题目大意

给定一个一个数$a$，现在要将a的十进制表示划分成若干段，对于一个段来说不能存在前导0，并且一段的数大小要在$[l,r]$区间中

求划分方案数
$$
a\leq 10^{10^6}
$$

## 算法讨论

首先考虑一个DP，设$dp(i)$表示当前最后一段划分的结尾在$i$的方案数

考虑$dp(i)$可以更新到哪些位置

首先如果$a_{i+1}$等于0的话，那么直接返回，如果$l=0$那么可以将$dp(i+1)$加上$dp(i)$

然后假设$l$的长度为$L$，$r$的长度为$R$

那么从$dp(i)$可能转移到的范围是$[i+L,i+R]$，

- 如果$L=R$，那么能转移的位置只有一个$i+L$，只需要判断a第$[i+1,i+L]$形成的数字是否在$[l,r]$，那么我们可以通过Hash+二分求出一个区间与l,r的LCP长度，那么我们就可以在$O(\log \log a)$的时间判断两个数的大小
- 如果$L\neq R$，那么对于$(i+L,i+R)$是一定可以转移到的，对于$i+L,i+R$这两个位置需要特殊判断一下，判断方式跟上面类似

那么相当于一个$dp(i)$可以转移到一个区间，那么我们可以树状数组进行维护

这样的时间复杂度$O(\log a\log \log a)$

其中求LCP可以将两个串拼接起来，然后预处理出Z函数即可，然后对于区间修改，可以用差分进行维护，因为并不会修改已经确定的位置

这样的时间复杂度是$O(\log a)$的

https://codeforces.com/contest/1051/submission/67662031

# The Shortest Statement

## 题目大意

给你一个有n个点,m条边的无向连通图。有q次询问，第i次询问回答从$u_i$到$d_i$的最短路的长度。保证图联通
$$
m-n\leq 20
$$

## 算法讨论

首先注意到边数不会超过点数太多，那么图就是在一个树的基础上加入不超过20条非树边

那么我们先求出这张图的一个生成树，那么如果我们不经过这些非树边，那么显然距离就是两个点在树上的距离，可以通过求LCA求得

而如果我们经过了非树边，那么我们一定经过某一个非树边的一个端点，这样的特殊点最多有$40$个，假设我们经过的点为x

那么所有经过非树边的路径长度的最小值是
$$
\min \limits_x dis_{x,s}+dis_{x,t}
$$
那么我们可以用dij预处理出来所有$dis_x$

时间复杂度$O((m-n) n\log n+q(\log n+m-n))$

### Solution 2

首先对于原图的生成树中，被非树边覆盖的联通块，单独拎出来考虑

对于其他部分连到这个联通块上的边，显然连接的点的度数是$\geq 3$，那么显然这样的点是$O(m-n)$级别的，对于联通块中其他的点都是度数$=2$，相当于是只存在一个环上

那么我们处理所有$\geq 3$的点之间的最短路，由于其他的点度数都是$=2$，那么我们可以暴力走过这些点，求出从一个特殊点走到另一个特殊点的路径的距离即可，这样复杂度是对的，因为=2度数的点只会被正反走过两遍

最后在特殊点之间用floyd进行处理出最短路

那么询问的时候如果在树上，那么之间询问树上路径距离

否则需要通过联通块中度数$\geq 3$的点走到另一个点去，然后需要处理出来路径上经过的所有特殊点，然后枚举起点和终点，求出最短距离，

时间复杂度$O(n\log n+(m-n)^3+q((m-n)^2+\log n))$

如果$n,q$同阶的话，跟Solution1的复杂度一样（常数小一些），但是细节多了很多，只有在n比较大的时候才有优势

# Distinctification

## 题目大意

假设$S$包含k个二元组$(a_i,b_i)$

我们可以进行若干次操作，一次操作中

- 选择一个$a_i$，如果存在$j\neq i$，满足$a_i=a_j$，那么将$a_i+1$，代价$b_i$
- 选择一个$a_i$，如果存在$j\neq i$，满足$a_i=a_j+1$，那么将$a_i-1$，代价$-b_i$

记$f(S)$表示最小代价，使得S中所有二元组的$a_i$不同

现在给定T，求S等于每一个前缀的时候$f(S)$
$$
n\leq 2\times 10^5
$$

## 算法讨论

首先需要考虑一个固定的S如何求出答案

首先可以发现的是，对于将每一个二元组按照a放到数轴上，对于连续的一段来说，放置的点数可能超过这个段的长度，根据操作性质，可以发现我们在不借助其他段的情况下，只能将多出的数向后填充

但是我们可能存在多个段，那么一个段将所有数放到唯一的位置上之后，可能会跟其他段重合，那么这两个段就可以合并

那么我们对于一个联通块，我们知道联通块中所有位置不能超过联通块中最小的位置，并且最终得到的位置一定形成了一个连续的段

接下来考虑最小代价，首先可以发现的我们可以交换相邻的两个数，并且如果前一个数的$b_i$小于后一个数的$b_j$，那么我们经过交换这两个位置之后，总代价是可以减少的，反之是增加的

那么显然最终最优状态就是所有二元组按照$b_i$降序排列，否则一定可以交换某两个相邻的位置使得代价变得更小

那么我们考虑向S中加入一个新的二元组如何更新答案，我们可以用map维护每一个联通块的最左端点位置，以及这个联通块的内部的二元组数量，然后对于每一个联通块，用线段树维护每一个$b_i$出现的次数以及出现b的和

在合并两个联通块的时候，可以用线段树合并更新答案，相当于我们在归并两个有序数组，那么在线段树合并的过程中需要记录代表右边那个联通块的线段树的后缀和以及数量

还有一个问题就是如果加入的二元组是在联通块内部的，那么我们可以先将这个二元组移到这个联通块的最后同时更新答案，然后按照上面的过程进行线段树合并

时间复杂度$O(n\log n)$

# Up and Down the Tree

## 题目大意

![20211220T1](D:\Blog\image\20211220T1.PNG)

## 算法讨论

首先我们需要预处理出来，树上每一个节点存在多少个叶子节点到这个点的距离$\leq k$，记作$sum(x)$，有多少个叶子节点到这个点的距离$=k$，记作$cnt(x)$

可以发现的是，如果我们从x的节点跳入$u$儿子子树内的一个叶子节点，并且$sum(u)-cnt(u)=0$，那么也就是意味着u子树内不存在到x节点等于k的叶子节点，那么我们一旦进入u子树，那么就不可能从u子树中出来

那么我们可以设$dp(x,0/1)$表示当前所在位置在x子树内并且需要满足最终是否可以跳出x这个子树时最大访问叶子节点数量，其中1表示还要出来，0表示不再出来

那么显然我们有转移，其中$dp(x,0)$的转移就是考虑，我们进入的所有子树都是需要可以跳出来的，然后$dp(x,1)$就是我们在经过其他可以跳出来的子树之后进入一个不再跳出来的子树即可
$$
dp(x,0)=\sum\limits_{u\in son(x)} [sum(u)-cnt(u)\neq 0] dp(u,0)\\
dp(x,1)=\max\limits_{u\in son(x)} (dp(u,1)+\sum\limits_{v\in son(x),v\neq u} [sum(v)-cnt(v)\neq 0] dp(v,0))
$$
其中我们可以维护先预处理$\sum\limits_{u\in son(x)} [sum(u)-cnt(u)\neq 0] dp(u,0)$的值，就是可以做到$O(son(x))$的转移

那么时间复杂度$O(n)$

# Fibonacci Suffix

## 题目大意

![20211220T2](D:\Blog\image\20211220T2.PNG)

## 算法讨论

首先由于所有后缀都是按照字典序排序，那么相当于我们在比较的时候是不断比较一个前缀，而后缀的前缀就是原来串的一个子串

那么我们可以枚举这个前缀（每一次先往后添加0，如果大于k，那么就变成1），那么求出有多少个后缀含有这个前缀，那么相当于就是在$F(n)$中求当前这个枚举的字符串出现了多少次

假设当前枚举的字符串在$F(n)$中出现了$f_n$次，首先如果$|F(n)|\leq m$，那么我们可以直接进行字符串匹配，求出在字符串中出现了多少次

否则对于$|F(n)|>m$的情况，我们预处理出来$F(n)$的长度为m的前缀和长度为m的后缀

那么考虑左右两个字符串，那么有$f_n=f_{n-1}+f_{n-2}$，但是这个字符串可能出现在$F(n-2),F(n-1)$之间，那么利用预处理的前缀和后缀，通过字符串匹配求出出现次数

以$F(n-2)$的前缀$pre$为例，假设当前的字符串为$s$，那么相当于我们要求哪些长度s的前缀可以作为$pre$的后缀出现

那么我们可以利用Z函数求出这个值，我们构造字符串$t=s+'?'+pre$，然后求出这个字符串的Z函数，那么枚举pre函数的位置，如果$|t|-i=z_i$，那么说明长度为$z_i$的前缀是可以作为$pre$的后缀出现的

所有的操作都是可以在$O(m)$的时间内完成

那么总的时间复杂度$O(nm^2)$

**这个时间复杂度还可以进一步优化**，就是注意到在$|F(i)|>m$的情况下$pre_i=pre_{i-2},suc_i=suc_{i-1}$

而我们使用的进行匹配的是$pre_{i-1},suc_{i-2}$，可以发现是存在一个长度为2的循环节，那么相当于我们只需要对于匹配进行计算$O(1)$即可，而不是$O(n)$

这样的时间复杂度就是$O((n+m)m)$的，可以发现的是我们在计算匹配的过程中复杂度只会与$m$有关，而在总复杂度中的n就是递推计算$f$的复杂度，那么显然$f$是可以矩阵乘法快速的求出来的，那么时间复杂度就可以优化到$O((\log n+m)m)$

https://codeforces.com/blog/entry/62411?#comment-463687

$O((n+m)m)$代码 https://codeforces.com/contest/1065/submission/44225229

# Yet Another LCP Problem

## 题目大意

![20211224T1](D:\Blog\image\20211224T1.PNG)

## 算法讨论

首先将整个串翻转，那么后缀就变成了前缀，相当于求两个前缀的LCS长度

那么可以对于这个串建出sam，那么两个串对应着的节点的LCA的length就是这两个前缀的LCS长度

那么现在给出集合，那么我们求出这些前缀代表的节点在后缀树上的虚树，那么对于任意两个集合中的节点的LCA都是在虚树上

那么dfs遍历整个虚树，然后在每一个节点维护子树内在a集合中出现次数，b集合出现次数，然后将LCA为当前节点的点对数量乘上当前节点的length贡献到答案即可

时间复杂度$O(n\log n)$，瓶颈在于求LCA

# Choosing Two Paths

## 题目大意

![20211224T2](D:\Blog\image\20211224T2.PNG)

## 算法讨论

首先最终最优解中两个链一定是有公共部分的

那么两条链的公共部分一定还是一条链，假设其端点为$a,b$，那么这个条链是合法的当且仅当a,b度数至少为3，由于在公共的部分的最长的前提下，需要总链长最长

那么需要在a,b的儿子子树中选取两个最深和次深的子树

首先考虑如何求出最长的公共部分，那么我们可以先保留树中度数$\geq 3$的节点，然后求出直径即可，需要注意这里直径的两个端点可能有多个，那么需要选取其中最深深度+次深深度最大的两个端点即可

至于求最深深度和次深深度可以在dfs过程中简单维护处理

时间复杂度$O(n)$

# Petya and Graph

## 题目大意

定义图权 == 图中边权总和 -− 图中点权总和（空图的图权 = 0=0），求 n 个点 m 条边的无向图最大权子图。

## 算法讨论

首先对于每一条边建一个节点，然后连向这条边两端的节点，那么就变成了求最大权闭合子图

建立源点和汇点，源点向所有正权边连点权大小容量的边，所有负权边向汇点连负点权大小容量的边

然后求出最小割即可，用最大流实现

# Array Game

## 题目大意

![20211224T4](D:\Blog\image\20211224T4.PNG)

## 算法讨论

首先如果物品离开了当前格子，那么就无法再回来，那么在当前位置不断进行操作目的就是转化先后手顺序，那么与$a_i$的具体大小没有关系，只与其奇偶性有关

注意到m很小，那么假设我们已经知道当前这个位置之后m个位置，从这些位置出发先手是否必胜结果

那么如果后面m个位置存在某一个位置满足从这个位置出现先手必败，那么这个位置的人一定会直接走到那个位置使得另一个人输掉

如果所有位置都是先手必胜，那么当前位置的先手只会在当前位置消耗步数，不会主动走到后面的位置，那么如果当前的数-1为奇数，也就是当前的数为偶数，那么先手可以耗到另一个为先手的时候不得不走到后面的位置，那么此时先手必胜，否则先手必败

那么相当于我们知道后面m个位置是否存在先手必败和当前位置的奇偶性，就可以确定当前位置先手是否必胜，那么这相当于一个映射

首先可以发现每m个位置中最多有一个先手必败的位置，那么总共可能状态数就是$m+1$，将这些可能状态的集合记作$S$

那么我们在线段树上每一个节点维护一个映射$f:S\rightarrow S$，假设当前的区间为$[l,r]$，那么f的意义就是我们已知$[r+1,r+m]$的状态的话，经过f的映射之后求出$[l,l+m-1]$的映射

那么pushup的时候，将左右儿子的映射进行复合即可，假设左儿子的映射为$f$，右儿子的映射为$g$，那么最终的映射就是$f(g(x))$

那么询问的话求出$[l,r]$形成的映射，求出全部位置都是先手必胜的映射结果即可

时间复杂度$O(nm\log n)$

# Speed Dial

## 题目大意

![20211224T5](D:\Blog\image\20211224T5.PNG)

## 算法讨论

首先将所有字符串加入到字典树中，那么相当于我们需要在这个字典树中选出k个特殊点，其中根节点需要选择，并且不算到这个k个特殊点中

那么一个字符串的代价就是其结尾节点到根路径上最近的那个节点与结尾节点的距离乘上m

那么考虑DP，设$dp(i,j,k)$表示考虑到字典树上的i号节点，其中离当前位置最近的特殊节点编号为j，并且当前子树选择了k个特殊点

转移考虑两个子树的合并
$$
dp'(x,y,k)=\min dp(x,y,i)+dp(u,y,j)
$$
一开始的时候$dp(x,y,k)=m_x(dep_x-dep_y)$

如果将第三维限制到i的子树大小的话，那么时间复杂度就是$O(n^2\min(k^2,n))$

# Summer Practice Report

## 题目大意

![20211224T3](D:\Blog\image\20211224T3.PNG)

## 算法讨论

设$a$表示考虑到第i个字符串，拼接起来得到的字符串最后一位为T，最后最短的连续字符后缀长度

$b$表示最后一位为F的结果

考虑加入一个新的字符串

那么首先可以在开头放$k-a$个T，然后间隔一个F，然后再放k个T即可

那么最终得到的结果就是$\max(0,x_i-(k-a)-k\times y_i)$

对于b的更新也是类似的，如果$a>k$或者$b>k$，那么说明不合法

时间复杂度$O(n)$

