# CF325C Monsters and Diamonds

## 题目大意

现在有n个怪兽，每一个怪兽在吃一个饼之后可以分裂得到若干n个怪兽中的以及若干钻石，要求求出一开始用第i个怪兽到最终不存在怪兽最多和最小得到多少个钻石
$$
n\leq 10^5
$$

## 算法讨论

首先考虑最小的情况，对于分裂之后全是变成钻石的分裂规则，我们可以新建一个点$t$，表示走到这个点当前状态就是没有怪兽了

那么相当于如果一个怪兽最终可以变成没有怪兽的情况，那么其最小得到的钻石就是到$t$的最短路，但是需要注意的是这里的分裂规则可能一次分裂出多个怪兽，不是简单的二元关系

那么需要对每一个分裂规则求出其中分裂出了多少不同的怪兽，以及对于每一个怪兽求出哪些分裂规则包含这个怪兽，那么在最短路松弛的时候，将包含这个点的分裂规则计数器+1，如果计数器等于这个分裂规则中不同的怪兽数量时，那么统计通过这个分裂规则能得到的最小钻石数量（此时分裂出来的怪兽的最短路都是已经被确定了），然后更新这个点的最短路即可

这样如果一个点不存在到t的最短路，那么说明这个点不能到达没有怪兽存在的局面

然后考虑最大的情况，首先如果一个怪兽通过分裂可以得到自己，由于保证每一个分裂规则至少存在一个钻石，那么说明这个怪兽可以不断分裂得到无限的钻石

由于在某一个分裂规则中出现了可以无限得到钻石的怪兽的话，那么一开始要进行分裂的怪兽一定能得到无限钻石，那么相当于可以转化成一个二元关系

那么在得到的图上进行缩点，对于一个大小$\geq 2$的强连通分量，其都是可以得到无限钻石的，那么在缩点完的DAG上进行DP即可

需要注意的时如果某一个分裂规则里面存在达不到没有怪兽的状态的话，那么这个分裂规则就不能使用

时间复杂度$O(n\log n)$

# CF351D Jeff and Removing Periods

## 题目大意

![20220121](D:\Blog\image\20220121.PNG)

## 算法讨论

首先由于再操作之后可以重新排列数列，那么每一次就可以将某一相同的数全部删除即可，那么答案就是第一次操作之后剩下不同数的数量+1

那么只剩下求出第一次操作是否可以将某一种数全部删除，那么相当于求出一个区间内是否存在一种数出现位置形成了等差数列

那么可以对于每一个位置求出$MAX_i$表示最大到$[i,MAX_i]$都是形成了一个等差数列

那么考虑用莫队处理每一个询问，在每一种数中记录出现的最小位置和最大位置即可，判断一下最小位置的$MAX_i$是否大于最大位置即可

时间复杂度$O(n\sqrt n)$

# CF238D Tape Programming

## 题目大意

![20220121T2](D:\Blog\image\20220121T2.PNG)

## 算法讨论

首先考虑走的过程中遇到的几种情况

- $>...>$，那么相当于将中的数字走过1
- $<...<$，也还是相当于将中间的数字走过1
- $>...<$，首先$><$的情况，相当于最终将$>$删除，并且最终的方向变成向左，然后考虑更一般的情况，相当于第一次向右走过的时候将其中所有数-1并将最大值-1，事实上我们只需要关系这一段中最大值即可，可以发现如果最大值（经过-1的）为偶数，那么最终方向为向左，否则为向右

那么我们可以通过维护一个栈，栈中元素为当前存在的>，并且对于每一个>维护直接连在之后的数字以及最大值，当前加入一个<的时候，判断栈顶的>的最大值是否为偶数，那么就弹出偶数的，需要注意的是如果最终栈不为空，那么留下的栈顶元素的数字也是被全部删除了

那么我们可以求出对于每一个数字或者符号$>$在哪一个$<$的时候被删除记作$to_i$

对于一个询问来说，首先求出区间内第一个符号为什么以及位置$pos$，如果不存在符号，那么当前区间内都是数字，那么将这些数字的桶输出即可，可以用前缀和维护

如果第一个符号为$<$，那么输出$[l,pos)$内部的所有数字v以及v-1

如果$to_x\leq r$，那么输出$[x,to_x]$中的数字$1...v$和$[l,pos-1]$数字中的$v,v-1$

如果$to_x>r$，那么需要输出$to_i>r$的$v$以及$to_i\leq r$的1...v

其中前三个都是可以用前缀和直接维护出来的，主要难以处理的是第四个情况，那么可以将这种情况的询问离线下来，按照右端点进行排序，将10个数字的桶用vector封装起来，用扫描线+树状数组即可

时间复杂度$O(Vn\log n)$

# CF249E Endless Matrix

## 题目大意

![20220121T3](D:\Blog\image\20220121T3.PNG)

## 算法讨论

首先对于一个子矩阵的询问可以拆成四个矩阵左上角为$(1,1)$的和

那么相当于我们要求
$$
\sum\limits_{i=1}^ x\sum\limits_{j=1}^y a_{i,j}
$$
首先注意到$\min(x,y)$为边长的子矩阵中的数是$1...\min(x,y)^2$，那么直接等差数列求和即可

根据观察可以得到
$$
a_{i,j}=(j-1)^2+i,i\leq j\\
a_{i,j}=(j-1)^2+j+i^2-j^2=i^2-2j+1,i>j
$$
如果$x>y$

那么要求
$$
\begin{align}
&\sum\limits_{i=y+1}^x \sum\limits_{j=1}^y i^2-2j+1\\
&=(x-y)\times (y(y+1)+y)+\sum\limits_{i=y+1}^x yi^2
\end{align}
$$
通过求出二次方和即可

对于$x<y$
$$
\begin{align}
&\sum\limits_{j=x+1}^y \sum\limits_{i=1}^x (j-1)^2+i\\
&=(y-x)\times\frac{x(x+1)}{2}+\sum\limits_{j=x}^{y-1} xj^2
\end{align}
$$
同样求出二次方和即可

由于答案最大为$10^{36}$，用__int128可以存下，那么直接计算即可

时间复杂度$O(q)$

# CF297E Mystic Carvings

## 题目大意

一个环上有标号为1到2n的顶点，每个顶点连接一条无向边。要求选择3条不重复的边在顶点处建熊洞（共6个），且每条边的两个顶点的距离相同，询问其方案数。

距离定义为在环上从一个顶点到另一个顶点所经过的最少熊洞数量-1。
$$
n\leq 10^5
$$

## 算法讨论

首先对于三条弦的选择有五种情况

![img](D:\Blog\image\1qEbgH.png)

其中Type 2 5是合法的，但是无法直接求出（至少很难）

那么就需要通过一些容斥的手段求出答案，那么同样考虑计算出所有不合法的情况

首先考虑Type 1，这个我们可以考虑枚举中间那条弦，求出左右两边与其不相交的弦$L_i,R_i$，然后方案数就是$L_i\times R_i$，考虑如何求出$L_i,R_i$

考虑断环成链，显然对于环上相交的两条弦，那么数轴上的区间也是相交的，其中在这条弦左侧并且不相交的对应到数轴上就是这个区间内部包含的区间数量，在这条弦右侧对应的就是与这个区间不交，并且不被这个区间包含在内区间的数量

那么可以通过排序扫描线+树状数组求出$L_i,R_i$

然后考虑Type 3,4，可以发现三条弦中有两条满足另外的两条弦一条与其相交，一条与其相离，那么我们枚举这两条相交的弦，对于每一条弦可以求出$s_i=L_i+R_i$表示与这个弦相交的数量

那么答案就是
$$
\frac{\sum\limits_{i=1}^n s_i(n-1-s_i)}{2}
$$
那么时间复杂度$O(n\log n)$

# Recursive Ant [Task Recursive Ant (rek) - Problemset - SZKOpuł (szkopul.edu.pl)](https://szkopul.edu.pl/problemset/problem/mbE5K5TLdbFtuHiFgKXs9113/site/?key=statement)

首先考虑一个最小的情况2*2的网格

如果我们知道了起始位置，以及最终出去的方向，通过讨论可以发现的是这样的存在的路径是唯一的，并且如果存在障碍物只要能够走过所有位置，路径也是唯一的

那么考虑更大的情况，$2^k\times 2^k$的网格，由于我们需要走完一个$2^{k-1}\times 2^{k-1}$的网格之后，在走到下一个网格

那么相当于我们先对于4个$2^{k-1}\times 2^{k-1}$的网格进行决策，那么就变成了2*2的网格情况，但是这个某一个格子有障碍的定义就是$2^{k-1}\times 2^{k-1}$的网格全部被障碍物覆盖，那么这个可以通过预处理类似线段树解决

那么相当于我们要给一个块定一个起始位置以及最终走出的方向，只要确定这两个量那么就可以得到最终走出的位置，而一开始我们的起点是确定的，那么相当于最终要求结束在四个边上的终点也是确定的

那么我们可以记一个函数$f(x,y,k,d,s)$表示当前的块大小为$2^k$，并且当前块的左上角为$(x,y)$，最终需要走出的方向为$d$，当前的起始点为$s$，得到最终走出的位置

那么相当于我们要将这个块划分成四块，然后在这四块中求出一个合法路径

一种方式是分类讨论，具体的就是首先求出s是在哪一个块中，然后通过翻折将起始块变成左上角的那一块，然后进行分类讨论，这样需要分类讨论的状态数比较少但也有10几种

但是一种更简单的方法是，以s所在块为起点，dfs搜索出一条合法的哈密顿路，由于进行搜索的图为2*2，那么需要的搜索量是很小的，那么根据搜索出来的哈密顿路径可以递归到子问题求解

需要注意的是如果当前块中不存在障碍，那么相当于同样大小的块在确定方向和起始位置的时候都是相同的，那么需要记忆化一下即可，以保证复杂度正确

那么最终走出向上的位置为$f(0,0,n,UP,(0,0))$，另外三个方向类似

考虑时间复杂度，首先在加入障碍的时候，我们相当于对一个四分线段树进行单点修改，每一次最多修改n层，而每一次计算$f$的时候在遍历有障碍的节点时候复杂度是$O(1)$的，这样的节点最多有$nm$个，还有访问空节点的时候，相当于是一个节点延伸出的一个，并且最多计算一次

那么时间复杂度就是$O(nm)$

