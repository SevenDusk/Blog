对于树上的exchange argument

### Solution 1

考虑使用算法一，也就是对于每一个节点维护$(v,w)$这两个信息，当合并两个序列的时候，将$(v,w)$进行合并

用堆维护全局最小的序列，然后将这个序列代表的点合并到父亲节点上面

这样就可以对于一个根进行求答案，但是这道题需要将对于所有的节点都求出答案

可以发现的是，每一次将序列合并的时候，我们知道是哪个序列合并到哪个序列之中，那么可以记录下这个信息，所形成的结构仍然是一个树形结构

那么对于一个节点，我们可以用线段树合并求出当子树内的节点合并到当前子树根的时候序列的信息，那么就可以求出答案，在线段树上的每一个节点是记录当前这区间内所有序列的信息合并结果，那么在线段树合并的过程中，记录一下前缀信息即可快速合并

时间复杂度$O(n\log n)$

### Solution 2

考虑算法二，对于每一个子树都可以求出一个最优的操作序列，可以用数据结构维护每一块的信息，然后对于一个节点，先将其儿子子树的序列进行归并，然后再插入当前的这个节点的信息

需要注意的是，由于当前节点必须要在子树其他节点之前进行操作，那么需要将子树内的操作如果$\leq $当前节点的信息，那么需要将其合并到当前节点

最后再插入回数据结构

由于需要对于每一个节点进行求值，那么我们使用平衡树进行合并，然后进行启发式合并或者splay finger search

时间复杂度$O(n\log ^2n)/O(n\log n)$

# 压缩法

“压缩法”的含义为：“除去冗余信息，留下精华，以减小问题的规模”

> 一般来说，当我们处理问题时常常遇到一个集合*S*，*S*内部各个元素之间的关系对问题的结果不造成影响，而且也不会受到外部因素的干扰，那么我们可以将*S*看作一个内外隔绝的**包裹（package）**，忽略包裹内部的冗余信息，并将这个包裹与外部事物的联系保留，打包、**压缩后**作为一个新的元素存储下来以供以后分析处理。

## 例1 **多源最短路问题**

给定起点集合$s$，以及终点$t$求所有起点在$s$到$t$的最短最短路

在初始化dij的时候，将$s$都进行作为起点初始化，加入优先队列即可

## 例2 球队问题

给出某个篮球队的球员通讯图*G* **=** {*V*, *E*}如下，若存在有向边(*u*, *v*)表示球员*u*可将消息及时告诉*v*，若教练想将一条紧急消息告知给全体队员，利用这个通讯图，他至少要亲自通知几个队员？

可以对这张有向图进行强连通分量**缩点**，得到DAG上没有入度的节点数量就是答案



以上两个例子一个是将需要重复计算的过程取其中最优的作为一个子结构，而第二个就是将已经确定好的信息整合，将一个强连通分量压缩成一个点



使用压缩法需要满足我们压缩的信息是可以代表我们原来有的信息，压缩过程中会存在信息的丢失，但是丢失的信息都是我们不关心的，而我们关心的信息还是保留下来的

比如解两个同余方程，那么我们通过列出不定方程进行合并的过程就是对冗余信息的合并处理，最终变成一个方程，让我们在表示问题的时候可以用更简便的数学语言进行表述



## 例题 欧元兑换

你每天会收到一些欧元，可能为正数也可能是负数，银行允许你在某天将手头所有的欧元兑换成lei。第i天的兑换比率是1 euro ：i lei，同时你必须在多付出T lei被银行收取。在N天你必须兑换所有持有的欧元。要求找一个方案使第N天结束时能得到最多的lei。



首先考虑一个暴力的DP，设$f(i)$表示在第$i$进行兑换的最多lei
$$
f(i)=\max\limits_{j\leq i} f(j)+(s_i-s_{j-1})\times i-T
$$
可以用斜率优化，但是由于加入的点不满足单调性是难以进行处理的，虽然可以通过CDQ分治，做到$O(n\log  n)$但是实现比较繁琐

注意到我们兑换的比例每一天都是不断上升的，那么如果我们当前拥有的钱仍然是一个正数，那么我们可以不今天兑换，而是继续等待，如果我们的钱是负数肯定是当前进行兑换最优

那么我们可以贪心的将序列划分成若干段，每一段保证在最后一天之前手上的钱数都是正数，这样显然我们会留到最后一天进行兑换，我们不妨看作最后一天获得了所有这一段中获得的钱数，而之前的天都是获得0块

**这里就是使用了压缩法，将所有不优的选择压缩到一个状态（天）中去**

这样的话我们得到的$s_i$就一定是一个不升的序列，这样就是满足单调性的，就可以使用斜率优化了

## 例题 合并数列问题

给出*K*个数列，假设每个数列的长度分别为*n*1，*n*2，*n*3，…，*n**K*。而这*K*个数列分别为：

![img](D:\Blog\image\wps3955.tmp.png)

注意这里每个数都可能是负数。

将这*K*个数列**归并**为一个新的数列*S*，所谓归并，即选择一个非空的输入数列，将其第一项放入*S*的尾部，并在数列中删去该项；重复这一过程，直到所有的输入数列都是空数列。

要求寻找一个归并后的数列*S*，新的数列*S*的长度为*N*=*n*1 + *n*2 + *n*3 + … + *n**K*。且*S*的各个部分和

Sum0, Sum1, Sum2,…,Sum*N*

中，最大的最小。

数据范围：

*K* ≤ *N* ≤ 105。



考虑定义一个二元组$(m,s)$表示代表的序列的前缀和中最大值以及整个序列的和$s$

相当于我们要将若干序列进行拼接，如果$(m_i,s_i)$放在$(m_j,s_j)$之前优，那么需要满足如下条件
$$
\max(m_i,s_i+m_j)<\max(m_j,s_j+m_i)
$$
那么通过讨论可以知道

- 如果$s_i<0,s_j>0$那么一定满足条件
- 如果$s_i>0,s_j<0$那么一定不满足条件
- 如果$s_i<0,s_j<0$那么如果满足$m_i<m_j$那么一定满足条件
- 如果$s_i>0,s_j<0$那么如果满足$s_i-m_i<s_j-m_j$那么一定满足条件

**那么我们就可以完成对两个二元组的比较，那么我们可以将整个序列的信息压缩到二元组**

然后回到原问题，由于我们限制同一个序列的元素相对顺序不变，那么实际上可以建出一条链的树形结构，那么可以套用zjk论文的方法

我们对每一个子树的操作缩减成一条链，然后在合并子树的过程中对操作进行归并排序，最终加入根节点的操作，此时需要将缩成链的操作最前面的小于根节点二元组的与根节点二元组合并，最终放到链首即可

这道题上我们只需要在合并所有$k$个序列的时候进行排序即可，时间复杂度$O(n\log n)$

考虑这个问题其实类似于第二种模型（$\max \sum\limits_{i=1}^n a_i-\sum\limits_{i=1}^{n-1} b_i$）在树上的版本

### Solution 1

考虑使用算法一，也就是对于每一个节点维护$(v,w)$这两个信息，当合并两个序列的时候，将$(v,w)$进行合并

用堆维护全局最小的序列，然后将这个序列代表的点合并到父亲节点上面

这样就可以对于一个根进行求答案，但是这道题需要将对于所有的节点都求出答案

可以发现的是，每一次将序列合并的时候，我们知道是哪个序列合并到哪个序列之中，那么可以记录下这个信息，所形成的结构仍然是一个树形结构

那么对于一个节点，我们可以用线段树合并求出当子树内的节点合并到当前子树根的时候序列的信息，那么就可以求出答案，在线段树上的每一个节点是记录当前这区间内所有序列的信息合并结果，那么在线段树合并的过程中，记录一下前缀信息即可快速合并

时间复杂度$O(n\log n)$

### Solution 2

考虑算法二，对于每一个子树都可以求出一个最优的操作序列，可以用数据结构维护每一块的信息，然后对于一个节点，先将其儿子子树的序列进行归并，然后再插入当前的这个节点的信息

需要注意的是，由于当前节点必须要在子树其他节点之前进行操作，那么需要将子树内的操作如果$\leq $当前节点的信息，那么需要将其合并到当前节点

最后再插入回数据结构

由于需要对于每一个节点进行求值，那么我们使用平衡树进行合并，然后进行启发式合并或者splay finger search

时间复杂度$O(n\log ^2n)/O(n\log n)$