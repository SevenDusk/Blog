# A.最短距离

首先最终的图一定是一个基环树，那么我们先将基环树上的环求出来，对于除了环上的节点来说，预处理子树内最深深度即可

首先考虑选的点在环上的情况，那么可以枚举这个点落在哪一条边上（此处的边包含两个端点），那么我们需要求出按照逆时针走到这条边左端点$x$的点集，以及按照顺时针走到$x$更小的点集，显然这都是一段区间，那么我们维护一下区间端点即可，在我们不断移动$x$的时候单指针更新区间端点即可，这样指针的变化次数就是$O(n)$的

当指针没有发生变化的时候，每一个点按照哪一个方向走到选择的点都是确定的，那么我们就可以用st表或者单调队列维护其中的深度的最大值，同时也可以计算出，如果指针没有发生变化的时候，当前选择点能选的区间，假设两种不同的方向最长的路径长度分别为$A,B$，选点的区间为$[l,r]$

那么我们最小化$\max(A+x,B+w-x)$其中$w$为当前枚举边的边权

那么显然$x=\frac{B+w-A}{2}$的时候最优，如果最优取值落在$[l,r]$区间内的话，直接求最小值即可，否则一定是选取左右两个端点

这样就可以在$O(n)$的时间内解决环上的问题

然后考虑树上的问题，在处理环上的时候我们可以得到环上其他子树到当前子树根的最大距离，然后dfs这颗子树，假设选的位置在$x\rightarrow u$这条边上

那么其他子树的最大值
$$
\max\limits_{v\neq u} dep_v+w
$$
记录一个前缀max和后缀max即可，然后在考虑$u$子树内的最大深度，按照上面分析的方法求出最小值即可

总时间复杂度$O(n)$

答案等于基环树上直径/2，那么可以考虑将环从某一个点断开，类似上面叙述的记录前/后缀缀深度最大值即可，相当于选出两个点进行配对，破环成链之后记录边长的前缀和即可

![img](https://cdn.luogu.com.cn/upload/pic/55484.png)

![img](https://cdn.luogu.com.cn/upload/pic/55488.png)

左侧的点用$dep(x)-sum(x)$取最大，右侧点用$dep(x)+sum(x)$取最大即可

# B.排列计数

考虑容斥，首先考虑如果同时存在两种限制是很难处理，首先考虑不存在某一种限制的情况，比如说先不考虑"$>$"

那么$>$左右两边的数大小关系不限制，那么两个之间的数只有$<$，那么这一段数一定要单调递增，那么$>$就相当于一个隔板，将序列划分成若干段，每一段都是单调递增的序列，设序列长度为$a_i$，总共划分成$m$段

那么方案数为$\frac{n!}{\sum\limits_{i=1}^m a[i]!}$

再考虑把所有$>$的限制加上，由于刚才计算的是两面的方案数，那么考虑将$>$改为$<$的限制，然后进行容斥

设$dp[i]$表示考虑到原串的第$i$位，去掉$n!$的容斥系数之和，如果$s[i]=>$，那么$dp[i]\neq 0$，否则$dp[i]=0$

$dp[i]=\sum\limits_{j=0}^{i-1} (-1)^{cnt_i-cnt_j-1}dp[j]\frac{1}{(i-j)!}$

分治$ntt$即可

# C.合并数列

考虑定义一个二元组$(m,s)$表示代表的序列的前缀和中最大值以及整个序列的和$s$

相当于我们要将若干序列进行拼接，如果$(m_i,s_i)$放在$(m_j,s_j)$之前优，那么需要满足如下条件
$$
\max(m_i,s_i+m_j)<\max(m_j,s_j+m_i)
$$
那么通过讨论可以知道

- 如果$s_i<0,s_j>0$那么一定满足条件
- 如果$s_i>0,s_j<0$那么一定不满足条件
- 如果$s_i<0,s_j<0$那么如果满足$m_i<m_j$那么一定满足条件
- 如果$s_i>0,s_j<0$那么如果满足$s_i-m_i<s_j-m_j$那么一定满足条件

那么我们就可以完成对两个二元组的比较，那么我们可以将整个序列的信息压缩到二元组，然后回到原问题，由于我们限制同一个序列的元素相对顺序不变，那么实际上可以建出一条链的树形结构，那么可以套用zjk论文的方法

我们对每一个子树的操作缩减成一条链，然后在合并子树的过程中对操作进行归并排序，最终加入根节点的操作，此时需要将缩成链的操作最前面的小于根节点二元组的与根节点二元组合并，最终放到链首即可

这道题上我们只需要在合并所有$k$个序列的时候进行排序即可，时间复杂度$O(n\log n)$

考虑这个问题其实类似于第二种模型（$\max \sum\limits_{i=1}^n a_i-\sum\limits_{i=1}^{n-1} b_i$）在树上的版本

### Solution 1

考虑使用算法一，也就是对于每一个节点维护$(v,w)$这两个信息，当合并两个序列的时候，将$(v,w)$进行合并

用堆维护全局最小的序列，然后将这个序列代表的点合并到父亲节点上面

这样就可以对于一个根进行求答案，但是这道题需要将对于所有的节点都求出答案

可以发现的是，每一次将序列合并的时候，我们知道是哪个序列合并到哪个序列之中，那么可以记录下这个信息，所形成的结构仍然是一个树形结构

那么对于一个节点，我们可以用线段树合并求出当子树内的节点合并到当前子树根的时候序列的信息，那么就可以求出答案，在线段树上的每一个节点是记录当前这区间内所有序列的信息合并结果，那么在线段树合并的过程中，记录一下前缀信息即可快速合并

时间复杂度$O(n\log n)$

### Solution 2

考虑算法二，对于每一个子树都可以求出一个最优的操作序列，可以用数据结构维护每一块的信息，然后对于一个节点，先将其儿子子树的序列进行归并，然后再插入当前的这个节点的信息

需要注意的是，由于当前节点必须要在子树其他节点之前进行操作，那么需要将子树内的操作如果$\leq $当前节点的信息，那么需要将其合并到当前节点

最后再插入回数据结构

由于需要对于每一个节点进行求值，那么我们使用平衡树进行合并，然后进行启发式合并或者splay finger search

时间复杂度$O(n\log ^2n)/O(n\log n)$