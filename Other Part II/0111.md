# UOJ418【集训队作业2018】三角形

## 题目大意

Snuke 有一棵 $n$个点的有根树，每个点有权值 $w_i$，初始每个结点上都没有石子。

Snuke 准备了一些石子，并把它们拿在手中。她可以进行以下两种操作任意多次：

1. 从手中取 $w_i$个石子放在结点 $i$ 上，进行该操作要求结点 $i$ 的所有孩子 $j$ 上都有 $w_j$ 个石子。
2. 将结点 $i$ 上的所有石子收回手中。

Takahashi 想知道对于每个 $i$，为了在结点 $i$ 上放 $w_i$ 个石子，Snuke 至少需要准备多少石子。
$$
n\leq2\times 10^5
$$

## 算法讨论

首先一般来说，树形结构对于选择排列的顺序来说都是父亲在所有子树节点之前选择，而这道题的选择顺序是从下到上选择，在处理起来会有一些困难

那么不妨将整个过程倒过来考虑，操作变成可以将某一个节点上的$w_i$个石子分裂到儿子节点上，使儿子节点每一个点都有$w_j$个石子，然后在完成分裂操作之后在将当前节点的石子移除，答案就是在操作过程中存在树上的最多石子数量

设$v_x=\sum\limits_{u\in son(x)} w_u$，那么对一个节点进行操作等价于，将总石子数先加上$v_x$，然后再减去$w_x$，由于需要求出在过程中最大的石子数量，那么相当于答案就是
$$
\max \sum\limits_{j=1}^i v_{p_j}-\sum\limits_{j=1}^{i-1} v_{p_j}-w_{p_j}
$$
然后需要最小化这个值，那么相当于是转化成了第二种模型（$\max \sum\limits_{i=1}^n a_i-\sum\limits_{i=1}^{n-1} b_i$）

考虑讨论交换两个相邻的位置，如果$x$在$y$之前进行操作，那么需要满足$\max(v_x,v_x-w_x+v_y)<\max(v_y,v_y-w_y+v_x)$，根据之前模型的证明，可以知道这个关系是可以构成全序关系的

### Solution 1

考虑使用算法一，也就是对于每一个节点维护$(v,w)$这两个信息，当合并两个序列的时候，将$(v,w)$进行合并

用堆维护全局最小的序列，然后将这个序列代表的点合并到父亲节点上面

这样就可以对于一个根进行求答案，但是这道题需要将对于所有的节点都求出答案

可以发现的是，每一次将序列合并的时候，我们知道是哪个序列合并到哪个序列之中，那么可以记录下这个信息，所形成的结构仍然是一个树形结构

那么对于一个节点，我们可以用线段树合并求出当子树内的节点合并到当前子树根的时候序列的信息，那么就可以求出答案，在线段树上的每一个节点是记录当前这区间内所有序列的信息合并结果，那么在线段树合并的过程中，记录一下前缀信息即可快速合并

时间复杂度$O(n\log n)$

### Solution 2

考虑算法二，对于每一个子树都可以求出一个最优的操作序列，可以用数据结构维护每一块的信息，然后对于一个节点，先将其儿子子树的序列进行归并，然后再插入当前的这个节点的信息

需要注意的是，由于当前节点必须要在子树其他节点之前进行操作，那么需要将子树内的操作如果$\leq $当前节点的信息，那么需要将其合并到当前节点

最后再插入回数据结构

由于需要对于每一个节点进行求值，那么我们使用平衡树进行合并，然后进行启发式合并或者splay finger search

时间复杂度$O(n\log ^2n)/O(n\log n)$

# Heavy Stones

## 题目大意

现在有n堆石子排成一排，其中第i堆石子中存在$a_i$个石子，首先选择第$k$堆，然后选择左右其中一堆石子进行合并，新的石子堆会成为下一轮操作选择的石子堆，其中合并的代价就是得到新石子堆中石子的个数

对于每一个$k$求出最小代价和
$$
n\leq 2\times 10^5
$$

## 算法讨论

首先如果第$i$个石子堆是在第$k$次进行合并的，那么其对最终代价产生的贡献就是$(n-k+1)a_i=(n+1)a_i-ka_i$其中我们只需要关系$ka_i$

相当于需要最大化一个排列的价值$\sum\limits_{i=1}^{n} ia_{p_i}$

其中$p_i$需要满足一些条件，假设现在第一堆石子是第$r$堆，那么相当于是一条在$r$位置为根的链，对$p$进行限制

现在考虑exchange argument ，假设$x$排在$y$之前，并且$x$之前有$cnt$个

那么需要满足$a_x(cnt+1)+a_y(cnt+2)>a_y(cnt+1)+a_x(cnt+2)\rightarrow a_y>a_x$

更一般的来说，由于我们需要对于两个序列进行排序，那么需要通过两个序列的信息进行排序，假设一个序列用$(s,c,f)$表示，其中$s$表示这个序列中$a$的和，$c$表示这个序列中存在多少个元素，$f$表示序列内部的贡献

那么就需要满足$s_x\times c_y<s_y\times c_x\rightarrow \frac{s_x}{c_x}<\frac{s_y}{c_y}$那么就转化成了第一个模型

根据算法二

由于发现$r$位置只有两个子树，并且这些子树最多种类只有$2n$个，那么我们可以正反两遍预处理出来所有种类子树的最优操作序列，并且可以得到出现过的所有序列的信息以及何时插入到最优序列以及何时删除

那么我们可以对于这些序列进行离散化，预先处理出来之前的顺序关系，知道每一个序列在什么位置，这样在计算答案的时候可以使用数据结构进行维护

考虑使用树状数组进行维护，同时用一个变量记录当前序列中的答案

以插入一个序列为例，删除序列的方式类似，首先考虑需要将内部贡献$f$算入答案，然后用两个树状数组分别维护$s,c$的和，如果在一个序列之前插入一个序列，那么其需要增加$c_x\sum s$的代价，如果在之后插入一个序列需要增加$s_x\sum c$的代价

那么贡献就是$s_x\times (A.query(cnt)-A.query(pos[x]))+c_x*B.query(pos[x]-1)$

其中$A$维护的是最优序列中$c$的前缀和，$B$维护的是最优序列中$s$的前缀和$pos[x]$表示离散化之后，插入序列的相对位置

这样i从小到大进行扫描，同时更新维护树状数组以及答案和即可

时间复杂度$O(n\log n)$