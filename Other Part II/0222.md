# A.简单计数

考虑相邻两个$0$之间的结构，我们强制其中的数字不能等于$0$，这样在之后的步骤中就不会计算重复

那么由于相邻两个数的差的绝对值等于1，那么相当于就是一个类似卡特兰数的方案

那么相当于强制第一步+1，最后一步-1，在过程中不能低于$1$，那么就是一个卡特兰数，假设中间存在$k$个位置，那么方案数就是$\binom{k-1}{(k-1)/2}-\binom{k-1}{(k-1)/2-1}$，其中$k\geq 1$为奇数

由于题目强制第一个位置为0，那么我们对于这个结构左边填上一个0即可，那么最终的序列就是若干这个结构进行组合，然后强制最后一个位置为0即可

那么我们可以考虑这个结构的生成函数，指数表示需要用的位置，记作$F$
$$
F=x+\sum\limits_{i=1}^{k}[i\bmod 2=1](\binom{i-1}{(i-1)/2}-\binom{i-1}{(i-1)/2-1})x^{i+1}
$$
那么由于是$F$进行组合，并且两个元素之间不存在顺序关系

那么答案就是
$$
[x^n](1+F+F^2+F^3+...)=[x^n]\frac{1}{1-F}
$$
那么直接多项式求逆即可

时间复杂度$O(n\log n)$

# B.简单字符串

首先考虑对这个串建出sam，考虑parent树上的一个节点，其endpos集合排序之后得到序列为$p$

代表字符串的长度区间为$[l,r]$

同时我们需要用kmp预处理出来$s[1...i]$的最长border和$s[i...n]$的最长border分别记作$fp_i,fs_{i}$

那么由于合法串是需要覆盖整个串，其中对于前缀来说，是选出串的一个后缀进行覆盖，对于后缀来说，是选出串的一个前缀进行覆盖

先不管两端的情况，只考虑中间部分，就是选出串完整覆盖的位置

那么要求串长$len\geq \max p_{i+1}-p_i$

然后考虑开头的情况，首先可能的覆盖前缀长度，相当于是选出串和原串的公共前缀后缀长度，那么通过预处理的$fp$可以知道，就是$fp_{p_1},fp_{fp_{p_1}}...$

首先由于我们强制$p_1$，那么说明$p_1$是当前选出串的最早出现位置，那么我们选出的串一定满足$len>fp_{p_1}$，那么也就是说一旦我们可以把$[p_1-len+1,p_1]$和$fp_{p_1}$接上就是合法的，那么我们肯定让覆盖的位置尽可能大

那么显然就是选$fp_{p_1}$最优，那么$p_1-len+1\leq fp_{p_1}+1$得到$len\geq p_1-fp_{p_1}$

接下来考虑后端的情况，跟前缀同理$p_k\geq fs_{p_k-len+1}+1$

注意到如果我们只考虑前端和中间的情况，我们是可以得到$len$的一个区间$[l',r]$其中$l'=\max (p_1-fp_{p_1},\max p_{i+1}-p_i,l)$

那么剩下的就是统计后端的合法情况，注意到len是在下标的位置，我们是难以进行处理的，那么我们可以考虑将统计过程离线，我们对于一个相当于是固定右端点，统计合法左端点，而左端点又是在一个区间里面并且当我们固定左端点的时候是很容易统计出合法右端点的

那么我们就可以考虑线段树分治，在$[p_k-r+1,p_k-l'+1]$区间内插入$p_k$的位置

然后最后在线段树中dfs一遍，同时用树状数组维护右端点的位置数量，当我们固定左端点的时候，合法右端点是一段区间，在树状数组上直接查询即可

至于输出方案，那么对于每一个可能的左端点，在树状数组中二分出最近的右端点，然后可能的串个数只有$O(n)$个，然后进行排序即可，求两个后缀的LCP可以通过二分hash

那么总时间复杂度$O(n\log ^2n)$

# C. 简单最优化

首先有一个暴力的DP式子

设$f(i,j)$表示考虑到第$i$个数，选了$j$个数的最大值
$$
f(i,j)=\max (f(i-1,j),f(i-1,j-1)+a_i\times j)
$$
然后有一个结论就是对于一个固定的$i$，一定存在一个分界点$k$，满足$j\leq k,f(i,j)=f(i-1,j)$对于$j>k,f(i,j)=f(i-1,j-1)+a_i\times j$

考虑证明，假设我们存在一个位置$k$满足$f(i,k)=f(i-1,k-1)+a_i\times k,f(i,k+1)=f(i-1,k+1)$

假设$F(i,j)$表示最优方案下选择的集合
$$
F(i,k)=F(i-1,k-1)\cup \{a_i\}\\
F(i,k+1)=F(i-1,k+1)
$$
考虑进行归纳，那么对于$F(i-1,k)$是满足$F(i-1,k)=F(i-1,k-1)\cup \{x\}$（根据过程可以得到）

假设
$$
F(i-1,k)=F(i-1,k-1)\cup\{x\}\\
F(i-1,k+1)=F(i-1,k)\cup \{z\}
$$
那么我们可以得到
$$
F(i,k)=F(i-1,k-1)\cup \{a_i\}\\
F(i,k+1)=F(i-1,k-1)\cup \{x,z\}
$$
$F(i,k+1)$的另一种转移是$F(i-1,k-1)\cup \{x\}$

由于$F(i-1,k)$是最优的

那么说明$val(F(i-1,k-1)\cup\{x\})>val(F(i-1,k-1)\cup \{z\})$

然后通过讨论x对应的下标和z对应的下标的相对位置关系可以发现的是
$$
val(F(i-1,k-1)\cup \{x,z\})<val(F(i-1,k-1)\cup \{x,a_i\})
$$
那么就和假设矛盾

那么就可以考虑用数据结构进行维护DP的值，首先我们需要找到这个分界点，然后需要在这个分界点插入一个值，然后将分解界点之后的点加上一个等差数列

那么这个可以用平衡树进行实现

至于二分的过程我们可以在平衡树上实现，具体的对于每一个节点来说同时位置对应下标的值以及前驱的值即可，然后在二分的时候利用计算好的值进行判断即可

这样的时间复杂度$O(n\log n)$

