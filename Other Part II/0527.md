# CF1685E The Ultimate LIS Problem

首先考虑将所有的位置转化括号序列，**通过括号序列的性质来限制约束，由于$LIS\geq n+1$，那么说明不能都是$<n+1$的数或者都是$>n+1$的数**

首先将所有$<n+1$的数变成右括号，=n+1变为空格，$>n+1$的数变成左括号

那么首先考虑括号匹配的情况

假设此时的LIS长度$\geq n+1$，如果$n+1$不在LIS中，那么说明选择了$k$个$<n+1$的数，右侧选择了$n+1-k$个$>n+1$的数，由于此时的括号是匹配的，那么在第$k$个LIS的位置之前一定是存在$k$个$>n+1$的数

那么这样就和$>n+1$只有$n$个的条件矛盾，那么说明$n+1$一定在LIS中

那么此时这个序列会被n+1这个数分成两段，假设左侧一段选择了$k$个$<n+1$的数，右侧的一段选择$n-k$$>n+1$的数，根据同样的分析可以知道，左侧一段一定存在$k$个$>n+1$的数，那么说明左侧一段的括号应该是匹配的，右侧一段的情况也是同理

那么如果我们找到一个位置，使得整体的括号序列是匹配的，但是n+1左右两段的括号序列是不匹配的，那么可以直接输出

那么既然左右两端是匹配的，那么我们不妨将左侧的全部移动到右侧去，**通过分析特殊情况以加强条件**

那么此时$n+1$处于最左侧，并且$n+1$右侧的序列要是匹配的，如果我们将$n+1$置于最左侧的时候，右侧的括号序列不是匹配的，那么说明前面的那个条件一定是不满足的，那么我们只要找到一个位置使得整体的括号匹配即可（此时n+1左右两侧的括号序列一定是不匹配的），那么我们可以维护这个括号序列的前缀和，找到前缀和最小的那个位置，然后将右侧的一段移动到$n+1$左侧即可

既然$n+1$右侧的是匹配的，如果LIS$\geq n+1$，那么所有的$>n+1$的数应该递增排列，如果不满足这个条件，那么说明当前序列$LIS\leq n$的，直接输出当前位置即可

对于$n+1$处于最右侧的情况也是同理的，所有$<n+1$的数应该递增排列，并且左侧的括号序列一定要匹配

如果有一个条件不满足，那么一定可以立马构造出一个解

现在考虑满足所有的条件的情况，那么此时$<n+1$和$>n+1$都是递增排列的，那么通过旋转操作，我们一定可以选择$<n+1$的一段前缀+(n+1)+$>n+1$的一段后缀构造出$LIS=n+1$的情况

那么此时的答案就是-1

接下来考虑如何维护需要用的信息，首先将序列复制一遍，方便旋转操作的求值，然后我们维护括号序列的前缀和，以及区间前缀和中的最小值

这样就可以判断一个区间内的括号序列是否匹配

然后考虑如何判断$<n+1$的数递增排列，那么我们在线段树上维护当前区间最左侧的数和最右侧的数，以及当前区间是否递增排列，合并两个线段树节点的时候，判断左儿子最右侧的数是否等于右儿子最左侧的数-1即可

这样的时间复杂度就是$O(n\log n)$

