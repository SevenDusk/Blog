# B.串串题

首先考虑二分答案，那么每一段的权值需要$\leq mid$

注意到如果从 $t$ 最后/最前删除一个字符，那么$J(t)$的值一定会变小，那么我们就可以考虑贪心，我们从1号位置出发，每一次选择$\leq mid$最长的一段进行扩展，如果经过 $\leq k$ 次扩展之后，覆盖了整个串，那么说明当前的mid合法

那么现在问题就变成如何求出从一个位置出发最长可以扩展多少

注意到对于固定的 $t$ 来说，我们可以通过建sam + 差分，做到$O(|t|\times |\sum|)$时间内计算贡献

那么我们就可以考虑倍增，首先我们先求出最长长度的最高位，然后从最高位开始不断倍增即可，那么我们需要检查的串长最大为$2|t|$，那么找到最长的串的时间复杂度就是$O(|t|\log n\times |\sum|)$

由于每一个位置最多被一个串覆盖，那么复杂度是对的

最终复杂度$O(n\log ^2n |\sum|)$，通过在倍增之前预先建好sam可以将$|\sum|$优化掉

# C.排排题

首先将A,B排序，由于题目保证合法，那么说明$B_i\in [A_i,A_i+R]$

但是由于我们需要选择一部分位置使得$B_{p_i}\in[A_i,A_i+L]$

我们可以考虑动态维护$A,B$这个有序上升的序列，我们可以在其中选择一个位置$i$，令$B_{p_i}\in [A_i,A_i+L]$，那么相当于我们需要找到另外一个位置$j$，使得$B_j\in [A_i,A_i+L]$

如果$j>i$满足条件，那么说明$i$也一定是满足条件的，可以发现令$j=i$比选择$>i$的位置更优，那么说明$j\leq i$

考虑删除$A_i,B_j$会造成什么影响，那么相当于将$[j+1,i]$位置的$B$向左平移一格，这样会造成$k\in [j,i-1]$位置对应的$B$增大

那么我们可以对每一个位置上的$A_i$维护有多少个$j\geq i$满足$B_j\in [A_i,A_i+R]$，那么每一次删除相当于区间减1

我们可以考虑从后往前进行贪心，每一次考虑确定当前序列最末尾的位置，如果这个位置可以选择$[A_i,A_i+L]$且选择之后仍然存在解，那么我们就贪心的选择这个位置，同时用线段树维护区间减法

可以这样做的原因就是删除一个位置操作的影响实际上是独立，我们可以通过交换删除顺序使得删除的位置从大到小选择

并且由于选择的$j$是$\leq i$的，那么只要我们保证删除之后有解，那么后面删除的位置并不会影响前面选择的$p_i$的取值

那么时间复杂度就是$O(n\log n)$
