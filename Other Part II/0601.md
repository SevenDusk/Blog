# A.抓鱼

首先将所有鱼的按照所含的宝石分类，对于同一类宝石将含有这类的宝石的鱼按照长度分类

那么在判断一种宝石组合是否合法的时候，条件就是存在一种宝石满足在组合中出现次数$>0$，然后选择这类宝石中长度最大的鱼作为最终捕获的鱼，对于其他鱼就贪心的选择宝石中长度最小的若干个即可，那么要求最终捕获的鱼能吃掉所有其他的鱼

那么事实上我们关心的就是每一种宝石长度最大的那条鱼，那么对于所有$m$种宝石求出其最大长度的鱼，那么枚举所有其他宝石，根据这条鱼需要吃掉所有其他鱼的限制，可以求出当前枚举的宝石中最多可以选择多少个鱼

那么可以用一个$v_{i,j}$表示第$i$种宝石最大长度的鱼，对于第$j$种宝石最多可以选择多少个鱼

对于$i\neq j$的时候，第$j$种宝石可以选择的个数区间为$[0,v_{i,j}]$，对于$i=j$的时候，可以选择的区间为$[1,v_{i,j}+1]$

那么相当于我们所有这些集合的并集

首先考虑容斥，枚举一个宝石集合$s$，令$M_j=\min \limits_{i\in s} v_{i,j}$，那么容斥系数就是$\prod (M_i+[i\not \in s])$

注意到如果我们将所有宝石按照最长的那条鱼进行排序，那么可以发现除了个别位置$v_{i,j}$的值是随着$i$单调递增的，而容斥过程是需要取min的

那么我们只要关系当前集合中最小的宝石$i$即可，但是注意到在$i$处取值会有一些问题，$v_{i,j}+1$可能不符合递增的条件，但是注意到只会增加1，那么可以通过二分出来最小的pos满足$v_{pos,j}=v_{i,j}+1$

如果集合中同样存在$j\in (i,pos)$，那么$M_i$处的取值会发生变化

那么可以考虑枚举$i$，过程中动态维护$v_{i,j}$的值，然后对于第二小的位置用线段树维护出来乘积即可

由于模数不是质数，无法进行除法，那么需要用线段树维护$v_{i,j}$的乘积，然后在确定第二小的位置之后，右边剩下的位置可以任意选择，可以发现贡献就是$M_i+1-M_i=1$，所以不需要特殊维护即可

那么时间复杂度就是$O(n\log n)$

# B.送别

首先从一个位置不断走的话，能走过的路径一定是一个环，那么所有相邻墙的位置会形成若干个环

我们可以对网格图中的每一条边两侧分别建立一个点，那么我们可以通过维护点的顺序来维护形成的环

由于每一次都是只对一个墙进行删除或者插入操作，相当于就是在环上删除一段点或者插入一段的点，那么我们可以考虑用平衡树维护每一个环中点顺序

那么我们就可以快速维护这个环上的顺序

主要复杂的地方在于实现，首先需要给每一个格子的四条边进行标号，那么最终的点数是$4\times n^2$

还需要讨论加入墙的方向

有一个简化的地方就是如果我们确定了加入一条边的算法流程，那么只要反向撤销的算法就是删除一个墙的做法

那么主要是考虑加入一条边的做法，首先一个墙的上/左标号为0，下/右标号为1

那么根据下图的向左方向的分类讨论，我们需要进行操作就是

![QQ图片20220601232427](D:\Blog\image\QQ图片20220601232427.jpg)

cut(A,B),link(A,1),link(0,B)

根据下图向右方向的分类讨论，我们需要进行操作的就是

![QQ图片20220601232422](D:\Blog\image\QQ图片20220601232422.jpg)

cut(A,B),link(1,B),link(A,0)



那么我们平衡树上需要支持删除和连接一条边，首先我们在每一个联通块上维护是为环还是为一条链，如果是链的话要求链首在平衡树中的顺序最大

那么link分为两种情况

- 一种是合并两条链，由于我们要求链首一定在最后，那么可以直接合并两个平衡树

- 一种是从链变成环，那么这样的连接要求连接链首和链尾，只要对根节点打上环的标记即可

cut也是分为两种情况

- 一种将链分成两条链，那么直接splay之后分离子树即可
- 一种是将环变成链，那么我们需要将断开的那个位置移动到平衡树中顺序最大的位置，那么同样需要分离两个子树，然后交换即可

这样就可以维护了，时间复杂度就是$O(n^2\log n^2)$，常数很小

还有一种常数比较大，但是比较好写的做法

就是对于每个格子的角落再建四个辅助点，然后将这个四个辅助点连成一个环，如果加入了一个墙（并且这个墙的一个端点是当前的格子），那么可以将对应的方向的两个点之间的边断开，链上加入墙对应两个方向的点即可

然后将所有辅助点的sz设为0即可

# C.田野

首先对于一个固定的点集来说，其最小包围的长度就是这个点集最小凸包的周长

那么现在问题就是需要将点集划分成若干个集合，然后最小化每一个集合凸包周长和

首先随机化做法就是，对于每两个凸包集合来说，都存在一个价值就是这个凸包的周长，如果合并之后价值变小，那么我们可以贪心的将其合并起来

但是有可能出现反例，就是只合并两个凸包周长变化都是正数，但是如果一次合并多个凸包，周长变化就有可能是负数

那么可以考虑在合并两个凸包的周长变化都是正数的时候，随机选择两个凸包进行合并，多做几次即可

接下来考虑确定性做法

首先有一个结论就是如果某次合并的价值为负，而从中选出任何一个子集来单独合并的价值均不为负，则这次合并一定会进行。更强的结论是，如果某次合并的价值为负，且任意子集合并的价值都大于当前集合，且不存在两个不交的子集的合并价值都为负，那么这次合并一定会进行

那么也就是说我们每一次需要选出一个凸包集合，然后合并所有这个集合中的凸包，并且要求合并后变化量为负数

可以考虑用DP进行统计，首先将所有点进行排序，然后枚举凸包的起点，从这个起点开始DP，然后如果我们一旦发现一个集合合并之后为负数，那么就立即合并，如果找不到那么显然之后的过程中这个点一定都不会被作为起点

那么可以设$dp(i)$表示当前凸包最后一个点为$i$的最小代价，由于组成的多边形如果不是凸的，那么一定可以通过连接两个凹处顶点使得方案变得更优，那么我们就不会判断凸包的条件

还有一点需要注意的是，我们在DP过程中产生的线段不能和已有的凸包相交，那么我们需要预处理每一个点和每一个凸包的两条切线，并将两个切点连接起来，如果一条线段和凸包有交，那么一定和这条线段有交，那么这样判断就可以做到$O(n^2)$预处理，$O(1)$判断

然后接下来我们需要考虑统计在DP的凸包内凸包的价值和，那么可以考虑射线法，对于每一个凸包中我们引出一条射线，并在这个射线上记录该凸包的价值

在dp时按逆时针顺序进行，则每选一条逆时针方向穿越某条射线的边就减去对应凸包的周长，顺时针方向穿越就加上对应周长

那么没有包含的凸包会被一正一负的贡献抵消掉，这样就可以统计价值和了

然后我们选取的射线端点应该是该凸包的重心的位置，并且方向竖直向上（略微偏离一个角度即可避免和其他点相交）

那么我们需要进行$O(n)$次DP操作，每一次DP的复杂度是$O(n^2)$，那么最终复杂度就是$O(n^3)$