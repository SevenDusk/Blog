# A.Border

假设k子串的答案为$f(k)$，可以发现的是，当k+1的时候，对于$f(k)-2$的border是一定存在的，画一下图就可以发现，这个相当于就是$f(k)$的border去掉第一个字符和最后一个字符的情况，这样前缀和后缀是一定相等的

那么我们就有$f(k+1)\geq f(k)-2$，那么如果直接暴力枚举的话就需要找到最后一个位置，然后不在枚举下去复杂度才是对的，但这样无法判断当前是否要停止复杂度就是错的

如果$f(k)\leq f(k+1)+2$，那么相当于找到第一个合法和border即可

那么从k大往小枚举，首先将$f(k)=f(k+1)+2$，然后不断减小$f(k)$,直到找到一个合法的border可以用hash实现（不能用自然溢出，需要双模hash）

这样势能还是随着位置的减小最多增加2，时间复杂度就是$O(n)$

### Solution 2

首先我们将原来串翻转隔位插入到原来串里面

比如原来的串为ABCAB，翻转后为BACBA然后隔位插入ABBACCABBA

可以发现的是对于原来串的一个border相当于得到新的串的一个回文串

那么我们可以先用manacher或者z函数求出每一个位置的回文半径，需要注意的是这里只取长度为偶数并且中心在偶数位置的回文串

然后利用单调栈去除被完全包含的回文串，那么得到的序列左端点一定递增，右端点也随之递增

按照左端点枚举这些回文串来更新答案，在回文串范围内的border都是可以被更新到的，就是$[l_i,\min(r_i,l_i)]$区间内的位置都是更新为$r_i-j$即可

# B.Majority

首先考虑枚举区间严格众数为$x$，记$sum_i$表示前缀$[1,i]$中$x$的出现次数

考虑一个区间$(l,r]$的众数等于$x$需要满足的条件
$$
2(sum_r-sum_l)>r-l\\
2 sum_r-r>2 sum_l-l
$$
那么令$a_i=2\times sum_i-i$，那么我们就需要求出有多少对二元组$(i,j)$满足$i<j,a_i<a_j$

注意到$a_i$等价于将$=x$的位置设为-1，其他位置设为1的前缀和，假设$x$在所有位置中出现了$k$次，出现的位置下标序列为$p$，满足$p_i<p_j,i<j$，并且$p_{k+1}=n$

那么$a$形成的序列可以看作$k+1$个连续下降序列拼接在一起（连续下降序列就是后一个数等于前一个数-1），其中第一个下降序列开头为$0$长度为$p_1$，剩下的下降序列开头为$2\times sum_{p_i}-p_i$长度为$p_{i+1}-p_i$

那么考虑对于一段统计答案，由于每一次变化1，那么这一段序列值域形成了一段区间$[l,r]$，我们记$c_x$表示前面段中$a_i=x$出现次数

那么这一段的贡献为
$$
\sum\limits_{i=l}^r c_i(r-i+1)+\sum\limits_{i<l} c_i(r-l+1)\\
$$
那么我们可以用线段树维护$c$的和以及$c_i\times i$的和即可，需要支持区间查询和区间修改，直接用线段树做的复杂度为$O(n\log n)$

事实上还可以进一步优化，注意到在$a_i=a_{i-1}+1$的位置只有$k$个，并且只会使$a_i$的值增加一，并且我们要求的二元组是因为这$k$个位置存在而产生的（上升的位置和回落位置都可能成为二元组中的$j$），更严谨的定义就是上升和回落的位置为$a_i\neq \min(a_1,...,a_i)$或者当前存在多个最小值

并且上升位置和回落的位置最多只有$2k$个，我们可以对所有可能的$a_i$维护一个桶，里面记录出现次数，考虑当前段的区间$[l,r]$，一定是存在一个$pos\in[l,r]$满足$[l,pos]$中对应的位置是上升或者回落的位置

那么我们可以维护一个指针指向当前位置的$a_i$对应的桶，同时记录$s=\sum\limits_{x<a_i} c_x$，由于每一次指针只会移动1，那么可以直接更新$s$

然后考虑$[pos+1,r]$之间的数，这些一定是之前没有出现过的，那么在查询某一个桶的时候，$c_x=\max(1,$当前桶内的数$)$即可（也就是说再没有进行操作之前默认当前桶个数等于1）

那么这样的时间复杂度为$O(n)$

# C.Paint

首先考虑最小形成的正方形大小为6，并且存在两种构造方案
$$
AABBAA\ \ \ \ \ \ \ \ \ \ \ \ \ \ AAAAAA\\
AABBAA\ \ \ \ \ \ \ \ \ \ \ \ \ \ AAAAAA\\
AABBAA\ \ \ \ \ \ \ \ \ \ \ \ \ \ AAAAAA\\
BBAABB\ \ \ \ \ \ \ \ \ \ \ \ \ \ AAAAAA\\
BBAABB\ \ \ \ \ \ \ \ \ \ \ \ \ \ BBBCCC\\
BBAABB\ \ \ \ \ \ \ \ \ \ \ \ \ \ BBBCCC\\
$$
一种使用了6个方格，一种使用了3个方格

事实上如果我们将$6\times 6$的看作最小单位网格的话，我们可以组成几乎所有的情况，首先注意到如果只使用这两种构造的话，$3|m$，那么我们先考虑这种最简单的情况

假设两种构造方案分别使用了$a,b$，那么需要满足$6a+3b=m$并且$a+b$是完全平方数

通过验证，只有$m=9$的时候不存在这样$a,b$，特判掉$m=9$的情况，那么我们只需要构造一个边长为$6\times \sqrt{a+b}$的网格即可，其中有a个$6\times 6$的网格用6个块，$b$个$6\times 6$的网格用3个块

至于染色，我们首先可以将$6\times 6$看成一个格子，然后对格子黑白染色，黑色格子只能使用A,B,C三种字符，白色格子只能使用D,E,F即可

然后考虑$m\equiv 1\bmod 3$的情况，那么我们可以先使用一个$12\times 18$的块，占据了$2\times 3$的$6\times 6$单位网格

那么现在的条件变为$6a+3b=m-1$并且$a+b+6$是完全平方数

通过打表验证，$m=7,22,25,28$的时候不存在$a,b$，直接特判掉即可

考虑$m\equiv 2\bmod 3$的情况，可以先使用两个$6\times 9$连在一起，占据了$1\times 3$的$6\times 6$单位网格

那么现在条件变为$6a+3b=m-2$并且$a+b+3$是完全平方数

通过打表验证，$m=8,11,14,17$的时候不存在$a,b$，直接特判掉即可

并且通过验证，最终得到正方形的边长$\leq 2500$

总时间复杂度$O(m)$