# Array Covering

首先可以将问题建出一个上下界费用流，那么说明答案是关于k上凸的函数

那么就可以wqs二分，假设当前的枚举的斜率为$mid$

那么显然对于区间和$\geq mid$的区间是一定需要选择的，那么可以先把这部分区间选出来，然后考虑每一个位置都是需要被至少一个区间覆盖的，那么就可以进行DP

设$dp(i)$表示当前最后一个区间覆盖到第$i$个位置，数值是一个二元组表示区间和和区间个数，和为第一关键字，个数为第二关键字

那么如果我们加入的区间和$\geq mid$那么是不计入这个DP统计里面的，因为之后会统一加入

记$sum(i)$为$a$的前缀和，记$pre(i)=\max \limits_{j=0}^i sum_j$
$$
dp(i)=\max\limits_{j=1}^{i-1} dp(j)+sum(i)-pre(j)
$$
如果$sum(i)-pre(j)\geq mid$即那么贡献为$(0,0)$

如果$sum(i)-pre(j)<mid$那么贡献为$(sum(i)-pre(j)-mid,1)$

可以注意到会对$pre(j)$有限制，那么我们可以用树状数组维护，那么转移的复杂度$O(n\log n)$

最后我们需要将所有区间和$\geq mid$的加入，对于第$i$个位置对于$j<i$求$\sum [sum(j)\leq sum(i)-mid]sum(i)-sum(j)$，也是可以用树状数组维护

总时间复杂度$O(n\log ^2n)$

# Nasty Donchik

首先我们可以考虑枚举中间的那个位置$j$，那么考虑两端的两个端点$L,R$

那么对于每一种数字我们求出跨过j这个位置相邻的两个位置$(a,b)$

那么$L\leq a\and R\geq b$或者$L> a\and R< b$

考虑固定$L$的时候$R$有多少种取值

那么$ \max \limits_{a_i\geq L} b_i\le R\leq \min \limits_{a_i<L} b_i$

如果按照$a_i$作为下标的话，记$pre(i)$表示前缀对于$b$的min，$suc(i)$表示后缀对于$b$的max

那么$R$的取值个数就是$\max(0,pre(L-1)-suc(L)+1)$，然后对于所有$L$求和即可

那么考虑用线段树维护$pre(L),suc(L)$还有所有答案，然后我们从小到大枚举$j$，那么相当于每一次都会删除一个$(a,b)$然后新加入一个新的二元组$(a,b)$，那么我们每一次修改二元组的时候，二分出需要修改的区间（注意需要修改的区间可能不止一个，那么要将所有的区间都找出来，这样复杂度是对的因为考虑单调栈，每一个元素只会被插入或者弹出两次），并且这个区间内的所有pre/suc相同，那么相当于转化为区间赋值操作

那么可以在另一个线段树上直接维护答案，需要特别注意一下，在线段树节点中需要记录$pre(L-1)$是否大于$suc(L)$，只有$pre(L-1)\geq suc(L)$才能将$pre(L-1)-suc(L)+1$计入答案中

然后在二分的时候需要使用线段树二分，这样的总时间复杂度$O(n\log n)$

# KazHackStan

首先将所有询问和修改操作分来，先处理所有的修改，再处理所有的询问

考虑一个询问，考虑时间从1开始不断增加的过程，相当于若干个点集的交，我们找到第一个时刻使得这个交集不为空，那么可以发现的是此时这个交集里面只有一个点或者两个相邻的点，在之后的时间相当于从这个点/相邻的两个点开始扩展

那么时间这一维就变成了到这个点/两个点距离$\leq T-d$的点个数，其中d表示在d时刻这个交集不为空

考虑如何求出这个$d$，那么相当于就是求出最晚相交的一对点即可，那么相当于求出在这个点集的直径，如果我们将每一个病毒看作连在v下面的一个虚点的话并且距离为t的话，那么相当于就是树上的直径

但实际上实现的时候没必要建虚点，两个点的距离定义为$\lceil \frac{dis(i,j)+t_i+t_j}{2}\rceil $即可

考虑一个询问相当于是要我们求出$[L,R]$点集的直径，那么可以用线段树维护，在合并两个节点的时候，最终点集的直接端点一定在两个点集直径四个端点之中，那么直接枚举更新即可

然后我们可以通过倍增求出在哪一个位置相交，那么问题就变成了如果求到一个点距离$\leq d$的点个数

那么可以考虑将所有这样的询问离线，然后进行一遍点分治即可

时间复杂度$O(n\log ^2 n)$，如果使用O(1)LCA，可以优化到$O(n\log n)$

# Support or Not

首先考虑二分答案，假设二分的距离为$mid$

那么我们可以给每一个球的半径加上$\frac{mid}{2}$这样的话，我们在解决问题的时候不需要考虑$mid$的关系，相当于求有多少对球相交

然后考虑最大那个球的半径$R$，那么我们将整个空间划分成若干个边长为$2R$的区域，一个球属于圆心所在的区域

如果所有球的半径都是相同的，那么说明一个格子中只有$\sqrt k$个球，否则一定超过限制对数

但是所有球半径不同，那么我们就需要如果当前球半径$<\frac{R}{2}$的时候重构所有格子，这样最多重构$O(\log r)$次，这样每一个格子中均摊$O(\sqrt k)$个球

那么用hash表维护每一个球在哪个格子内即可

# Jiry Matchings

考虑一个暴力的DP，设$f(i,j,0/1)$表示当前节点$i$子树内存在$j$个匹配，当前节点是否被匹配的最大边权

那么就可以得到一个max +卷积的形式

考虑由于是匹配，而树又是一个二分图，那么显然可以建出费用流模型，那么说明答案一定是凸的

两个凸函数作max+卷积相当于进行闵可夫斯基和合并

但是注意到闵可夫斯基和的时间复杂度是$O(n+m)$，那么是不能进行启发式合并的，那么就只能考虑链分治，考虑对树进行树链剖分

那么计算一条链的所有节点的DP值时候，先将节点的轻儿子信息合并上来，然后对于整条重链看作一个序列进行分治合并即可

就是考虑一个分治区间的左右端点是否被匹配了，然后向上合并的时候讨论一下左右端点以及相交的位置是否进行匹配，然后进行闵可夫斯基和合并即可

对于轻儿子的合并，那么同样需要一个分治

那么总的时间复杂度$O(n\log n)$

# Count the Sequences

首先考虑对于所有的位置进行容斥，假设当前容斥的集合为$s$

那么限制就转化为
$$
x_i\geq 0\\
\sum\limits_{i=1}^m x_i\leq n-\sum\limits_{i\in s} (b^i-c+1)-1
$$
那么考虑如何统计这个方案数，那么相当于我们枚举一个$k\in [0,n-\sum\limits_{i\in s} (b^i-c+1)-1]$使得
$$
\sum\limits_{i=1}^m x_i=k
$$
那么这个的方案数就是$\binom{k+m-1}{m-1}$，那么对于k进行求和
$$
\sum\limits_{k=0}^{n-\sum\limits_{i\in s} (b^i-c+1)-1} \binom{k+m-1}{m-1}=\binom{n-\sum\limits_{i\in s}(b^i-c+1)-1+m}{m}=\binom{n+|s|(c-1)+m-1-\sum\limits_{i\in s}b^i}{m}\\
$$
那么我们可以枚举$|s|$的大小，然后求出所有集合大小为$|s|$的贡献和，注意此时我们将$\sum\limits_{i\in s} b^i$看作变量，由于我们固定了$|s|(c-1)$的大小上面式子的求和范围就会发生变化

具体的
$$
\sum\limits_{k=0}^{n-1} \binom{k+|s|(c-1)+m-1-\sum\limits b^i}{m-1}\\
=\binom{n+|s|(c-1)-1+m-\sum\limits_{i\in s}b^i}{m}-\binom{|s|(c-1)-1+m-\sum b^i}{m}
$$


其中后面减去的式子由于$|s|(c-1)$的范围在$|s|b$左右，那么我们可以直接暴力枚举可能的$s$即可，这部分的复杂度为$2^{\log_b |s|(c-1)}$

主要是考虑计算前面的式子，将组合数展开，将$\sum b^i$看作变量，那么可以得到一个关于$\sum b^i$的$m$次多项式记作$\sum f_ix^i$

其中我们需要计算$(\sum b^i)^k$的形式，那么相当于在所有$|s|$个不同的$b^i$中选出k个可以相同的数然后乘起来的方案数总和

那么就可以考虑DP进行统计，首先我们有限制$\sum \limits_{i\in s}b^i\leq n+|s|(c-1)-1$

可以考虑将左边的数分解成$b$进制即可，然后进行数位DP即可

设$dp(i,j,k,0/1)$表示从最高位考虑到第$i$位的时候，选择了$j$个位置作为$s$，在这$j$个位置中又选出了$k$个位置，当前是否小于限制（1表示等于限制,0表示小于限制）

那么转移的话，就是讨论当前位置选不选到$s$中去，如果选择又会在计算幂次的组合意义中选了几次计算贡献（如果选了$p$次，乘上的系数为$b^{ip}\times \frac{1}{p!}$，这是因为(幂次)个位置都是不同的，需要乘上一个组合数，拆开之后就是这个形式，最后算答案的时候将(幂次)!乘上即可），然后进行转移即可

状态数$O(m^3)$转移复杂度$O(m)$（因为要枚举在组合意义中选了多少次，是卷积的形式无法用前缀和优化）

总时间复杂度$O(m^5)$

