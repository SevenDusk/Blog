# A.a 酱的 dq

首先将原来序列加入到双端队列之后的情况，形成新的序列显然是单谷的，并且谷底为1，那么这个序列可以分成两个下降的序列

考虑得到序列中1的位置$k$，那么显然在$k$之后的序列元素一定是从某一个下降序列不断删除两头元素得到的，并且$[1,k]$的元素和$[k+1,n]$的元素顺序实际上是独立的

首先考虑$[k+1,n]$的排列，由于是从一个下降序列中删除两端得到的，那么方案数就是为$2^{n-k-1}$（除了最后一次删除，其他删除都有两种选择）

那么剩下的就是对$[1,k]$元素顺序进行计数

由于此时双端队列中还是存在两个下降序列的，那么$[1,k]$内的元素一定是可以被划分成两个下降序列的，并且要求其中一个下降序列的最小值需要大于$[k+1,n]$中的最大值

那么相当于我们需要最大化其中一个序列的最后一个元素，那么我们可以得到一个贪心的划分方式，假设我们划分成了两个序列$A,B$并且我们需要最大化$B$序列中的最后一个元素

从前往后进行考虑，加入一个数$x$的时候，如果$x<$A中最后一个元素，那么就将$x$加入到$A$中，否则将$x$加入到$B$中即可

那么就可以对这个过程进行DP了，我们可以设$dp(i,j)$表示考虑到前$i$个数的时候$A$的最后一个元素为$j$的方案数

转移有两种转移，第一种是我们添加一个$<j$的元素，然后更新A序列，那么对应着
$$
dp(i,j)=\sum\limits_{k>j} dp(i-1,k)
$$
还有一种转移是，添加的元素$>j$，那么显然我们只能添加当前所有$>j$中的最大值，否则就无法划分成两个递减的序列了，这样对应着转移
$$
dp(i,j)=dp(i-1,j)
$$
那么合并两个转移就是
$$
dp(i,j)=\sum\limits_{k\geq j} dp(i-1,k),j\leq n-i+1
$$
那么对于一个$k$来说其方案数就是$2^{\max(0,n-k-1)}dp(k,2)$，特别的如果$k=1$，那么方案数就是$2^{n-2}$

直接做的时间复杂度$O(n^2)$

考虑进行优化，注意到这个DP的形式特别简洁，可以考虑直接求出$dp(i,j)$是什么，考虑转移式的组合意义，可以将每一个状态放到二维坐标系中，其中$dp(i,j)$对应着$(i,n+1-j)$，注意到所有状态都在$y=x$这条直线之下

首先初始状态$dp(0,n+1)=1$，那么说明起点在$(0,0)$上，转移式的组合意义就是每一次可以将当前纵坐标减去任意一个非负整数，并且要求减去之后还是一个正整数

考虑用一条路径来表示减去的过程，那么我们可以从当前点$(i,j)$先走到$(i,k)$然后再走到$(i+1,k)$，并且不能超过$y=x$这条直线

那么本质上就是一个类似卡特兰数的过程，需要注意的这个过程并不和卡特兰数完全等价，因为最后一步不能是从$(i,j-1)$走到$(i,j)$

那么方案数通过折线法就可以求出，走到$(i,j),j\neq i$的方案数等于
$$
\binom{i+j}{i}-\binom{i+j}{i-1}-\binom{i+j-1}{i}+\binom{i+j-1}{i-1}
$$
如果$i=j$
$$
\binom{i+j}{i}-\binom{i+j}{i-1}
$$
由于我们要对$j\in[i,n-1]$进行求和（可以发现这是个差分的形式，中间项全部抵消，只剩最后一项），那么最终的式子为$\binom{i+n-1}{i}-\binom{i+n-1}{i-1}$

那么最终的方案数等于
$$
2^{n-2}+\sum\limits_{i=1}^{n-1} 2^{\max(0,n-i-2)}(\binom{i+n-1}{i}-\binom{i+n-1}{i-1})
$$
实际上通过平行求和法，最终得到式子就是$\binom{2n-2}{n-1}$

# B.b 酱的博弈

首先形成的状态一定是一个DAG说明这是一个ICG游戏

注意到实际上如果我们将每一个斜行来看的话，前一个斜行是决定着后一个斜行的

那么这个游戏的过程实际上很像3.17模拟的T3，通过同样的推理过程就可以得到所有白点可以看作一个独立的游戏，整个游戏的sg值等于所有白点的sg值的异或和

那么问题就是如何求出白点的sg值，正常做是比较困难的，那么就可以进行打表

对n,m,k分别在$[1,4]$进行取值，可以发现的是如果$(i,j)$位置存在白色格子的话，其sg值等于$\min(lowbit(i),lowbit(j),highbit(k))$，证明的话可以进行归纳

那么接下来就是对这个进行求值，由于给出的白点是通过矩阵并给出的，那么我们根据求矩阵并的思路，从左到右进行扫描线

首先我们需要发现一个性质，如果我们要求$\min(lowbit(i),lowbit(j)),i\in[l,r],j\in[L,R]$的异或和的时候，我们可以先求出$lowbit(i),i\in[l,r]$的异或和$A$，求出$lowbit(j),j\in[L,R]$的异或和$B$

那么假设$B$中第$k$位等于1，那么将A中所有大于等于$k$位的1进行异或和，然后将得到的结果放到第$k$位上，然后剩余的位不动，得到新数$A'$，那么原问题的答案就是等于对于所有$k$得到的$A'$进行异或和

那么应用到上面的式子也是同理的，我们可以最后处理$highbit(k)$的影响，先求出$\min(lowbit(i),lowbit(j))$的异或和

对于矩阵并我们可以用线段树在$O(m\log n)$的时间内解决

问题就剩下如何求出$lowbit(i),i\in[1,r]$的异或和，那么答案就是$r\bigoplus \lfloor\frac{r}{2}\rfloor$

# C.c 酱的二分图

首先考虑最终我们删除的边，首先这些边一定是不交的，那么也就是说，对于$i,j\in s,i<j$一定有$p_i<p_j$，并且如果$i,j$之间没有被删除的边，那么不能存在$k\in(i,j),p_k\in(p_i,p_j)$

那么我们就可以考虑一个DP，设$dp(i)$表示删除最后一个边为$i$的时候最小代价，考虑转移

我们称$j$在$i$下合法，当且仅当$p_i$是在$[j,i]$中$>p_j$的所有数中最小的那个

也就是在只保留$>p_j$的数时候，$p_i$是前缀min

我们可以通过线段树维护类似前缀min的值，首先在线段树中维护出最小值

就是在线段树中pushup的时候，如果右儿子的权值比左儿子小，那么直接用左右儿子的最小值更新当前节点的答案

否则递归到左儿子求解答案即可

这样的时间复杂度为$O(n\log ^2n)$