# A.Power

首先有一种的随机算法就是将不断迭代$(ax+b)\bmod p$

此处由于$x,p$都是随机的，那么对于序列中的每一个位置都可以看作随机变量

那么在进行若干次操作之后，当前序列的最大值就会变得很大，具体的我们可以设置一个阀值$lim$，表示当前序列的最大值$\geq lim$的时候停止，如果$lim=p-10000$在随机数据下只需要$2\times 10^5$次操作即可

那么相当于我们只需要对$(p-10000,p-1]$区间内的数求出其在序列中的出现时间即可求出之后序列前缀最大值的和

如果直接做的话，需要对这里面的数用BSGS求出其是$x$的多少次幂，但是如果我们求出$p$的原根$w$，然后求出这些的数关于$w$的离散对数，通过求出$x$的离散对数之后，就可以通过解同余方程求出是$x$的多少次幂

那么我们从后往前进行枚举，同时维护一下后缀时间的最小值就可以求出答案

由于BSGS的次数较多，那么块长可以适当调整

# B.Match

首先考虑求出这个串的最小循环节，首先考虑整个串中最小循环节最后一次出现是完整的

由于最小循环节不存在长度$>0$的border，那么在$s$出现的连续段一定是不交的

那么首先预处理出来所有最小循环节和$t$在$s$出现的位置，由于$s$中存在通配符，那么需要用FFT求出可能的出现位置

具体的，令$a_i$表示$s_i$上字符的代价，如果$s_i='?'$，那么$a_i=0$，否则$a_i=s_i-'a'+1$

对于$b_i$表示$t_{m-i+1}$，定义也是同理

那么只要求出$(a-b)^2\times b$的值等于0的位置即可，那么可以用FFT进行计算

然后设$dp(i)$表示的连续段最后结尾在$i$时候$t$出现了多少次

接下来考虑最小循环节最后一次出现并不是完整的情况

此时可以发现连续段并不一定是不交的，但是可以发现如果两个连续段相交，那么一定是前面连续段最后那个不完整最小循环节和后面连续段的第一个最小循环节相交，否则我们就可以导出最小循环节存在border的悖论

那么可以相交的位置距离后面连续段开头的长度集合就是最后那段不完整的最小循环节的border

由于一个串的border集合可以划分成$O(\log n)$个等差数列，那么我们可以通过单调队列+前缀 max 来优化$dp$的转移

更近一步的是，注意到对于同一个等差数列，只有其中最长大小的border的是有用的

那么时间复杂度就是$O(n\log n)$

# C.Tile

