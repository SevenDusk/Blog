# 「JOISC 2017 Day 1」开荒者

首先可以发现对于某一个种子来说，经过若干次操作，其形成含有种子的形状是一个矩形，并且这个种子是这个矩形的中心，矩形的上边界离这个中心的距离是向上操作的数量，其他边界也是类似

首先需要考虑某一维，就是考虑上下边界，考虑枚举向上操作的次数$u$，向下操作的次数$d$，那么现在每一个种子都是形成了一个竖直的长条，然后考虑求出最小的左右操作的数

考虑某一行的情况，考虑在这一行中存在种子的位置$p_1,p_2,...,p_k$，假设向左的操作数有$c$，向右操作数有$d$，那么相当于$c\geq p_1-1,d\geq W-p_k,c+d\geq \max p_i-p_{i-1}-1$

那么可以对于每一行都可以求出这三个限制，那么对于$c,d,c+d$求出这些限制的最大值$k_1,k_2,k_3$，那么需要的最小操作数就是$\max(k_1+k_2,k_3)$

需要注意到$u+d$一定是某两个初始种子的纵坐标之差，$u,d$其中之一需要顶到边界，然后由于本质不同的行只有$O(n)$个也就是两个顶点的位置，由于计算一行的复杂度是$O(n)$的，那么总复杂度就是$O(n^5)$

然后考虑如果$u+d$相同的话，对于所有点形成长条的相对顺序是固定的，需要忽略边界的限制，不妨让某一个点形成的长条为$(x,y),(x,y+L)$，那么我们可以只考虑枚举$L=u+d$，然后确定边界的位置

在枚举$L$之后，计算所有不同行的三个限制

边界类似一个滑动窗口，相当于求出边界内部的行三个限制的最大值，那么就可以用单调队列进行维护，时间复杂度$O(n^4)$

注意到当枚举的$L$发生变化的时候，我们需要重新计算所有行的限制，但是当$L+1$的时候很多行是不会发生变化的，注意到所有行的答案会发生变化当且仅当$y,y+L$形成的点序列之间的相对顺序发生变化，并且一旦发生变化只会影响两行的答案，变化次数$O(n^2)$，用单调队列维护最值的时间复杂度$O(n)$，枚举量$O(n^2)$，总时间复杂度$O(n^3)$

# AGC21F Trinity 

首先考虑列对行的限制

如果我们从前往后按照列的顺序扫描整个矩阵，我们可以维护一个行集合$s$表示集合内的行已经出现了黑色格子，那么考虑加入当前列，那么我们可以枚举$C_{u}s$的一个子集$t$，表示子集中的行在当前这一列第一次出现了黑色格子

对于$s$集合中的位置，这一列也可以任意填，然后令$s'=s\cup t$即可

考虑将整个过程倒过来，相当于一开始有一个集合（注意不一定是全集，因为可能存在行中不出现任何黑色格子），每一行都可以删除一个当前集合中的子集，表示这些行在这一列第一次出现，但是这一列可以不止填这些位置

事实上这些集合具体是哪些是没有用的，我们只需要记录集合中还存在多少元素$k$，假设当前取出了$p$个元素

- $p=0$的情况，方案数为$s(k,p)=\frac{k(k+1)}{2}+1$（注意需要+1，因为可以空）
- $p>0$的情况，考虑枚举两个边界，方案数$s(k,p)=\sum\limits_{i=1}^k\sum\limits_{j=i}^k \binom{j-i+1}{p}=\sum\limits_{L=p}^k (k-L+1)\binom{L}{p}$

那么设$dp(i,j)$表示考虑后i个列，还剩下$j$行的方案数，其中$dp(m,i)=\binom{m}{i}$
$$
dp(i,j)=\sum\limits_{k=j}^{n} dp(i+1,k)\times s(k,k-j)
$$
事实上这样已经可以用FFT优化了，但是需要凑一下形式，可能一下子看不出来，但是如果将$s(k,p)$化简之后，形式会非常好凑，同时能马上看出来如何进行优化
$$
\begin{align}
s(k,p)&=(k+1)\sum\limits_{L=p}^k\binom{L}{p}-\sum\limits_{L=p}^k L\binom L P \\
&=(k+2)\binom{k+1}{p+1}- (p+1)\sum\limits_{L=p}^k \binom{L+1}{p+1}\\
&=(p+2)\binom{k+2}{p+2}-(p+1)\binom{k+2}{p+2}=\binom{k+2}{p+2}
\end{align}
$$
那么
$$
\begin{align}
dp(i,j)&=dp(i+1,j)\times(\frac{j(j+1)}{2}+1)+\sum\limits_{k=j+1}^n dp(i+1,k)\times \binom{k+2}{k-j+2}\\
&=dp(i+1,j)\times(\frac{j(j+1)}{2}+1)+\frac{1}{j!}\sum\limits_{k=j+1}^n dp(i+1,k)(k+2)!f(n+j-k) 
\end{align}
$$
其中$f(k)=\frac{1}{(n+2-k)!}$，由于此处$k$从$j+1$开始枚举，那么$n+j-k<n$，那么可以令$f(k)=0,k\geq n$

那么就可以变成$k=0$开始枚举，那么就是卷积的形式了，取$x^{n+j}$处的系数即可

时间复杂度$O(nm\log n)$

# UOJ388 【UNR #3】配对树

首先对于一个确定的序列的答案，考虑贪心，就是一个子树最优只有一个不在子树内部进行匹配

那么相当于我们新加入一个点可以将这个点到根路径上的所有边是否选择进行反转

那么某一条边如果能产生贡献，那么子树内序列节点出现次数需要为奇数

考虑某一条边的贡献，考虑用线段树合并求出子树内在整个序列中存在的位置，同时计算出答案，在线段树中维护8个信息，有三维，第一维表示奇数位置和偶数位置，第二维表示到左边界还是有边界，第三维表示到边界经过存在的位置是奇数个还是偶数个

然后按照这个定义利用线段树的分治结构，求出所有的合法子段数量

时间复杂度$O(n\log n)$

