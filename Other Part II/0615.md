# A.染色

首先对于图中存在奇环的情况，那么就可以对于所有节点构造颜色集合$(1,2)$使得其不合法

那么接下来只需要考虑有偶环的情况，首先可以注意到一个性质就是如果存在一个偶环，那么我们一定可以通过，(1,2)-(2,3)-(3,4)-(2,4)的环状结构，使得某一个位置必须要填一个数

那么相当于如果存在两个不相交的环由一条边相连，那么我们可以强制两端的环端点一定都填同一个数，那么这样就可以构造不合法情况

或者如果某个点存在四个不同的并且与之相邻的点，并且分成了两对点使得在不同的环（这两个环其他位置可以重合）上，那么也是可以对于这两个环强制这个点选择不同的颜色，构造出不合法情况

也就是对于每一个连通块来说，进行边双连通分量缩点之后，必须只能有一个连通分量，而且由于一个边双内部都是环状结构的拼接，那么如果存在度数$\geq 4$的点一定可以构造处不合法情况

那么考虑度数$\leq 3$的情况，如果所有点的度数都是$=2$，那么说明这个双连通分量就是一个环，那么一定合法

如果最大度数$=3$的情况，首先考虑最简单的情况，最大度数=3的点个数只有两个，那么需要考虑两种图

<img src="D:\Blog\image\graph (4)-16553380580911.png" alt="graph (4)" style="zoom: 33%;" />

<img src="D:\Blog\image\graph (5)-16553381869563.png" alt="graph (5)" style="zoom:33%;" />

由于度数$=3$的时候，整个连通分量相当于被划分成三条路径，而且有两种情况，一种是三条路径上的点数都是偶数或者三条路径上的点数都是奇数

然后上面两种图就是两种情况的最小不合法的图，其中对于偶数来说只要存在三条路径就一定不合法，奇数的情况如果路径长度为1 1 3,1 1 1的情况是合法的（可以通过写一个暴力验证）

对于偶数的构造就是1:(1,2),2:(3,2),3:(1,3),4:(1,2),5:(3,1),6:(2,3)

对于奇数的构造就是1:(1,2),2:(1,2),3:(1,2),4:(1,3),5:(3,4),6:(1,4),7:(2,4),8:(2,4),9:(1,2)

而对于$\geq 4$个度数=3的点来说，大环至少需要8个点，分割成的路径至少有$2$个点，那么说明一定不合法

至此就可以得到一个$O(n)$的做法

# B.绿宝石

由于是实数题没有取模所以不能考虑容斥的做法

那么题目的限制可以转化为$\sum \limits_{i=1}^n a_i=d$，第$i$个人拥有的宝石个数为$a_i+1$，对于所有$a$序列前$r$个的进行求和

考虑此时的概率
$$
pr[X=a]=\frac{\binom{d}{a_1,a_2,...,a_n}\prod \limits_{i=1}^n a_i!}{n^{\overline{d}}}=\frac{d!}{n^{\overline{d}}}
$$
那么也就是说对于所有合法的$a$序列来说其概率是相同的，那么我们只需要对于所有序列$a$的前$r$大进行求和即可

考虑如何求前$r$大的数值，那么可以考虑如下过程，每次我们选出$a_i>0$的位置，将$a_i-1$，那么可以发现的是此时对前$r$大的贡献就是$\min(r,$当前$a_i>0$的位置数量$)$

那么设$p(i,j,k)$表示当前已经进行了$i$次操作，还剩下$j$个位置$>0$，已经使用了$k$个宝石的概率，同时记$val(i,j,k)$表示期望贡献

然后枚举$p\leq j$表示在接下来的一轮操作种有多少个位置从$>0$变成了0
$$
val(i+1,j-p,k+j)=(\min(j,r)\times p(i,j,k)+val(i,j,k))\binom{j}{p}\\
p(i+1,j-p,k+j)=p(i,j,k)\times \binom{j}{p}
$$
那么可以发现的是$k\geq ij$，那么对于i来说$j\leq \frac{d}{i}$

那么总枚举量就是$n^2\sum (\frac{d}{i})^2=n^3$

那么时间复杂度就是$O(n^3)$

如果题目是取模题的话，那么可以通过二项式反演做到$O(n\log n)$或者$O(n\log \log n)$的复杂度

# C.移动

首先可以建立一个费用率模型，对于所有点$x$源点$s$向$x$连一条费用为$-\infin$容量为$y_x$的边，同时连向汇点，代价为0，容量为$x_x$

对于树边需要建双向边即可，然后跑最小费用最大流即可，最后加上$(-\infin)\times \sum y_i$，由于数据范围很大，需要考虑模拟费用流

这个模型是经典的老鼠进洞模型，那么可以考虑进行双向增广，也就是说对于所有源点连向的点和汇点连向的点都用堆维护一个增广集合（也就是可撤销贪心的撤销操作和所有待匹配的点）

由于是树形结构，那么可以考虑从子树开始不断进行扩展，这一过程的本质就是费用流的动态加边和删边

注意到贡献的形式是$de_x+de_y-2\times de_{LCA}$，那么我们可以在匹配的两个点的LCA处统计贡献

注意到源点连边的费用是$-\infin$，那么源点连向的点集合初始代价为$de_x-\infin$

那么对于一个子树维护所有可能的增广集合即可，在向上合并的过程中需要堆的合并，那么可以用左偏树实现，然后对于在LCA处，我们不断弹出两个增广集合的堆顶进行匹配

如果代价$\geq 0$，那么说明当前进行匹配一定不优，那么直接退出即可，否则找到了一条可以使答案更优的增广路，进行增广加入撤销操作即可

需要注意的是，如果此时两个增广集合的堆顶是来说同一个子树的话，那么计算的贡献会有问题，但是可以发现一旦这样进行匹配的，那么我们可以下移LCA的位置使得答案变得更优，那么这种情况一定不会成为最优解

那么复杂度就是$O(n\log n)$
