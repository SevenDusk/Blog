# CF325D Reclamation

首先不考虑这个网格图在列这一维形成了环的情况，将这个网格图转成对偶图，那么如果上下不连通，当且仅当左边和右边通过8联通的障碍联通

那么就可以用并查集维护连通性

然后考虑网格图在列上形成了环的结构，那么可以将这张图无限进行延伸，那么相当于如果我们可以从一个障碍走到另外一个复制份的对应障碍的位置，那么就可以无限沿着障碍走下去，相当于将上下两部分断开

那么相当于需要判断图中是否存在某一个障碍，使得在经过至少一次边界之后回到当前位置

那么可以将整张网格图复制一份，并且得到的大网格的列也是形成环的，那么相当于判断两份网格图中对应相同的障碍位置是否联通，因为一旦这两个点联通，那么一定是经过了一次边界

那么可以用可撤销并查集维护连通性，显然如果插入新障碍会使得这样的路径存在，那么当前加入的这个位置也是存在走到另一份相同位置的路径

那么在加入之后，这两个位置连通，那么将加入合并的并查集进行撤回即可

# CF360D Levko and Sets

首先假设$a_i=g^{c_i}$其中$g$是p的原根

那么相当于第i个集合中的元素可以被表示成$g^{c_i(\sum b)}$，显然我们只看质数上的结果，将模数变成$p-1$

显然我们只能得到$\gcd(x,p-1)=\gcd(c_i,p-1)$的数，那么记$k=\frac{p-1}{\gcd(c_i,p-1)}$，那么相当于我们要求$\sum b_i$在模k意义下有多少种不同的取值

由于每一个$b_i$都能无限取值，那么只用一个$b_i$可以的取值为所有的$x$，满足$\gcd(x,k_i)=\gcd(b_i,k_i)$，那么记$t=\gcd(b_1,b_2,..,b_m)$，那么相当于可能的取值为$\gcd(x,k_i)=\gcd(t,k_i)$，那么等价于$r_i=\gcd(c_i,p-1)\times \gcd(t,k_i)$，而所有合法的数都需要满足$r_i|x$

那么现在变成了一个经典问题，对于$x\in[0,p-1)$满足$\exist i\in [1,n],r_i|x$，对这样的$x$进行计数即可

考虑到$r_i|p-1$，那么说明不同的$r_i$只有$\sigma(p-1)$个，最多为1100个，那么我们就可以进行容斥，设$dp(i,j)$表示考虑到前i个位置，钦定选择的$r_i$的LCM为$j$的代价

其中可以将第二维用map或者unordered_map进行维护

至于求$\gcd (c_i,p-1)$，那么只需要试除法，试除p-1的每一个因子，看$a_i$剩下的数次方是否为1，如果为1，那么将其除掉即可

时间复杂度$O(n\log ^2p+\sigma(p-1)^2)$

# CF273E Dima and Game

首先考虑用sg函数分析博弈的情况，由于整个游戏是由若干子游戏组成的，并且子游戏之间互不相关，那么根据sg定理可以知道，整体游戏的sg值等于所有子游戏sg值得nim和

设$sg(l,r)$表示区间$[l,r]$之间的游戏，首先考虑两个变化，实际上跟l,r的具体取值没有什么关系，只与$r-l$有关，那么说明$sg(l,r)=sg(l-c,r-c)$

那么我们不妨令$l=1,f(r)=sg(1,r)$

那么有如下两个转移
$$
f(k)\leftarrow f(\lfloor\frac{k-1}{3}\rfloor+1)\\
f(k)\leftarrow f(k-\lfloor \frac{k-1}{3}\rfloor )
$$
首先注意到计算$f(k)$的时候只需要用到$\log k$个取值，并且$f(k)\in\{0,1,2\}$，那么显然$f(k)$连续段数会很少，通过打表可以发现段数和k成$\log $关系

在$k=10^9$段数只有100左右

那么我们考虑将所有段缩起来，首先预处理前$10^7$个的$f(k)$，然后记录每一段，在增加一个新的段的时候可以发现对于不同的k如果$\lfloor\frac{k-1}{3}\rfloor+1$在同一段中，并且$k-\lfloor \frac{k-1}{3}\rfloor $也是在同一段中，那么说这两个位置相同，那么我们可以二分或者直接求出这一段，然后加入到最后，需要注意的是可能加入的新段跟之间的段相同，那么需要将其合并即可

这样的时间复杂度是$O(\log ^2k)$或者$O(\log k)$，但是常数比较大，求出$f(k)$的值之后可以还原出所有区间的sg取值，假设$cnt(k)$表示区间sg值为$k$的个数

那么相当于我们要统计每一位有0,1,2的取值，最终异或和为0的方案数，直接DP统计即可，时间复杂度$O(n)$

# CF249D Donkey and Stars

首先考虑将一个角度表示成向量的形式，假设$\frac{a}{b}=\frac{\sin \alpha}{\cos\alpha}$，那么对应的坐标为$(b,a)$，假设$\alpha _1,\alpha_2$对应的向量分别为$a_1,a_2$

那么考虑一条线段$AB$，那么根据叉积的性质可以知道
$$
AB\times a_1<0\\
AB\times a_2>0
$$
将式子拆开可以得到
$$
ax_a-by_a>ax_b-by_b\\
cx_a-dy_a<cx_b-dy_b
$$
那么记$f_i=ax_i-by_i,g_i=cx_i-dy_i$，那么相当于转化为了一个二维偏序问题，那么按照$f_i$进行排序，然后用树状数组维护g即可

时间复杂度$O(n\log n)$

# CF283E Cow Tennis Tournament

首先求三元环的数量可以通过**补集转化**，先求出不能形成三元环的三元组点对数量，然后再用$\binom{n}{3}$总数量减去不合法的数量即可

观察不能形成三元环的三元组可以发现，这三个点其中一定有有一个点指向其他两个点，那么只要满足这个条件无论剩下的两个点之间如何连边，那么都是不能形成三元环的

那么我们只需要统计有一个点指向其他两个点的数量即可，假设某一个点的出度为$dg_x$

那么答案就是
$$
\binom{n}{3}-\sum\limits_{i=1}^n \binom{dg_i}{2}
$$
那么现在就变成了如何求出某一个点的度数即可

由于题目的操作是将一个区间内的点之间的边进行翻转，那么我们可以用扫描线+线段树维护出某一个点向左边的连边的点有多少被翻转了，那么相当于线段树需要支持单点修改+区间翻转+区间求和

扫描到某一个区间的时候将当前的计数器+1，如果是右端点，那么将计数器-1，并且将区间内的点进行翻转，扫描完往前位置的时候，查看计数器为奇数还是偶数单点修改当前位置即可

那么从前往后扫描线一次再从后往前扫描线一次即可，求出$dg_i$

时间复杂度$O(n\log n)$

# 