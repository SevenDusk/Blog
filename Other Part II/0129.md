# So Many Lucky Strings [Problem - A - Codeforces](https://codeforces.com/gym/103447/problem/A)

## 题目大意

给定一个字符串序列，要求其中有多少个子序列满足将其字符串拼接起来使得其是一个回文串
$$
n\leq 100,\sum |s|\leq 10^5
$$

## 算法讨论

首先将所有串的每一个字符中间加入一个特殊字符，并且最左侧不加特殊字符，最右侧加特殊字符，那么相当于所有回文串都变成了奇数回文串

考虑从回文中心开始扩展，首先可以枚举回文中心在哪一个串的哪一个位置，然后判断一下是否合法，那么可以注意到此时可能在某一侧存在多出来的字符，并且在对应侧一段需要有对称相同的字符与其匹配，那么我们就可以用一个DP进行统计

设$dp(l,r,pos,0/1)$表示当前考虑了区间$[l,r]$的串，并且此时多出来的字符位置是在左侧还是右侧，pos表示从哪里开始多出来

那么转移的时候，考虑加入$l-1$或者$r+1$，根据0/1的取值确定，然后用hash预处理每一个串的正向hash值和翻转后的hash值，那么就可以在$O(1)$的时间内判断是否对称匹配了

时间复杂度$O(n|s|+n^2)$

# Cross the Maze

## 题目大意

给定一个$a\times b$的网格，其中有n个人在不同的网格，n个出口，其中一个出口只能让一个人出去，一个人在一个单位时间内可以向四个方向走一步或者留在原地或者从出口离开，并且要求任何一个时间内，每一个两个人在同一个网格，求所有人都离开的最小时间，并且构造方案
$$
a\times b\leq 100,n\leq 100
$$


## 算法讨论

首先最小时间的上界就是$2n$，因为所有人走到其离开的出口需要的步数$\leq n$，由于不能存在两个人在同一个格子中，那么所有人走过的步数$\leq 2n^2$

由于在某一个时刻至少还可以走$a\times b$步，那么所有离开时间的上界就是$2n$

那么考虑二分答案，那么相当于每一个人每一个时间内可以走向周围格子，考虑网络流，对于每一个时间的每一个格子都建两个点，分别作为连入点和连出点，其中连入点向连出点连一条容量为1的边，那么就限制这个格子在某一个时间内只能存在一个人

一个人就是一个流量，那么相邻时间的相邻格子之间需要连一条容量为1的边，然后对于有出口的格子来说对于所有时间需要连向一个特殊点，然后这个特殊点向汇点连容量为1的边，限制这个出口只能走过一个人

跑最大流即可，如果最大流=n那么说明当前答案比时间答案大

考虑输出方案，一个人的路径相当于就是图上的一个流，那么我们按照时间顺序扫描所有点，然后维护这n个人当前所在的格子，然后通过相邻两个时间格子之间边是否满流确定人下一步走到哪里

# Jumping Monkey II [Problem - F - Codeforces](https://codeforces.com/gym/103495/problem/F)

## 题目大意

给定一个n个点的树，每一个节点都有点权，对于每一个节点为端点路径，所经过的点记录其点权，形成序列的LIS的最大值

## 算法讨论

首先相当于从一个点出现，每一个可以跳到一个比当前点权大的点并且这个点没有走回头路

那么首先考虑从这个点走到下一个点的情况，这样会有三种情况

一开始以1为根dfs一遍

- 第一种情况就是走到子树内部

- 第二种情况是走到到根节点路径上的一个点

- 第三种情况就是除了前两种情况剩下的点

在dfs过程中可以用线段树合并求出第一种情况，设$dp(x)$表示从这个点走向子树最多可以走多少次
$$
dp(x)=\max\limits_{u\in subtree(x),a_u>a_x} dp(u)+1
$$
那么就可以用线段树合并维护子树内所有dp值

那么对于第三种情况，那么相当于这个点的dfs序和x的dfs序列区间是没有交的，并且如果从x走到这样的点话，那么再下一步一定就是向子树内走，那么在处理出dp之后，可以通过树状数组求出，与当前x的dfs区间不交的点$dp(u)$的最大值，第三种情况记作$f(u)$

主要是第三种情况，那么考虑在dfs过程中维护这个点到根路径上的序列，下一步最优的就是走到离x最近并且$a_u>a_x$的u，并且将其$f(u)$和向上走过的答案进行更新，还有一种情况就是下一步走到这个$u$除掉当前dfs的路径的子树的其他子树中

那么主要问题就是在于如何求出去除一个子树其他子树内部的$dp$答案

那么考虑刚才的线段树分治，一种暴力的做法就是对于所有的轻儿子子树一开始先合并在一起，求出去除重儿子子树的答案，然后在合并进来，对于所有轻儿子，枚举子树内的所有点暴力在线段树上进行回退

这样的时间复杂度$O(n\log ^2n)$

事实上如果我们用可持久化线段树合并维护出儿子序列的前缀合并结果和后缀合并结果，时间复杂度就是$O(n\log n)$

