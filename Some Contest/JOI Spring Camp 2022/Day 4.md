# JOISC 2022 Day 4 鱼 2

一开始想的是先求出不能称为最后一条鱼的个数，在吃的过程可以贪心的吃，一旦旁别有可以吃的鱼直接吃掉就可以，那么存在不合法的情况就是存在两个端点$[l,r]$满足$(l,r)$中数的和小于$\min(a_l,a_r)$，那么$(l,r)$中的鱼一定不可能超过这个范围，那么区间内的鱼都是不合法的

但是这样很难用线段树之类的数据结构进行维护，那么就需要换方法

那么我们可以先考虑在线段树节点中维护有多少个鱼可以吃掉当前区间的其他鱼，那么考虑在合并两个节点的时候需要什么信息

首先需要注意是，假设现在需要合并两条鱼$x,y$，那么$x+y\geq 2\min(x,y)$，如果一开始的鱼是$\min(x,y)$，那么进行一次合并可以倍增。由于现在的鱼是$\max(x,y)$，注意到如果我们往左边或者右边无法进行合并的时候，当前的鱼就是$\min(x,y)$，而对于当前的鱼为$\max(x,y)$就一定可以合并

那么可以得到在一个区间内只有$O(\log V)$个位置会阻碍合并的过程，由于是合并两个区间，那么可以考虑对于一个区间维护下标从小到大阻碍合并的位置，从大到小阻碍合并的位置

以从小到大为例，记$s_i$表示从区间左端点到位置$i$所有$a$的和，那么一个位置会阻碍合并当且仅当$a_i>s_{i-1}$，那么可以用一个vector维护这些位置

那么可以通过遍历vector确定可以吃掉一侧区间的鱼是否可以吃掉另一侧的区间

还有一种可能就是一开始一条鱼只能吃掉子区间的一部分鱼，然后拼接上另一个区间之后可以将整个区间吃掉，显然被吃掉的这些鱼一定是子区间的一个前缀或者后缀，并且端点一定是在阻碍合并的位置上

那么可以在所有端点上记录这些只能吃掉一个后缀或者前缀的鱼数量即可

合并的时候同样可以用双指针确定这些鱼可以吃到的范围，如果可以吃掉整个区间那么加入到答案中，如果还是可以吃掉合并后区间的前缀或者后缀同样进行处理，如果只是一个不是前缀后缀的子区间，那么这条鱼一定不能吃掉整个区间，直接舍弃即可

在合并的区间的时候，相当于给右儿子的区间中的所有$s$加上的左儿子区间的和，那么直接判断一下是否还是满足阻碍位置的条件就行

为了方便实现可以在vector中同时记录每一个位置的前缀和

这样的时间复杂度$O(n\log n\log V)$

# JOISC 2022 Day 4 复兴计划

考虑固定询问的$x$，那么我们可以将边集分成两部分，一部分的边集中的边权都是$\leq x$，一部分的边集中的边权$>x$，那么可以分别对这两个边集分别求出最小生成树，那么最终的最小生成树中边一定是在这两个最小生成树中的

如果直接暴力合并的话，时间复杂度$O(nq\alpha (n))$是不能通过的，那么就需要进行优化

可以发现的是每一条边出现在$x$中的最小生成树中的合法$x$一定是一个区间

如果我们将所有边出现的位置的区间求出，那么就可以在$O(q)$时间内计算答案

可以考虑按照边权从小到大加入边，然后同时维护一个生成树，如果当前加入的边可以合并两个联通块的话，那么说明从$x=0$开始这条边一定在最小生成树中，那么就可以确定这条边的出现区间的左端点

如果当前加入的边不能合并两个联通块的话，那么可以找到形成环中边权最小的边$(u,v)$，那么当前边能够出现在最小生成树中需要满足其权值比$(u,v)$这条边的权值小，那么就可以确定当前加入边区间的左端点。然后将$(u,v)$这条边删除，加入当前边即可

由于加入的边都是按照权值从小到大加入的，那么我们当前维护的生成树就是前缀的最小生成树，并且同时考虑了后缀最小生成树中的边的影响

这样的时间复杂度可以做到$O(mn+q)$，如果使用LCT，可以做到$O(m\log n+q)$

