# B.Browsing The Collection

首先限制集合中可能的元素都是某一个位置$a_i$中可能$j$组成的集合，记一个状态为$(i,s)$表示第i个位置的限制集合就是$s$，对于$j\in s,(j,a_{i,j})$形成一个限制，那么总共可能的限制集合个数为$n\times 2^m$，那么考虑对于每一个限制集合$f$求出一个下标形成的环$cir_f$，使得所有$i\in cir_f$满足这个限制集合，显然对于一个状态$(i,s)$来说只会出现在其中一个$cir_f$中

如果将所有操作看成图中的边，那么相当于我们要求这张图从某一个节点出发到达其他节点的最短路

然后考虑左右移动的操作，由于一个状态只会出现在一个环中，那么可以求出这个状态在环上的相邻节点即可，对对于删除操作直接进行即可，但是对于add操作就比较复杂

就是考虑一个$j\not\in s$然后加入一个限制，得到新的集合$g$，那么显然$cir_g\subset cir_f$，假设$cir_g$出现过的**位置**在会在$cir_g$分成若干段并且这些段中状态会连向对应$cir_g$中的某一个状态

![20220209T1](D:\Blog\image\20220209T1.png)

类似这样的，其中黑色点代表$cir_f$红色点代表$cir_g$

这样得到的图的总边数为$n^22^m$，然后再固定起点进行bfs的复杂度是$O(n^32^m)$

考虑优化，一种做法是由于每一个环连到一个点的集合都是一个区间，那么可以对每一个环建出线段树，然后线段树优化建图，但是比较难写，还有一种做法是使用bitset

如果考虑在进行松弛的过程中进行优化，多对一的关系是难以进行处理的，那么如果反过来，就是我们固定终点，从终点开始bfs，那么相当于我们在对红色节点进行操作的时候，需要对一个黑色节点区间进行操作，并且由于边权都为1，那么一旦可以进行更新，那么一定会被更新到

那么相当于每一次需要删除这个区间内还没有被删除的点，然后将这些进行更新加入bfs的队列中即可，我们就可以用链表或者并查集维护下一个没有被删除的点，并查集会比较方便，可以动态更新之前被删除点的下一个位置

那么这样的时间复杂度就是$O(n^2m2^m\log n)$

# F.First Occurrence

肯定是要递归考虑的，一开始的想法是按照将奇数位置和偶数位置分开，然后分别求最小出现位置，但是这样需要求出所有出现集合，显然是不行的

但是这个序列的递归性质很强，如果每$2^i$个分成一组，如果将一组内所有位置与第一组相同记作0，全部取反记作1，那么仍然是得到原来的序列

就需要考虑向下递归一层的结果，那么我们按照2个分成一组，显然一组之内的两个数字是不同的，那么就需要将原来的序列分成若干组，一组之内的两个数字不同

注意到如果原来$[l,r]$的序列长度$\geq 4$那么一定存在两个相邻的位置数字相同，那么能够划分的方案就是按照原来序列的划分方案进行划分

一组之内有两种情况，01和10

还有一个问题就是如果开头位置并不是在一组的第一个字符，而我们递归下去找的是整一组的结果，两种情况的答案是否存在偏差，事实上是不会的，就是如果确定了一组第二个字符相当于就是确定了整一组的情况

那么我们记$f(l,r)$表示答案
$$
f(l,r)=f(\lfloor\frac{l}{2}\rfloor,\lfloor\frac{r}{2}\rfloor )+[l\bmod 2\equiv 1]
$$
然后对于长度如果$\leq 3$的话，直接暴力求答案即可

# K. Kilk Not

首先需要二分答案，假设二分的是$mid$

那么我们需要判断在强制要求最长连续段长度$\leq mid$的情况是否存在一种分配方案使得有a个?变成了0，b个?变成了1

那么可以DP，但是存在分配个数的限制，会使得DP状态中至少存在两维，这样复杂度只能是保证在$O(n^2)$及以上，那么就考虑要去掉这个限制

有一个结论就是可以填入0的个数是一段区间，那么就只需要求出最小可能个数和最大可能个数，只要a在这个区间内就是合法的

但是如何证明这个结论，一种方式就是打表，在写出暴力DP的时候将取值打印出来，可以发现是一段区间合法

就是考虑让0最多的情况和0最少的情况，两种串分别记作$S,T$

那么我们可以通过拼接S的一个前缀和T的一个后缀得到结果，考虑一开始只有S的长度为n的前缀，当前0的个数最多，然后不断将最后一个字符替换成T中对应位置的字符，如果将0->1那么个数会减少1，如果将1->0那么个数会增加1，最终0的个数会变成最小的情况

由于中间变化量=1，那么最小情况和最大情况中间任何一种情况都是合法的

但是唯一需要确定的是在整个过程中不会出现连续段长度$>mid$的情况，可能出现不合法的情况就是出现在0->1或者1->0的情况

以0->1的情况为例，如果加入之后不合法，那么说明这个位置$i$左侧一定是一段连续的1，假设长度为$L$，再假设$i$右边的1连续位置到$j$，首先我们可以找到其中第一个不是确定位置的1记作$pos$，那么如果只看$[pos,j]$的话，显然一定要是合法的
