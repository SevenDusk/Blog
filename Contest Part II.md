# 8.26

## 匹配

### 题目大意

![20210826T1](D:\Blog\image\20210826T1.PNG)

### 算法讨论

考虑如何计算出来最小的$\sum |A_i-B_{p_i}|$，考虑两个棋子之间的空隙会被经过多少次，就是这个空隙左边A，B棋子的差，如果我们确定一个匹配是A指向B，那么同时也可以确定这个空隙被经过的方向

那么回到这问题上来，由于题目需要的是字典序最小的$p$，那么考虑从下标小的开始求出对应的最小的$B$

**根据上面的讨论可以发现一个A的棋子匹配B的方向需要跟空隙中的方向一致，并且所有空隙中的方向都要一致**

那么一开始只需要处理极长的连续同方向的空隙，并且处理这个空隙可以被经过多少次，每一次匹配时都要将区间内的空隙的次数-1

现在我们需要维护的这个空隙的序列并且支持区间减，二分出第一个次数为0 的位置，只需要一个线段树维护就可以了

然后我们还需要求出一段区间内B最小的编号是什么，还需要支持单点修改，那么也是一个线段树就可以解决的事

时间复杂度$O(n\log n)$

## 游戏

### 题目大意

![20210826T2](D:\Blog\image\20210826T2.PNG)

### 算法讨论

显然对于一个问题来说，只有三个变量会影响答案，那么就只需要将这个三个变量记录到DP状态里面，然后考虑转移即可

设$f(n,m,k)$表示这个问题的答案

转移的时候枚举当前的下注$x$​，由于我们是求最优决策在最坏情况下的答案，那么外层一定是一个max，内层就是min
$$
f(n,m,k)=\max\limits_{x=0}^k \max(\min(f(n-1,m,k+i),f(n,m-1,k-i)),\min(f(n-1,m,k-i),f(n,m-1,k+i)))
$$
直接转移的复杂度是$O(nmans^2)$​会超时

首先$f(n,m,k)=f(m,n,k)$，那么下面默认$n<m$

#### 处理 1

注意到$f(n,m,k)$是关于n递减的，那么最大的答案只有5000多，那么说明我们的k一定是$\leq 5000$

由于不同的n的上限也是不同的，那么只需要打表求出这个上界就可以了

然后在记忆化搜索的过程中，判断k是否在这个上界中就行了

#### 处理 2

是一个剪枝搜索，注意到如果$f(n,m-1,k-i)$​小于当前的$f(n,m,k)$​，那么就没有必要搜索$f(n-1,m,k+i)$了，另外一边也是同理

**需要注意的是必须先搜索$f(n,m-1,k-i)$​因为k会变小（比赛的时候就是搞反了）**

#### 处理 3

二分最优决策，由于这个函数是递减的，那么只需要让$f(n,m-1,k-i)$和$f(n-1,m,k+i)$的差尽可能小

#### 处理 4

考虑在$\frac{m-n}{n+m}k$​附件寻找最优决策点

#### 处理 5

考虑将整个过程倒过来，我们可以二分枚举最终得到的答案$mid$，按照最优策略，检查进行n+m轮操作过后最多得到的钱是否$\geq k$

那么考虑递推转移记$a_{n,m}$表示状态，首先$n=0$或者$m=0$的情况很好处理，就是上次赌所有的钱，$a_{n,0}=\lceil\frac{a_{n-1,0}}{2}\rceil$

然后考虑$n,m\neq 0$的情况

由于有两种情况，$(n,m)\rightarrow (n-1,m),(n,m-1)$​​，那么根据**处理 3**可以知道，肯定是让这两种情况跟$(n,m)$的差的最大值尽可能小，那么取他们的中位数就可以了，那么有
$$
a_{n,m}=\lceil\frac{a_{n-1,m}+a_{n,m-1}}{2}\rceil
$$
时间复杂度$O(nm\log ans)$

## 矩阵

### 题目大意

![20210826T3](D:\Blog\image\20210826T3.PNG)

### 算法讨论

显然需要一行一行的进行DP，并且我们从后往前考虑

先设$dp(i,j)$表示当前走到第$i$​行第$j$个格子上的答案

然后就需要考虑在第i行这一行中反复走的过程

由于在同一行走过的格子一定是一段区间，那么设$f(l,r,0/1)$表示已经走过了$[l,r]$​区间内格子，当前在左端点还是右端点的答案

转移的时候只需要讨论下一步是向右走还是向左走就可以了

综合两个DP的答案就是可以得到最终结果

##  猫

### 题目大意 ![20210826T4](D:\Blog\image\20210826T4.PNG)

### 算法讨论

考试的时候以为是最后一题不可做，就没有多想，说明考试的时候每一道题都要分配合理的思考时间

还是比较显然可以想到二分答案，那么我们要做的就是检查$mid$是否合法

首先一开始如果前面的猫可以不搭乘运输器就可以在$mid$的时间之内走到目标节点，那么运输器就不搭载这些猫

我们需要尽可能减少停靠的次数，那么就一直走，直到运输器上搭载的最左边的猫pos恰好可以走到其位置上才停靠一次，具体的说如果当前走到$a_{pos}$的时间花费是$t$，那么最多可以走的距离是$\lfloor\frac{mid-t}{12}\rfloor$

那么同时让右边可以走到的猫也送下运输器，然后更新当前运输器 的位置

只要判断是否超时就可以了

时间复杂度$O(n\log n)$

# 8.29

## A.进度

### 题目大意

![20210829T1](D:\Blog\image\20210829T1.PNG)

### 算法讨论

首先我们只考虑那些1和n之间的那些边和点，称$i$号点为好点当且仅当$1$号点可以到达$i$号点，$i$号点可以到达$n$点，边的定义也是同理

如果给所有除了$1,n$号节点的好点钦定一条出边，那么剩下没有被钦定的边的数量就是答案

首先1号节点是没有被钦定出边的，那么说明所有这些钦定为某一个点的出边的边是构不成一条从$1$到$n$的路径的，那么任何一条路径都是包含至少一条没有被钦定的边

考虑一条没有被钦定的边$u\rightarrow v$，那么首先$v$可以通过那些被钦定的边直接走到$n$，不会使用任何新的没有被钦定的边，那么只需要1可以通过钦定的边或者已经使用过的边到达$u$即可

那么可以使用像bfs过程构造这个顺序

还有一种方法就是考虑点减边这个势能函数

# 9.5

## A.三角形

### 题目大意

![20210906T1](D:\Blog\image\20210906T1.PNG)

### 算法讨论

考虑将三元环函数化，变成一个构造函数的问题

假设有二元函数$f(i,j)$表示包含$i,j$的三元环另外一个点为$f(i,j)$

这个函数需要满足以下几条限制

- $f(i,j)=f(j,i)$
- $f(i,k)=j$
- $f(k,j)=i$

如果列出这几个条件，会发现$f(i,j)=-(i+j)\% n$就是满足条件的，枚举$i,j$如果边没有重复那么就选取，这样每一个点连出的边最多只有一个没有被三元环覆盖

像这种构造题转化为构造函数的方法值得借鉴

## B.区间

### 题目大意

![20210906T2](D:\Blog\image\20210906T2.PNG)

### 算法讨论

首先如果一个大区间覆盖了一个小区间，那么这个大区间要么跟这个小区间在一个组内（不会产生任何影响），要么单独在一个组内（因为加到其他组只会减少交的长度，肯定不优）

那么如果将所有有包含区间的大区间去掉，**那么剩下的区间之间的关系只有相交或者不交，那么如果按照左端点排序，那么其右端点一定是递增的**

那么说明同一组的区间在这个区间序列中一定是一段区间，那么设$dp(i,j)$表示当前考虑到第$i$个区间，分成了$j$个组的最大答案
$$
dp(i,j)=\max\limits_{k< i} dp(k,j-1)+r_{k+1}-l_i
$$
最后需要考虑那些去除的大区间，按照长度排序，选取前$k-j$大的

时间复杂度$O(n^3)$

## C.三染色

### 题目大意

![20210906T3](D:\Blog\image\20210906T3.PNG)

### 算法讨论

由于要联通，那么至少这些黑色边要形成一个树，不妨就让这个树为这张图的dfs树

首先将这些树上的点黑白染色，黑色点和白色点染成的颜色不能相同，假设黑色点有$a$个，白色点有$b$个，令$a\leq b$

#### $a\geq \frac{n}{3}$

由于黑白色的点数量比较接近，考虑构造方案使得满足第一种条件

首先将黑色点按照树上的度数进行降序排序，然后将前$\frac{n}{3}$个点染成一个颜色，这时候需要发现一个结论

> 对于剩下的黑点其在树上的度数$\leq 2$

考虑反证，如果剩下黑点中度数最大的$>2$，那么前$\frac{n}{3}$的度数$\geq 3$，其连出的边至少有$\frac{n}{3}*3=n$条，与树的结构矛盾

由于剩下的不超过$\frac{n}{2}-\frac{n}{3}=\frac{n}{6}$，那么最多有$\frac{n}{3}$个白点与其相邻，那么只要将所有剩下的黑点和一部分与之不相邻的白点染成一个颜色，再将剩下的白点染成一个颜色即可

#### $a\leq \frac{n}{3}$

考虑构造满足第二种条件

如果将所有白色叶子节点删除，那么剩下的树的叶子节点一定都是黑色，那么白色节点的数量$\leq $黑色节点的数量

那么说明在原来的dfs树中，白色非叶子节点数量$\leq \frac{n}{3}$，由于$b\geq \frac{2n}{3}$，那么说明白色叶子节点数量$\geq \frac{n}{3}$，由于dfs树的性质，只存在返祖边，那么所有叶子节点之间是没有边存在的，那么只需要给所有叶子节点然同一种颜色即可

剩下黑色节点和白色非叶子节点染另外一种颜色

## D.匹配

### 题目大意

![20210906T4](D:\Blog\image\20210906T4.PNG)

### 算法讨论

首先$n$为奇数的时候一定无解

考虑删去树上的边$(u,v),v=fa(u)$，如果$u$子树的大小为偶数，那么显然另外一部分也是偶数，那么这两个部分都必须要有完美匹配，贡献就是$sz(u)(n-sz(u))$

那么只剩下分出的部分都是奇数的情况，那么显然每一个部分都必须要恰好一个点没有被匹配，然后在这两个点之间连边即可

显然两个部分是独立的，分别算出有多少个点符合条件，然后相乘起来就是对答案的贡献

考虑设$dp(i,0/1,0/1)$表示$i$子树内，$i$这个节点是否匹配，子树内除了根节点是否存在一个没有匹配的节点的方案数，考虑合并两个有父亲儿子关系的子树，$x=fa(u)$
$$
dp'(x,0,0)=dp(x,0,0)dp(u,1,0)\\
dp'(x,1,0)=dp(x,0,0)dp(u,0,0)+dp(x,1,0)dp(u,1,0)\\
dp'(x,0,1)=dp(x,0,1)dp(u,1,0)+dp(x,0,0)(dp(u,1,1)+dp(u,0,0))\\
dp'(x,1,1)=dp(x,0,1)dp(u,0,0)+dp(x,0,0)dp(u,0,1)+dp(x,1,1)dp(u,1,0)+dp(x,1,0)(dp(u,1,1)+dp(u,0,0))
$$
然后由于要求出去除一个子树的联通块信息，那么需要换根DP，但是这里是合并子树的做法，存在乘法，如果直接撤销可能会出现除以0的情况，那么就需要在转移的时候，记录前缀合并的结果，后缀合并的结果，然后将两个合并起来（这里的合并不是合并子树的那种，而是合并答案）
$$
dp'(x,0,0)=dp(x,0,0)dp(u,0,0)\\
dp'(x,0,1)=dp(x,0,0)dp(u,0,1)+dp(x,0,1)dp(u,0,0)\\
dp'(x,1,0)=dp(x,1,0)dp(u,0,0)+dp(x,0,0)dp(u,1,0)\\
dp'(x,1,1)=dp(x,1,1)dp(u,0,0)+dp(x,1,0)dp(u,0,1)+dp(x,0,1)dp(u,1,0)+dp(x,0,0)dp(u,1,1)
$$

#### 另解 1

设$dp(i)$为一个二元组，第一个位置记录$i$子树内最大匹配的大小，第二个位置记录在最大匹配的情况的方案数

同时dfs的时候需要记录一下子树的大小为偶数的数量，加上第一维才是真正的匹配大小（因为要计算方案数）

如果为偶数，那么用$dp(i).first-1,dp(i).second$更新

否则用$dp(i).first+1,dp(i).second$更新

至于换根部分也是同理，由于也是存在乘法，需要记录前缀和后缀和

#### 另解 2

可以将$dp(x,0/1,0/1)$的转移方程写成类似矩阵乘法的东西，并且满足交换律，然后将转移的相交即可
