# 数据结构

# 1.求$depth[LCA(i,j)]$处理办法

将$i$到$root$的路径所有的点权值加一，然后询问$j$到$root$的路径的点权之和，就是$LCA$的深度

$LCA$可以看成两个点到根的两条链的第一个交点

# 2.LCT维护边权

将边看作一个点，将这个代表边的点的点权赋为这条边的边权，并将其他的点边权设为$0$或其他不影响答案的值

在连边或断边时，设这条边两端的端点为$u$,$v$，代表边的点编号为$id$

```cpp
link(u,id),link(id,v);
cut(u,id),cut(id,v);
```

# 3.LCT维护子树信息

维护一个点由虚边连结的点的信息$si$，然后再维护所有的边（包括虚边和$Splay$上左右儿子）相连的儿子和自己的信息$s$

因为虚实边会随着LCT的操作不断变化

首先在$pushup$的时候，$s[x]=s[son[x][0]]+s[son[x][1]]+si[x]+val[x]$，保证$s$的值实时更新

$access$的时候因为去掉了$x$之前的实儿子（变为了虚儿子），增加了一个新的实儿子（由原来虚儿子变来），$si$一加一减，$s$不变化

```cpp
for (int y=0;x;x=fa[x])
{
    splay(x);
    si[x]+=s[son[x][1]];
    son[x][1]=y;
    si[x]-=s[son[x][1]];
    pushup(x);
    y=x;
}//access
```

在$link$的时候增加了一条虚边，改变$y$的$si$，要注意要将$y$转到根上，以免改变其他节点的值

```cpp
inline void link(int x,int y)
{
    makeroot(x);
    access(y);
    splay(y);
    fa[x]=y;
    si[y]+=s[x];
    pushup(y);
}
```

$cut$因为切掉的是实边，对$si$无影响，注意$pushup$即可

还有这里可以维护的信息是满足加减性的，如子树大小，子树权值和

但像子树权值最大值是不满足加减性的，不能维护（据说可以每个节点将$si$和$s$改成一棵平衡树）

在求出$x$子树的信息的时候，$access(x)$后取出$si[x]$即可

# 4.维护区间中位数

可以二分答案，将$\geq x$的数标记为$1$，$<x$的数标记为$-1$，利用维护区间和，若某一个区间的和大于$0$，则这个区间的中位数$\geq$当前二分的数，若某一个区间的和小于$0$，则这个区间的中位数$\leq$当前二分的数

# 5.树上任意一点的最远距离

树上任意一点的最远距离就是树上直径的两个端点到该点距离的较大值

证明：利用反证法

对于一条直径两个端点$u$,$v$

若存在一条路径$x\rightarrow y$，且满足$len(x,y)>len(x,u)$,$len(x,y)>len(x,v)$

设直径和路径的交点为$a$

则可以找到一条比原来直径更长的路径$u\rightarrow a\rightarrow y$

与直径的定义矛盾

# 6.树联通块直径

两个树联通块合并之后，直径的两端点一定在原来两个联通块的直径的四个端点内

然后在这四个端点处枚举即可，判断剩余两个点是否在选出的两个点形成的路径上

$P.S.$ 判断一个点在一条路径上的充分必要条件是

设路径为$x\rightarrow y$，当前要判断的点为$u$

那么$depth[u]\geq depth[LCA(x,y)]$并且 $LCA(u,x)=u$或$LCA(u,y)=u$

# 7.利用树剖维护修改所有儿子信息

可以先修改节点和重儿子的信息，并将修改的信息记录在节点上，在询问的时候跳轻边的时候，将信息更新即可

相关题目[Tree Queries](https://codeforces.com/problemset/problem/1254/D)

# 8.最大化AND,OR

当操作是XOR时可以简单地利用Trie来进行维护，但当是AND的时候，由于当去匹配的数当前这一位是0时，不知道应该是走0还是1，如果两个子树都走下去的话，复杂度不对，那么考虑将1子树合并到0子树上，然后查询的时候如果当前这一位是1那么走1子树，如果是0就走向0/1子树。这样单次询问就是$O(m)$，预处理为$O(m2^m)$，$m$为位数，适用于$m$比较小的情况

# 9.点分树

点分树就是在点分治的时候将每一层的重心连起来所形成的一颗树，具有一些优良的性质

1.首先点分树的最大深度为$log_{2}^n$，可以通过这个性质来在点分树上维护一些点分治可以维护的信息，记录点分树中子树的信息，通过修改询问的时候不断跳父亲，来得到答案，但同时这里需要注意，在从$x$跳到$fa[x]$时，如果直接统计$fa[x]$的所有子树信息，会把x子树重复统计，那么就需要在每一个节点记录这个子树到节点父亲的信息，最终容斥计算

这里的空间复杂度$O(n*pertime)$，时间复杂度$O(nlog_{2}^{n}*pertime)$

2.点分树还有具有类似Kruskal重构树的性质，对于节点$x$，任意两个节点$u,v$，保证$u,v$不在$x$在点分树的同一棵子树，那么$u->v$一定经过$x$，那么$dis(u,v)=dis(u,x)+dis(x,v)$，那么可以利用这个性质来加速一些在树上跳的问题

# 10.三度化

对于无根树上一些依赖于每个节点的度数的算法，可以利用把树转为二叉树来做，那么度数就变为3，其实也就是边分治的思想

一种方法是

<img src="D:\Blog\image\1614195-20201022221928001-1687003134.png" style="zoom:33%;" />

<img src="D:\Blog\image\1614195-20201022221923199-755636503.png" style="zoom:33%;" />

# 11.对于$ax_i+by_i$的优化方式

$ax_i+by_i$中$a,b$是给定的参数。那么可以将每一个$x,y$看作一个二维平面坐标系上的一个点

令$ax+by=c$

那么$y=-\frac{a}{b}x+\frac{c}{b}$

那么就是相当于一个斜率为$-\frac{a}{b}$的直线去截平面上的点，然后通过计算得到在y轴上的截距，然后乘上$b$，要得到最大\最小值

那么可以维护平面凸包来实现，所截到的最优点一定是在凸包上的

# 12.吉司机线段树

势能函数啥的我也没听懂，不管他

吉司机线段树以其优秀的性质可以维护各种duliu信息

然而我只会区间$max/min$（我觉得就这个有点用吧）

以取$min$为例，就是在线段树中维护最大值$MAX_0$，次大值$MAX_1$和相应出现的次数，注意此处的次大值是要严格小于最大值的（如果不存在次大值那么可以将其赋为$-inf$）

当每次更新的时候检查当前节点设当前需要取$min$的是$t$

如果$t \geq MAX_0$那么说这个区间什么也不会发生，那么直接返回

如果 $t \leq MAX_1$那么说明更新的区间内会变化的数不止一个，那么继续递归下去

如果$ MAX_1 < t < MAX_0 $那么这个区间内会被更新的数只有$MAX_0$一个数，那么直接打上减法标记，然后修改$MAX_0$的值为$t$

时间复杂度大概感性理解一下

就是区间取$min$操作会使序列中的数趋于相同，每一次第三种操作更新的时候更新一个数，然后第二种情况递归下去，肯定会减少区间中不同数的数量，这样的区间每次询问最多$log$个，那么就是$nlogn$的复杂度

如果要区间加减，那么就是$log^2n$

# 13.询问集合中第$k$大/小

就是给定一种生成某一集合的方法，一般是给出一个序列每一个数可选可不选，问集合中第$k$大的数是多少，往往这个集合是巨大的（指数级别），有一种方法可以从小到大构造出集合中的数

先把序列排好序

设二元组$(sum,id)$表示当前操作出来的数为$sum$，并且当前考虑到序列中第$id$个数的状态，并且第$id$个数必选

然后可以进行转移

$(sum,id)\rightarrow (sum+a[id+1],id+1)$

$(sum,id)\rightarrow (sum+a[id+1]-a[id],id+1)$

相当于是进行$0/1$背包的过程，这个二元组可以用堆来进行维护

如果可以选多个，那么多一个转移

$(sum,id)\rightarrow (sum+a[id],id)$

相当于在做无限背包

再拓展如果每一个数有一个选择上限，那么需要用三元组来记录状态即$(sum,cnt,id)$其中多出来的$cnt$表示当前这个数选了$cnt$次，其他转移同理进行即可

再再拓展每一个数有一个下限和上限，那么在三元组的基础上，在进行转移到下个数的时候，选下限个数即可，就可以保证满足限制了

# 14.摩尔投票法

这是一种可以在$O(n)$时间内统计出众数的东西，其思想值得借鉴

由于众数在整个序列种出现了超过一半的数量，那么如果用这个数与其他的数两两抵消，那么剩下的一定是那个众数

那么就可以维护一个栈，如果栈顶元素等于加进去的元素，那么就把这个元素压入栈中，否则就弹出栈顶元素

扩展一下可见[CF643G](https://codeforces.com/problemset/problem/643/G)

# 15.单调栈维护凸包

对于一些，加入直线斜率不单调，但是满足当前加入的斜率是当前最优，那么可以用单调栈维护凸包，以上凸包为例，首先要保证栈中的直线斜率是递减的，把所有比当前加入直线斜率大的弹出去，然后凸包内的直线与加入的线的交点应该是要递增的，再利用这个一个限制去弹出栈内的元素

可以应用于一些DP中

[交通运输](https://dev.xjoi.net/contest/1596/problem/2)

# 16.$SAM$后缀自动机

东西挺多的

$SAM$中每一个节点都是一个$endpos$的等价类，节点与节点之间有字符的转移。构成的$SAM$是一个$DAG$，每一个在原串中本质不同的子串都唯一对应一条在$SAM$从初始节点出发的路径

可以发现对于一个节点的那些串，如果以长度升序排序后，前一个串是后一个串的后缀并且长度相差$1$，那么记最长的那一个串长度为$len(x)$，最短的一个串为$minlen(x)$，定义后缀链接为这个串最长一个串的$endpos$不和当前节点的$endpos$集合相同的节点，那么可以发现$len(link(x))=minlen(x)$，那么可以知道一个点所包含的本质不同子串个数就是$len(x)-len(link(x))$

首先是其构造，大概流程就是，在构造过程中记录前面一个前缀的节点，在后面添加一个字符的时候，新建一个节点$x$，先不断地扩展那些没有当前字符转移的节点，把这些节点的这种字符转移转移到当前节点$x$上，设第一个以前就有这种字符转移的节点为$p$，转移到的节点为$q$，如果$len(q)=len(p)+1$，那么直接把x的后缀链接设为$q$，否则克隆出一个新节点$cl$，令$len(cl)=len(p)+1$并且把所有小于其长度的节点重定向为$cl$，最后把$q$和$x$连接到$cl$上

可以发现$link(x)$形成了一个树形结构，那么这棵树就叫$parent$树，这棵树有很多性质

如果设那些前缀节点为终点，那么终点的$endpos$集合就是对应前缀的下标，那么对于任意一个节点来说，其$endpos$集合就是这个节点在$parent$树上子树所有终点构成的集合，那么可以方便通过一次$dfs$维护出所有节点$endpos$集合的大小，对于具体位置是哪些需要线段树合并来做

对于$parent$树上节点$x$，那么节点$x$到根路径上所有节点对应字符串恰好构成了所有$x$节点的后缀，相当于划分成了若干个区间，并且这些区间不交

那么在$parent$树上跳类似于$AC$自动机上建出的失配树上跳，只不过$SAM$相当于把所有子串建出了一个压缩版的$AC$自动机，那么这个东西可以做类似求两个串最长公共子串的问题，就是不断尝试去匹配，如果匹配失败就跳$parent$树，直到跳到空节点或者重新匹配上

《各 种 套 路》

# 17.对于询问区间定长设关键点

如果每一次询问的区间都是相同长度的，设长度都为$k$，那么可以在原序列上每隔$k$个点设一个关键点，然后在关键点上记录这个点向后$k$个的后缀信息，向前$k$个的前缀信息，那么每一次询问的区间一定覆盖了某一个关键点，那么利用关键点的信息即可

# 18.点减边

对于树上路径问题，如果考虑重链剖分的话，会把某一条路径拆成$log$个区间，对于那些某一条路径只计一次数的问题，如果对于每一个区间都进行一次统计的话会算重，那么可以考虑统计是区间内的点和边的数量

然后最后统计答案的时候相减，只会得到$0/1$的答案，还有注意在重链剖分的时候，需要将每一条链顶上面的那条轻边算到这条链上来

具体问题具体分析

# 19.回滚莫队/莫队二次离线

### 回滚莫队

回滚莫队可以处理删除难以进行删除操作的问题，首先如果询问的两个端点在同一个块内，那么直接暴力计算，对于左端点同一个块内的右端点递增排序

考虑进行询问的时候，对于同一组内的询问，将两个指针移动到这个块的右端点，对于组内某一个询问，先将右边那个指针移动到对应位置，然后左移左指针，直到询问位置，求出答案后，将左指针移动所产生的修改撤回，移动回当前块的右端点

### 莫队二次离线

设处理单次询问的复杂度为$O(k)$，莫队二次离线可以将总复杂度，从$O(kn\sqrt(n))$，优化至$O(n\sqrt(n)+kn)$，前提条件是询问的内容是可差分的

考虑移动左右端点的贡献，记$f(x,[l,r])$表示$x$这个位置，对于区间$[l,r]$的贡献

移动左端点时$f(l,[l+1,r])=f(l,[1,r])-f(l,[1,l])$

移动右端点时$f(r,[l,r-1])=f(r,[1,r-1])-f(r,[1,l-1])$

那么就可以将询问拆开，再一次离线下来处理$f$，由于区间都是一个前缀，那么只要从前往后扫描序列就可以统计答案

具体来说注意到$f(l,[1,l])$和$f(r,[1,r-1])$这只有$n$种可能，直接计算，对于其他的，由于保证了另一个端点不动，那么只要把修改的区间加入对于另一个端点所处前缀的询问中去即可

细节较多，需要注意正负号的变化

# 20.树上点集最小连通块

将点集内的点按$dfs$序排序，然后顺次求出两两之间的距离之和，再加上 首尾两个点的和，除以二就是所需最小联通块的边数
$$
the\ edge\ in\ component=\frac{len(a_1,a_2)+len(a_2,a_3)+...+len(a_{n-1},a_n)+len(a_1,a_n)}{2}
$$


证明就是类似欧拉序一样，可以发现如果将所有连通块内的边拆成两条，然后按$dfs$序的顺序走，那么一定是构造出了一个欧拉回路，那么每条被拆的边走过了一次，那么就是总边数的两倍

# 21.三维偏序

有一种吊打$O(nlog^2n)$的做法

三维偏序有$3$维$(a,b,c)$要满足$a_i<a_j,b_i<b_j,c_i<c_j$

那么首先对$(a,b)(b,c)(a,c)$分别做一遍二维偏序

可以发现除了$a_i<a_j,b_i<b_j,c_i<c_j$和$a_i>a_j,b_i>b_j,c_i>c_j$的无序对$(i,j)$被统计了三次以外，其他都是被统计了一次

那么只要减去总无序对数量再除以$2$就是答案

# 22.利用Trie树维护全局加1

此操作需要在已知上限或者在模意义下进行

每一次修改就从根往下走，从低位到高位进行考虑

假设当前节点为$x$，那么交换$x$的$0/1$儿子，然后递归进入原先$1$儿子（相当于进位）

那么每一次操作复杂度$O(\log n)$

其他进制下也是同理

# 23.统计子树信息

如果对于一些可以加减的信息，需要统计每一个节点子树内的信息

在$dfs$过程中考虑维护一个储存信息的数据结构（并且要求可以支持信息的加减）$S$表示当前已经$dfs$节点的信息之和

在遍历节点$x$时，进入的时候记录$S$，回溯的时候记录$S'$，那么$x$子树内的信息之和即为$S'-S$，并且更新$S$

相当于是在$dfs$序上记录了一个动态的前缀和，由于子树一定在$dfs$序上是一个区间，那么只要将两端的前缀和相减即可

# 24.树分块

对于分块的块长$B$，该算法可以将树划分成大小在$[B,2*B)$范围内的连通块

在dfs过程中，记录一个栈，在访问到当前节点时候记录当前栈的大小$t$，先去遍历儿子，当遍历完某一个儿子树时，若当前栈中元素个树$\geq t+B$，将栈中元素一直弹出直到栈中元素个数等于$t$，弹出的节点构成了一个块，这个块的根节点就是当前dfs到的节点

**一个块中可能不联通，但是加上根节点一定联通，根节点可能不属于这个块**

所有块构成了一个树形结构 