# 1.在基环树上DP

主要思想是将基环树上的环断开，然后做树形DP

最后处理这一条边对答案的影响

# 2.在数列上划分并要求划分区域递增的DP

基本的DP转移是

$dp[i][j]=\max{dp[j][k]}+v(i)$

其中 $i$到$j$的区间和大于 $j$到$k$的区间和

朴素复杂度$O(n^3)$

可以使用单调队列优化到$O(n^2)$

利用固定j的取值

所以$i$增加的同时，$k$的范围也相应变大，利用单调队列和单指针维护

例如[P3089](https://www.luogu.com.cn/problem/P3089)

但如果$v(i)$有单调性，可优化到$O(n)$，如[P5665](https://www.luogu.com.cn/problem/P5665)

# 3.期望DP的转移

由于期望DP常常是由结束状态推到状态，并且不确定性，常常会出现既要从前面转移当前DP，又要从后面转移当前DP，会导致需要高斯消元，但不过高斯消元的常规复杂度都是$O(n^3)$，复杂度较大，并且难以优化。但如果DP转移方程，项数较少，可以利用数列的递推，来进行解决

以[[六省联考2017\]分手是祝愿](https://www.luogu.com.cn/problem/P3750)为例

DP转移方程：$dp[i]=\frac{i}{n}dp[i-1]+\frac{n-i}{n}dp[i+1]+1$

可以发现这个式子可以直接高斯消元，但时间复杂度承受不起

考虑可以设一个递推关系，可以注意到dp[i]只跟前后两项有关

那么设$dp[i]=dp[i-1]+f[i]$

代入$dp[i]=\frac{i}{n}(dp[i]-f[i])+\frac{n-i}{n}(dp[i]+f[i+1])+1$

化简得到$f[i]=\frac{n-i}{i}f[i+1]+\frac{n}{i}$

那么就可以从后往前递推得到$f$

可以根据具体题目的转移方程来改变设的数列

# 4.区间DP的模型

对于操作为删除一段连续的区间，然后将左右两端的区间拼接起来的操作，可以考虑以下的$dp$状态设计

$dp[l][r][k]$表示删除$[l,r]$这个区间并且$[l,r]$这个区间左边与$a[l]$信息有关的位置个数有$k$个的代价

转移时$dp[l][r][k]=dp[l+1][i-1][0]+dp[i][r][k+1]+...$，其中$a[i]$与$a[l]$相等

或者$dp[l][r][k]=dp[l+1][j][k+1]+...$

复杂度为$O(n^4)$，跑不满，$100$随便跑

考虑这样设状态的原因，因为删除一段区间可以将两端的信息拼接起来，如果直接记录左右两端的信息会需要两维的DP，那么在某一个拼接起来的区间的最右端记录左边的信息，那么可以用一维的空间记录下。在转移的时候，第一个的转移方程就是在中间扣掉一段区间，将之前左边的信息合并到当前来

有关的题目

[[COCI 2010\] ZUMA](https://www.luogu.com.cn/problem/P5189)和[Vasya and Binary String](https://codeforces.com/problemset/problem/1107/E)

$P.S.$上面两道题都有另外一种设DP的状态

设$dp[l][r][k][kind]$表示$[l,r]$这个区间中最终删完之后剩下了$k$个种类为$kind$的元素的代价

$f[l][r]$表示$[l,r]$这个区间完全删完的代价

明显，可以用$dp[l][r][k][kind]$直接更新$f[l][r]$

$dp[l][r][k][kind]=f[l][i-1]+dp[i+1][r][k-1][kind](a[i]=kind)$

要有一个前提就是一定删除一个长度为$x$的区间$f(x)$优于$f(a)+f(b)$,$a+b=x$

所以剩下的一定是一个前缀（后缀，两个都可以）

# 5.DP转移状态有互相转移的情况

即DP转移建出来的图里面有环的情况

一句话：利用最短路思想，先把DP的初始状态放入堆中，然后利用状态之间的关系进行转移，跑最短路即可

其实就是废话

# 6.状压DP的优化

对于一些分层枚举的状压DP，往往是需要枚举子集进行转移，时间复杂度为$O(3^n)$

有一种方法可以优化到$O(n2^n)$，枚举子集可以换成尝试将一个点一个点加入到集合中，可以做$0/1$背包来进行转移，但空间需要多开一维

[Yet Another DAG Problem](https://codeforces.com/problemset/problem/1430/G)

# 7.拆分数优化DP

对于一些指数级别的DP，可以转化枚举某一个集合中具体是哪些元素为枚举集合的大小，当然这是在保证集合中的数是等价的情况，然后这个DP复杂度就变为拆分数级别的复杂度，一般来说可以跑$40-50$的数据规模

# 8.线头DP

比较有意思的DP方式

> 我们知道，线头 DP 是我们搞定一类只和两侧元素有关的排列问题的利器。
>
> 我们在数轴上，将排列中相邻的两个数连线，这样得到一条折线。以边为单位，考察穿过这条边的折线段的影响，进行动态规划。

就是DP过程就是补长拼接已有线段的过程

设计DP的方式可以（但不限于）考虑第$i$个元素和$i+1$个元素之间的那段距离被多少或者哪些线段经过，然后通过$i-1$个元素的状态转移出当前元素的状态

或者直接考虑加入某一个新的点，然后将两个线段拼接起来，得到新的状态

例题有[「BalticOI 2013」Vim]([#2687. 「BalticOI 2013」Vim - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/2687))和[2021省选训练 31Path]([XJOI](https://dev.xjoi.net/contest/1712))，还有一个（应该？）可以算是树上线头DP的题[CF830D Singer House](https://codeforces.com/contest/830/problem/D)

比如Vim那道题就是考虑$i$到$i+1$的之间这段长度只会被$1$条或者$3$条线段覆盖，由此设计两个DP状态，然后进行转移

Path那道题就是曼哈顿回路数量，很符合线头DP的适用范围，添加点就是拼接两条链

# 9.决策单调性的证明

如果可以证明，**不存在包含转移**，那么就可以说明，该DP具有决策单调性

# 10.值域和定义域交换

当定义域很大，值域比较小的情况时，可以考虑将值域和定义域交换