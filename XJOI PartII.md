# [ 2021省选训练40'](https://dev.xjoi.net/contest/1727)

# A.wsm

通过打表发现这个问题具有很强的递归性

如果对于已有的$A$中序列的数在数轴上表示出来，$1$代表出现，$0$代表不出现，整个序列的结果记作$T$

一开始$T=1$

可以发现如果将$T$原样复制若干遍$T'=TTTT...$仍然是合法的，$B$序列不变往后补$0$即可，并且$1$的个数乘上的复制的个数

由于$A,B$序列本质上是对称的，那么同样也可以在$A$序列后面补$0$，$T'=T(000...)_{|T|}(000...)_{|T|}...$

可以发现第一种操作使序列长度$*d$，$1$的个数$*d$，第二种操作使序列长度$*d$，$1$的个数不变，并且这两个操作是交替进行的

最终变为长度为$s$，$1$的个数为$m$的序列

考虑倒着考虑，设$f(s,m,0/1)$表示当前序列长度为$s$，$1$的个数为$m$的，$0$表示第一种操作，$1$表示第二种操作的方案数
$$
\begin{align}
&f(s,m,1)=\sum\limits_{d|m,d>1} f(\frac{s}{d},\frac{m}{d},0)
\\&f(s,m,0)=\sum\limits_{d|s,d>1}f(\frac{s}{d},m,1)
\end{align}
$$
边界$f(1,1,0)=f(1,1,1)=1$

注意到$1$操作要将$s,m$都除$d$，那么考虑将$s'=s/m$，递归式变为
$$
\begin{align}
&f(s,m,1)=\sum\limits_{d|m,d>1} f(s,\frac{m}{d},0)
\\&f(s,m,0)=\sum\limits_{d|s,d>1}f(\frac{s}{d},m,1)
\end{align}
$$
答案为$f(s',m,0)+f(s',m,1)$

本质上就是将两个数不断除掉其因数，求出$k$轮之后得到$1$的方案数，由于是交替除的，那么两者进行的轮数最多差$1$

设$g(n,k)$表示将$n$拆成$k$个有顺序的数$(>1)$的乘积的方案数

令$n=p_1^{r_1}p_2^{r_2}...p_m^{r_m}$

可以发现每一种质因数都是独立的，那么直接插板法即可，但是这些数不能为$1$，如果将这$k$个数看作$k$个盒子，那么在每一种质因数放完之后，任意一个盒子都不能为空

那么考虑容斥
$$
g(n,k)=\sum\limits_{i=0}^{k-1}\binom{k}{i}(-1)^i\prod\limits_{j=1}^m\binom{k-i+r_j-1}{r_j}
$$
预处理连乘，复杂度$O(log^2)$

那么最终答案就是$\sum\limits_{k\geq 1}g(s',k)g(m,k)+\sum\limits_{k\geq 1}g(s',k+1)g(m,k)+g(s',k)g(m,k+1)$

最终复杂度$O(Wlog^2)$

# B.完美串

首先可以发现如果在环的意义下，同时存在$00$和$11$，那么显然这个串是不完美的

那么假设当前串中$1$的个数比$0$多，那么将环意义下的所有极长连续段找出来

由于$1$的个数比$0$的个数多，那么任意一个极长连续$0$段的长度一定为$1$，如果从每一个连续$1$段中删去一个$1$，那么得到的$t$如果还是一个完美串，那么当前串$s$也一定是一个完美串

那么就可以将问题规模缩小，如果当前的$1$的个数为$a$，$0$的个数为$b$，那么进行一次操作之后就是$a-b,b$

类似与$gcd$过程，那么如果我们枚举初始的$0$的个数$x$ ，那么每一步是删$0$还是删$1$都是确定的，而这个过程是可逆的，于是可以从最后的终态还原出初始的$s$，不过由于中间的极长连续段是循环意义下的，因此得到的$s$也可以循环移位，这样可以得到恰有$\frac{n}{gcd(x,n)}$个有$x$个$0$的完美串 

用$bitset$优化即可

# C.行列式

首先注意到$p_i<i$那么如果在$i$和$p_i$之间连一条边，那么形成了一棵树的结构，那么接下来的思路应该与树相结合

首先需要考虑$x=0$的情况

那么矩阵中只有$(i,i),(i,p_i),(p_i,i)$上面有值，考虑将行列式展开，在枚举排列的时候，前面的系数是这个排列形成环的数量$(-1)^{cnt+n}$次

那么由于只有这些点上有不为$0$的值，那么相当于每一个环都是在树上形成，由于是树的结构，那么不能有长度大于$3$的环，那么只能是父亲儿子形成的二元环，还有自环

那么这个就是树形$DP$可以做的事了

那么再考虑$x!=0$的情况，那么将原矩阵拆成两个矩阵相加的形式

其中第一个$A$矩阵$b'_i=b_i-x,c'_i=c_i-x,d'_i=d_i-x$另外一个$B$矩阵为全$x$矩阵

展开$det(A+B)$，相当于是每一行都有两种可能，要么是A中的同一行，要么是B中的同一行，最终结果等于所有$2^n$矩阵中行列式之和

注意到如果得到的矩阵中有超过$1$行来自于$B$，那么可以将其中一行变为$0$，那么行列式的值也为$0$

那么最多只有一行来自于$B$

由于这一行都不为$0$，那么在树上相当于是任取了两个点，在这两个点之间连一条边，并且这两个点在树上的路径要连起来

这个也是可以DP的设$dp[x][0/1/2/3/4/5]$

0:表示当前节点没有匹配，并且子树内没有特殊环

1:表示当前节点已经匹配，并且子树内没有特殊环

2:表示当前节点没有匹配，并且子树内有特殊环

3:表示当前节点已经匹配，并且子树内有特殊环

4:表示当前节点已经匹配，并且处于环上的上升链中

5:表示当前节点已经匹配，并且处于环上的下降链中

# [ 清北夏令营与NOI训练3](https://dev.xjoi.net/contest/1755)

# B.数数

首先$\mu$相当于就是一个容斥系数，那么考虑题面上式子的组合意义

考虑$i$的每一个素因子，每一次容斥选出一个子集，使得其次数减一

考虑平方的含义，就是每一种素因子都有两个球，这两个球可以在次数个位置上任意放置

考虑加上两个球不能都在次数为0的位置的方案数，那么得到的容斥式子就是这个

那么所求变为$\sum\limits_{i=1}^n\sigma_0(i^2)$

 令$f(i)=\sigma_0(i^2)$

考虑$g=f*\mu$那么$g(n)=2^{W(n)}$，$W(n)$表示n不同素因子个数，证明也是一样的考虑组合意义，容斥得出
$$
\begin{align}
g&=f*\mu
\\I*g&=f*\mu*I=f
\\f(n)&=\sum\limits_{d|n}2^{W(d)}
\\f(n)&=\sum\limits_{d|i} \sum\limits_{k|d} |\mu(k)|
\\\sum\limits_{i=1}^nf(i)&=\sum\limits_{i=1}^n \sum\limits_{d|i} \sum\limits_{k|d} |\mu(k)|
\\&=\sum\limits_{d=1}^n\lfloor\frac{n}{d}\rfloor\sum\limits_{k|d}|\mu(k)|
\\&=\sum\limits_{k=1}^n|\mu(k)|\sum\limits_{d=1}^{\lfloor\frac{n}{k}\rfloor}\lfloor\frac{n}{kd}\rfloor
\end{align}
$$
令$F(n)=\sum\limits_{i=1}^n \sigma_0(i),M(n)=\sum\limits_{i=1}^n |\mu(i)|$
$$
M(n)=\sum\limits_{i^2\leq n} \mu(i)\lfloor \frac{n}{i^2} \rfloor
$$
这个考虑平方因子存在，然后容斥掉即可

那么整除分块即可，预处理的话，复杂度$O(n^{\frac{2}{3}})$

# [清北夏令营与NOI训练5](https://dev.xjoi.net/contest/1757)

# A.消除

首先就是一个构造

考虑每一次等概率随机一个排列，然后从前往后依次删去排列中的数，如果这个数在之前就已经删去了，那么就跳过这个数，一个排列合法，当且仅当这个按照这个排列删除的数的数量$\leq k$

结论就是生成合法排列的概率就是答案

考虑证明，可以发现，如果删除一个数需要附加删除$sz$个数，那么将这个$sz$任意的放到这个位置之后的排列中去，假如当前还有$m$个数未填入排列，其方案数为$\binom{m-1}{sz}sz!=(m-1)(m-2)...(m-sz)$

以此归纳下去，可以发现在连乘式中未出现的数，就是被选中这些数概率的分母，那么除以$n!$就是原来的答案

那么问题转化为（考虑这个排列的逆置换），对于每一个点分配一个互不相同的序号，一个数在被删除的点集中，当且仅当，这个点上的数是在所有其祖先内最小的那个，那么我们需要统计出所有合法点集大小$\leq k$的方案数

设$dp(x,i,j)$表示$x$子树内，来自祖先的限制在$x$子树内的排名为$i$，子树内有$j$个点合法的方案数

转移时需要将两个子树内的序号合并，由于来自祖先的限制相同，那么合并$dp(x,i,j)$和$dp(u,i',j')$其贡献为
$$
dp(x,i,j)dp(u,i',j')\binom{i+i'}{i}\binom{sz_x-i+sz_u-i'}{i}\rightarrow dp(x,i+i',j+j')
$$
最后加入当前根的限制，根据之前的大小关系进行更新即可

# B.排序

首先如果将序列看作环的话，那么可以发现操作可以得到较为简洁的解释

此处如果从1位置出发，顺时针将环断成序列，得到的是原序列，但是这样直接做会有很多特判，那么考虑将序列重新标号，使得逆时针标号递增

想象有一个指针指向1，每一次指针会逆时针旋转一个单位，每一次可以选择是否交换两个相邻的元素

将全0/1，只有一段连续0/1的特殊情况特判掉之后，可以发现最优移动策略一定是将环劈成两个部分，尽可能将1移动到两个部分交界的地方（其中一个），由于指针移动的时候只能向一个方向移动，那么有一部分需要将1尽可能带近分界点，另一部分尽可能的将0带离分界点

可以发现，指针旋转一周可以将分别$1$个0/1移动就位（当然还有一些特殊情况）

考虑枚举一段区间$[l,r]$使得$1$尽可能靠近$l$，并且$[l,r]$区间内的0尽可能被带离（这里可以$l>r$，因为是环上的）

记当前区间内的$0$个数为$a$，另外一部分中$1$个数为$b$

- $l\leq r$那么考虑指针第一次移动到$r+1$上过程中，区间$[0,l-1]$中的$1$可以带一个到$l$上，区间$[l,r]$中一个0可以被带到$r$上，那么就变成前面一段是需要带$1$接近$l$，并且有$b-1$个$1$，后面一部分有$a-1$个$0$，那么可以$O(1)$计算答案

  ```c++
  int a=get0(l,r),b=get1(1,l-1)+get1(r+1,n),pos=n-(r-l+1)-b;
  if (get1(1,l-1)>0) b--;
  ans=min(ans,r+max(a-1,b)*n+pos-1);
  ```

- $l>r$也是类似的分析，转化成前面一段，后面一段的形式

  ```c++
  int a=get0(1,r)+get0(l,n),b=get1(r+1,l-1),pos=l-r-1-b;
  if (get0(1,r)>0) a--;
  ans=min(ans,r+max(a,b)*n+pos-1);
  ```

直接去做复杂度$O(n^2)$考虑优化

以第一种情况为例，显然答案的式子为，令$s$表示$[1,l-1]$中$1$的个数
$$
n-l-b-2+n*\max(a-1,b-[s>0])
$$
由于$b\leq n$那么只要最小化$n*\max(a-1,b-[s>0])$即可，那么可以直接二分出结果，需要注意的是，如果取值相同的情况下，$b$要尽可能大，那么在二分出的位置左右两个位置也需要进行检查

第二种情况同理

